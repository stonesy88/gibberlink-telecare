import OpenAIOrignal, { AzureOpenAI } from 'openai';
import { PostHog } from 'posthog-node';
import { RequestOptions, APIPromise } from 'openai/core';
import { Stream } from 'openai/streaming';
import { LanguageModelV1 } from 'ai';
import AnthropicOriginal from '@anthropic-ai/sdk';
import { RequestOptions as RequestOptions$1, APIPromise as APIPromise$1 } from '@anthropic-ai/sdk/core';
import { Stream as Stream$1 } from '@anthropic-ai/sdk/streaming';
import { BaseCallbackHandler } from '@langchain/core/callbacks/base';
import { Serialized } from '@langchain/core/load/serializable';
import { ChainValues } from '@langchain/core/utils/types';
import { BaseMessage } from '@langchain/core/messages';
import { LLMResult } from '@langchain/core/outputs';
import { AgentAction, AgentFinish } from '@langchain/core/agents';
import { DocumentInterface } from '@langchain/core/documents';

interface MonitoringParams {
    posthogDistinctId?: string;
    posthogTraceId?: string;
    posthogProperties?: Record<string, any>;
    posthogPrivacyMode?: boolean;
    posthogGroups?: Record<string, any>;
    posthogModelOverride?: string;
    posthogProviderOverride?: string;
    posthogCostOverride?: CostOverride;
}
interface CostOverride {
    inputCost: number;
    outputCost: number;
}

type ChatCompletion$1 = OpenAIOrignal.ChatCompletion;
type ChatCompletionChunk$1 = OpenAIOrignal.ChatCompletionChunk;
type ChatCompletionCreateParamsBase$1 = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParams;
type ChatCompletionCreateParamsNonStreaming$1 = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParamsNonStreaming;
type ChatCompletionCreateParamsStreaming$1 = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParamsStreaming;

interface MonitoringOpenAIConfig$1 {
    apiKey: string;
    posthog: PostHog;
    baseURL?: string;
}
declare class PostHogOpenAI extends OpenAIOrignal {
    private readonly phClient;
    chat: WrappedChat$1;
    constructor(config: MonitoringOpenAIConfig$1);
}
declare class WrappedChat$1 extends OpenAIOrignal.Chat {
    constructor(parentClient: PostHogOpenAI, phClient: PostHog);
    completions: WrappedCompletions$1;
}
declare class WrappedCompletions$1 extends OpenAIOrignal.Chat.Completions {
    private readonly phClient;
    constructor(client: OpenAIOrignal, phClient: PostHog);
    create(body: ChatCompletionCreateParamsNonStreaming$1 & MonitoringParams, options?: RequestOptions): APIPromise<ChatCompletion$1>;
    create(body: ChatCompletionCreateParamsStreaming$1 & MonitoringParams, options?: RequestOptions): APIPromise<Stream<ChatCompletionChunk$1>>;
    create(body: ChatCompletionCreateParamsBase$1 & MonitoringParams, options?: RequestOptions): APIPromise<ChatCompletion$1 | Stream<ChatCompletionChunk$1>>;
}

type ChatCompletion = OpenAIOrignal.ChatCompletion;
type ChatCompletionChunk = OpenAIOrignal.ChatCompletionChunk;
type ChatCompletionCreateParamsBase = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParams;
type ChatCompletionCreateParamsNonStreaming = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParamsNonStreaming;
type ChatCompletionCreateParamsStreaming = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParamsStreaming;

interface MonitoringOpenAIConfig {
    apiKey: string;
    posthog: PostHog;
    baseURL?: string;
}
declare class PostHogAzureOpenAI extends AzureOpenAI {
    private readonly phClient;
    chat: WrappedChat;
    constructor(config: MonitoringOpenAIConfig);
}
declare class WrappedChat extends AzureOpenAI.Chat {
    constructor(parentClient: PostHogAzureOpenAI, phClient: PostHog);
    completions: WrappedCompletions;
}
declare class WrappedCompletions extends AzureOpenAI.Chat.Completions {
    private readonly phClient;
    constructor(client: AzureOpenAI, phClient: PostHog);
    create(body: ChatCompletionCreateParamsNonStreaming & MonitoringParams, options?: RequestOptions): APIPromise<ChatCompletion>;
    create(body: ChatCompletionCreateParamsStreaming & MonitoringParams, options?: RequestOptions): APIPromise<Stream<ChatCompletionChunk>>;
    create(body: ChatCompletionCreateParamsBase & MonitoringParams, options?: RequestOptions): APIPromise<ChatCompletion | Stream<ChatCompletionChunk>>;
}

interface ClientOptions {
    posthogDistinctId?: string;
    posthogTraceId?: string;
    posthogProperties?: Record<string, any>;
    posthogPrivacyMode?: boolean;
    posthogGroups?: Record<string, any>;
    posthogModelOverride?: string;
    posthogProviderOverride?: string;
    posthogCostOverride?: CostOverride;
}
declare const wrapVercelLanguageModel: (model: LanguageModelV1, phClient: PostHog, options: ClientOptions) => LanguageModelV1;

type MessageCreateParamsNonStreaming = AnthropicOriginal.Messages.MessageCreateParamsNonStreaming;
type MessageCreateParamsStreaming = AnthropicOriginal.Messages.MessageCreateParamsStreaming;
type Message = AnthropicOriginal.Messages.Message;
type RawMessageStreamEvent = AnthropicOriginal.Messages.RawMessageStreamEvent;
type MessageCreateParamsBase = AnthropicOriginal.Messages.MessageCreateParams;

interface MonitoringAnthropicConfig {
    apiKey: string;
    posthog: PostHog;
    baseURL?: string;
}
declare class PostHogAnthropic extends AnthropicOriginal {
    private readonly phClient;
    messages: WrappedMessages;
    constructor(config: MonitoringAnthropicConfig);
}
declare class WrappedMessages extends AnthropicOriginal.Messages {
    private readonly phClient;
    constructor(parentClient: PostHogAnthropic, phClient: PostHog);
    create(body: MessageCreateParamsNonStreaming, options?: RequestOptions$1): APIPromise$1<Message>;
    create(body: MessageCreateParamsStreaming & MonitoringParams, options?: RequestOptions$1): APIPromise$1<Stream$1<RawMessageStreamEvent>>;
    create(body: MessageCreateParamsBase & MonitoringParams, options?: RequestOptions$1): APIPromise$1<Stream$1<RawMessageStreamEvent> | Message>;
}

declare class LangChainCallbackHandler extends BaseCallbackHandler {
    name: string;
    private client;
    private distinctId?;
    private traceId?;
    private properties;
    private privacyMode;
    private groups;
    private debug;
    private runs;
    private parentTree;
    constructor(options: {
        client: PostHog;
        distinctId?: string | number;
        traceId?: string | number;
        properties?: Record<string, any>;
        privacyMode?: boolean;
        groups?: Record<string, any>;
        debug?: boolean;
    });
    handleChainStart(chain: Serialized, inputs: ChainValues, runId: string, parentRunId?: string, tags?: string[], metadata?: Record<string, unknown>, runType?: string, runName?: string): void;
    handleChainEnd(outputs: ChainValues, runId: string, parentRunId?: string, tags?: string[], kwargs?: {
        inputs?: Record<string, unknown>;
    }): void;
    handleChainError(error: Error, runId: string, parentRunId?: string, tags?: string[], kwargs?: {
        inputs?: Record<string, unknown>;
    }): void;
    handleChatModelStart(serialized: Serialized, messages: BaseMessage[][], runId: string, parentRunId?: string, extraParams?: Record<string, unknown>, tags?: string[], metadata?: Record<string, unknown>, runName?: string): void;
    handleLLMStart(serialized: Serialized, prompts: string[], runId: string, parentRunId?: string, extraParams?: Record<string, unknown>, tags?: string[], metadata?: Record<string, unknown>, runName?: string): void;
    handleLLMEnd(output: LLMResult, runId: string, parentRunId?: string, tags?: string[], extraParams?: Record<string, unknown>): void;
    handleLLMError(err: Error, runId: string, parentRunId?: string, tags?: string[], extraParams?: Record<string, unknown>): void;
    handleToolStart(tool: Serialized, input: string, runId: string, parentRunId?: string, tags?: string[], metadata?: Record<string, unknown>, runName?: string): void;
    handleToolEnd(output: any, runId: string, parentRunId?: string, tags?: string[]): void;
    handleToolError(err: Error, runId: string, parentRunId?: string, tags?: string[]): void;
    handleRetrieverStart(retriever: Serialized, query: string, runId: string, parentRunId?: string, tags?: string[], metadata?: Record<string, unknown>, name?: string): void;
    handleRetrieverEnd(documents: DocumentInterface[], runId: string, parentRunId?: string, tags?: string[]): void;
    handleRetrieverError(err: Error, runId: string, parentRunId?: string, tags?: string[]): void;
    handleAgentAction(action: AgentAction, runId: string, parentRunId?: string, tags?: string[]): void;
    handleAgentEnd(action: AgentFinish, runId: string, parentRunId?: string, tags?: string[]): void;
    private _setParentOfRun;
    private _popParentOfRun;
    private _findRootRun;
    private _setTraceOrSpanMetadata;
    private _setLLMMetadata;
    private _popRunMetadata;
    private _getTraceId;
    private _getParentRunId;
    private _popRunAndCaptureTraceOrSpan;
    private _captureTraceOrSpan;
    private _popRunAndCaptureGeneration;
    private _captureGeneration;
    private _logDebugEvent;
    private _getLangchainRunName;
    private _convertMessageToDict;
    private _parseUsageModel;
    private parseUsage;
}

export { PostHogAnthropic as Anthropic, PostHogAzureOpenAI as AzureOpenAI, LangChainCallbackHandler, PostHogOpenAI as OpenAI, wrapVercelLanguageModel as withTracing };
