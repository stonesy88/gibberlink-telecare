"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/audiomotion-analyzer";
exports.ids = ["vendor-chunks/audiomotion-analyzer"];
exports.modules = {

/***/ "(ssr)/./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioMotionAnalyzer: () => (/* binding */ AudioMotionAnalyzer),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**!\n * audioMotion-analyzer\n * High-resolution real-time graphic audio spectrum analyzer JS module\n *\n * @version 4.5.0\n * @author  Henrique Avila Vianna <hvianna@gmail.com> <https://henriquevianna.com>\n * @license AGPL-3.0-or-later\n */\n\nconst VERSION = '4.5.0';\n\n// internal constants\nconst PI      = Math.PI,\n\t  TAU     = 2 * PI,\n\t  HALF_PI = PI / 2,\n\t  C_1     = 8.17579892;  // frequency for C -1\n\nconst CANVAS_BACKGROUND_COLOR  = '#000',\n\t  CHANNEL_COMBINED         = 'dual-combined',\n\t  CHANNEL_HORIZONTAL       = 'dual-horizontal',\n\t  CHANNEL_SINGLE           = 'single',\n\t  CHANNEL_VERTICAL         = 'dual-vertical',\n\t  COLOR_BAR_INDEX          = 'bar-index',\n\t  COLOR_BAR_LEVEL          = 'bar-level',\n\t  COLOR_GRADIENT           = 'gradient',\n\t  DEBOUNCE_TIMEOUT         = 60,\n\t  EVENT_CLICK              = 'click',\n\t  EVENT_FULLSCREENCHANGE   = 'fullscreenchange',\n\t  EVENT_RESIZE             = 'resize',\n \t  GRADIENT_DEFAULT_BGCOLOR = '#111',\n \t  FILTER_NONE              = '',\n \t  FILTER_A                 = 'A',\n \t  FILTER_B                 = 'B',\n \t  FILTER_C                 = 'C',\n \t  FILTER_D                 = 'D',\n \t  FILTER_468               = '468',\n\t  FONT_FAMILY              = 'sans-serif',\n\t  FPS_COLOR                = '#0f0',\n\t  LEDS_UNLIT_COLOR         = '#7f7f7f22',\n\t  MODE_GRAPH               = 10,\n\t  REASON_CREATE            = 'create',\n\t  REASON_FSCHANGE          = 'fschange',\n\t  REASON_LORES             = 'lores',\n\t  REASON_RESIZE            = EVENT_RESIZE,\n\t  REASON_USER              = 'user',\n\t  SCALEX_BACKGROUND_COLOR  = '#000c',\n\t  SCALEX_LABEL_COLOR       = '#fff',\n\t  SCALEX_HIGHLIGHT_COLOR   = '#4f4',\n\t  SCALEY_LABEL_COLOR       = '#888',\n\t  SCALEY_MIDLINE_COLOR     = '#555',\n\t  SCALE_BARK               = 'bark',\n\t  SCALE_LINEAR             = 'linear',\n\t  SCALE_LOG                = 'log',\n\t  SCALE_MEL                = 'mel';\n\n// built-in gradients\nconst PRISM = [ '#a35', '#c66', '#e94', '#ed0', '#9d5', '#4d8', '#2cb', '#0bc', '#09c', '#36b' ],\n\t  GRADIENTS = [\n\t  [ 'classic', {\n\t\t\tcolorStops: [\n\t\t\t\t'red',\n\t\t\t\t{ color: 'yellow', level: .85, pos: .6 },\n\t\t\t\t{ color: 'lime', level: .475 }\n\t\t\t]\n\t  }],\n\t  [ 'prism', {\n\t\t\tcolorStops: PRISM\n\t  }],\n\t  [ 'rainbow', {\n\t\t\tdir: 'h',\n\t\t\tcolorStops: [ '#817', ...PRISM, '#639' ]\n\t  }],\n\t  [ 'orangered', {\n\t  \t\tbgColor: '#3e2f29',\n\t  \t\tcolorStops: [ 'OrangeRed' ]\n\t  }],\n\t  [ 'steelblue', {\n\t  \t\tbgColor: '#222c35',\n\t  \t\tcolorStops: [ 'SteelBlue' ]\n\t  }]\n];\n\n// settings defaults\nconst DEFAULT_SETTINGS = {\n\talphaBars      : false,\n\tansiBands      : false,\n\tbarSpace       : 0.1,\n\tbgAlpha        : 0.7,\n\tchannelLayout  : CHANNEL_SINGLE,\n\tcolorMode      : COLOR_GRADIENT,\n\tfadePeaks      : false,\n\tfftSize        : 8192,\n\tfillAlpha      : 1,\n\tfrequencyScale : SCALE_LOG,\n\tgradient       : GRADIENTS[0][0],\n\tgravity        : 3.8,\n\theight         : undefined,\n\tledBars        : false,\n\tlinearAmplitude: false,\n\tlinearBoost    : 1,\n\tlineWidth      : 0,\n\tloRes          : false,\n\tlumiBars       : false,\n\tmaxDecibels    : -25,\n\tmaxFPS         : 0,\n\tmaxFreq        : 22000,\n\tminDecibels    : -85,\n\tminFreq        : 20,\n\tmirror         : 0,\n\tmode           : 0,\n\tnoteLabels     : false,\n\toutlineBars    : false,\n\toverlay        : false,\n\tpeakFadeTime   : 750,\n\tpeakHoldTime   : 500,\n\tpeakLine       : false,\n\tradial\t\t   : false,\n\tradialInvert   : false,\n\tradius         : 0.3,\n\treflexAlpha    : 0.15,\n\treflexBright   : 1,\n\treflexFit      : true,\n\treflexRatio    : 0,\n\troundBars      : false,\n\tshowBgColor    : true,\n\tshowFPS        : false,\n\tshowPeaks      : true,\n\tshowScaleX     : true,\n\tshowScaleY     : false,\n\tsmoothing      : 0.5,\n\tspinSpeed      : 0,\n\tsplitGradient  : false,\n\tstart          : true,\n\ttrueLeds       : false,\n\tuseCanvas      : true,\n\tvolume         : 1,\n\tweightingFilter: FILTER_NONE,\n\twidth          : undefined\n};\n\n// custom error messages\nconst ERR_AUDIO_CONTEXT_FAIL     = [ 'ERR_AUDIO_CONTEXT_FAIL', 'Could not create audio context. Web Audio API not supported?' ],\n\t  ERR_INVALID_AUDIO_CONTEXT  = [ 'ERR_INVALID_AUDIO_CONTEXT', 'Provided audio context is not valid' ],\n\t  ERR_UNKNOWN_GRADIENT       = [ 'ERR_UNKNOWN_GRADIENT', 'Unknown gradient' ],\n\t  ERR_FREQUENCY_TOO_LOW      = [ 'ERR_FREQUENCY_TOO_LOW', 'Frequency values must be >= 1' ],\n\t  ERR_INVALID_MODE           = [ 'ERR_INVALID_MODE', 'Invalid mode' ],\n\t  ERR_REFLEX_OUT_OF_RANGE    = [ 'ERR_REFLEX_OUT_OF_RANGE', 'Reflex ratio must be >= 0 and < 1' ],\n\t  ERR_INVALID_AUDIO_SOURCE   = [ 'ERR_INVALID_AUDIO_SOURCE', 'Audio source must be an instance of HTMLMediaElement or AudioNode' ],\n\t  ERR_GRADIENT_INVALID_NAME  = [ 'ERR_GRADIENT_INVALID_NAME', 'Gradient name must be a non-empty string' ],\n\t  ERR_GRADIENT_NOT_AN_OBJECT = [ 'ERR_GRADIENT_NOT_AN_OBJECT', 'Gradient options must be an object' ],\n\t  ERR_GRADIENT_MISSING_COLOR = [ 'ERR_GRADIENT_MISSING_COLOR', 'Gradient colorStops must be a non-empty array' ];\n\nclass AudioMotionError extends Error {\n\tconstructor( error, value ) {\n\t\tconst [ code, message ] = error;\n\t\tsuper( message + ( value !== undefined ? `: ${value}` : '' ) );\n\t\tthis.name = 'AudioMotionError';\n\t\tthis.code = code;\n\t}\n}\n\n// helper function - output deprecation warning message on console\nconst deprecate = ( name, alternative ) => console.warn( `${name} is deprecated. Use ${alternative} instead.` );\n\n// helper function - check if a given object is empty (also returns `true` on null, undefined or any non-object value)\nconst isEmpty = obj => {\n\tfor ( const p in obj )\n\t\treturn false;\n\treturn true;\n}\n\n// helper function - validate a given value with an array of strings (by default, all lowercase)\n// returns the validated value, or the first element of `list` if `value` is not found in the array\nconst validateFromList = ( value, list, modifier = 'toLowerCase' ) => list[ Math.max( 0, list.indexOf( ( '' + value )[ modifier ]() ) ) ];\n\n// helper function - find the Y-coordinate of a point located between two other points, given its X-coordinate\nconst findY = ( x1, y1, x2, y2, x ) => y1 + ( y2 - y1 ) * ( x - x1 ) / ( x2 - x1 );\n\n// Polyfill for Array.findLastIndex()\nif ( ! Array.prototype.findLastIndex ) {\n\tArray.prototype.findLastIndex = function( callback ) {\n\t\tlet index = this.length;\n\t\twhile ( index-- > 0 ) {\n\t\t\tif ( callback( this[ index ] ) )\n\t\t\t\treturn index;\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n// AudioMotionAnalyzer class\n\nclass AudioMotionAnalyzer {\n\n/**\n * CONSTRUCTOR\n *\n * @param {object} [container] DOM element where to insert the analyzer; if undefined, uses the document body\n * @param {object} [options]\n * @returns {object} AudioMotionAnalyzer object\n */\n\tconstructor( container, options = {} ) {\n\n\t\tthis._ready = false;\n\n\t\t// Initialize internal objects\n\t\tthis._aux = {};\t\t\t\t// auxiliary variables\n\t\tthis._canvasGradients = []; // CanvasGradient objects for channels 0 and 1\n\t\tthis._destroyed = false;\n\t\tthis._energy = { val: 0, peak: 0, hold: 0 };\n\t\tthis._flg = {};\t\t\t\t// flags\n\t\tthis._fps = 0;\n\t\tthis._gradients = {};       // registered gradients\n\t\tthis._last = 0;\t\t\t\t// timestamp of last rendered frame\n\t\tthis._outNodes = [];\t\t// output nodes\n\t\tthis._ownContext = false;\n\t\tthis._selectedGrads = [];   // names of the currently selected gradients for channels 0 and 1\n\t\tthis._sources = [];\t\t\t// input nodes\n\n\t\t// Check if options object passed as first argument\n\t\tif ( ! ( container instanceof Element ) ) {\n\t\t\tif ( isEmpty( options ) && ! isEmpty( container ) )\n\t\t\t\toptions = container;\n\t\t\tcontainer = null;\n\t\t}\n\n\t\tthis._ownCanvas = ! ( options.canvas instanceof HTMLCanvasElement );\n\n\t\t// Create a new canvas or use the one provided by the user\n\t\tconst canvas = this._ownCanvas ? document.createElement('canvas') : options.canvas;\n\t\tcanvas.style = 'max-width: 100%;';\n\t\tthis._ctx = canvas.getContext('2d');\n\n\t\t// Register built-in gradients\n\t\tfor ( const [ name, options ] of GRADIENTS )\n\t\t\tthis.registerGradient( name, options );\n\n\t\t// Set container\n\t\tthis._container = container || ( ! this._ownCanvas && canvas.parentElement ) || document.body;\n\n\t\t// Make sure we have minimal width and height dimensions in case of an inline container\n\t\tthis._defaultWidth  = this._container.clientWidth  || 640;\n\t\tthis._defaultHeight = this._container.clientHeight || 270;\n\n\t\t// Use audio context provided by user, or create a new one\n\n\t\tlet audioCtx;\n\n\t\tif ( options.source && ( audioCtx = options.source.context ) ) {\n\t\t\t// get audioContext from provided source audioNode\n\t\t}\n\t\telse if ( audioCtx = options.audioCtx ) {\n\t\t\t// use audioContext provided by user\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\taudioCtx = new ( window.AudioContext || window.webkitAudioContext )();\n\t\t\t\tthis._ownContext = true;\n\t\t\t}\n\t\t\tcatch( err ) {\n\t\t\t\tthrow new AudioMotionError( ERR_AUDIO_CONTEXT_FAIL );\n\t\t\t}\n\t\t}\n\n\t\t// make sure audioContext is valid\n\t\tif ( ! audioCtx.createGain )\n\t\t\tthrow new AudioMotionError( ERR_INVALID_AUDIO_CONTEXT );\n\n\t\t/*\n\t\t\tConnection routing:\n\t\t\t===================\n\n\t\t\tfor dual channel layouts:                +--->  analyzer[0]  ---+\n\t\t    \t                                     |                      |\n\t\t\t(source) --->  input  --->  splitter  ---+                      +--->  merger  --->  output  ---> (destination)\n\t\t    \t                                     |                      |\n\t\t        \t                                 +--->  analyzer[1]  ---+\n\n\t\t\tfor single channel layout:\n\n\t\t\t(source) --->  input  ----------------------->  analyzer[0]  --------------------->  output  ---> (destination)\n\n\t\t*/\n\n\t\t// create the analyzer nodes, channel splitter and merger, and gain nodes for input/output connections\n\t\tconst analyzer = this._analyzer = [ audioCtx.createAnalyser(), audioCtx.createAnalyser() ];\n\t\tconst splitter = this._splitter = audioCtx.createChannelSplitter(2);\n \t\tconst merger   = this._merger   = audioCtx.createChannelMerger(2);\n \t\tthis._input    = audioCtx.createGain();\n \t\tthis._output   = audioCtx.createGain();\n\n \t\t// connect audio source if provided in the options\n\t\tif ( options.source )\n\t\t\tthis.connectInput( options.source );\n\n \t\t// connect splitter -> analyzers\n \t\tfor ( const i of [0,1] )\n\t\t\tsplitter.connect( analyzer[ i ], i );\n\n\t\t// connect merger -> output\n\t\tmerger.connect( this._output );\n\n\t\t// connect output -> destination (speakers)\n\t\tif ( options.connectSpeakers !== false )\n\t\t\tthis.connectOutput();\n\n\t\t// create auxiliary canvases for the X-axis and radial scale labels\n\t\tfor ( const ctx of [ '_scaleX', '_scaleR' ] )\n\t\t\tthis[ ctx ] = document.createElement('canvas').getContext('2d');\n\n\t\t// set fullscreen element (defaults to canvas)\n\t\tthis._fsEl = options.fsElement || canvas;\n\n\t\t// Update canvas size on container / window resize and fullscreen events\n\n\t\t// Fullscreen changes are handled quite differently across browsers:\n\t\t// 1. Chromium browsers will trigger a `resize` event followed by a `fullscreenchange`\n\t\t// 2. Firefox triggers the `fullscreenchange` first and then the `resize`\n\t\t// 3. Chrome on Android (TV) won't trigger a `resize` event, only `fullscreenchange`\n\t\t// 4. Safari won't trigger `fullscreenchange` events at all, and on iPadOS the `resize`\n\t\t//    event is triggered **on the window** only (last tested on iPadOS 14)\n\n\t\t// helper function for resize events\n\t\tconst onResize = () => {\n\t\t\tif ( ! this._fsTimeout ) {\n\t\t\t\t// delay the resize to prioritize a possible following `fullscreenchange` event\n\t\t\t\tthis._fsTimeout = window.setTimeout( () => {\n\t\t\t\t\tif ( ! this._fsChanging ) {\n\t\t\t\t\t\tthis._setCanvas( REASON_RESIZE );\n\t\t\t\t\t\tthis._fsTimeout = 0;\n\t\t\t\t\t}\n\t\t\t\t}, DEBOUNCE_TIMEOUT );\n\t\t\t}\n\t\t}\n\n\t\t// if browser supports ResizeObserver, listen for resize on the container\n\t\tif ( window.ResizeObserver ) {\n\t\t\tthis._observer = new ResizeObserver( onResize );\n\t\t\tthis._observer.observe( this._container );\n\t\t}\n\n\t\t// create an AbortController to remove event listeners on destroy()\n\t\tthis._controller = new AbortController();\n\t\tconst signal = this._controller.signal;\n\n\t\t// listen for resize events on the window - required for fullscreen on iPadOS\n\t\twindow.addEventListener( EVENT_RESIZE, onResize, { signal } );\n\n\t\t// listen for fullscreenchange events on the canvas - not available on Safari\n\t\tcanvas.addEventListener( EVENT_FULLSCREENCHANGE, () => {\n\t\t\t// set flag to indicate a fullscreen change in progress\n\t\t\tthis._fsChanging = true;\n\n\t\t\t// if there is a scheduled resize event, clear it\n\t\t\tif ( this._fsTimeout )\n\t\t\t\twindow.clearTimeout( this._fsTimeout );\n\n\t\t\t// update the canvas\n\t\t\tthis._setCanvas( REASON_FSCHANGE );\n\n\t\t\t// delay clearing the flag to prevent any shortly following resize event\n\t\t\tthis._fsTimeout = window.setTimeout( () => {\n\t\t\t\tthis._fsChanging = false;\n\t\t\t\tthis._fsTimeout = 0;\n\t\t\t}, DEBOUNCE_TIMEOUT );\n\t\t}, { signal } );\n\n\t\t// Resume audio context if in suspended state (browsers' autoplay policy)\n\t\tconst unlockContext = () => {\n\t\t\tif ( audioCtx.state == 'suspended' )\n\t\t\t\taudioCtx.resume();\n\t\t\twindow.removeEventListener( EVENT_CLICK, unlockContext );\n\t\t}\n\t\twindow.addEventListener( EVENT_CLICK, unlockContext );\n\n\t\t// reset FPS-related variables when window becomes visible (avoid FPS drop due to frames not rendered while hidden)\n\t\tdocument.addEventListener( 'visibilitychange', () => {\n\t\t\tif ( document.visibilityState != 'hidden' ) {\n\t\t\t\tthis._frames = 0;\n\t\t\t\tthis._time = performance.now();\n\t\t\t}\n\t\t}, { signal } );\n\n\t\t// Set configuration options and use defaults for any missing properties\n\t\tthis._setProps( options, true );\n\n\t\t// Add canvas to the container (only when canvas not provided by user)\n\t\tif ( this.useCanvas && this._ownCanvas )\n\t\t\tthis._container.appendChild( canvas );\n\n\t\t// Finish canvas setup\n\t\tthis._ready = true;\n\t\tthis._setCanvas( REASON_CREATE );\n\t}\n\n\t/**\n\t * ==========================================================================\n\t *\n\t * PUBLIC PROPERTIES GETTERS AND SETTERS\n\t *\n\t * ==========================================================================\n\t */\n\n\tget alphaBars() {\n\t\treturn this._alphaBars;\n\t}\n\tset alphaBars( value ) {\n\t\tthis._alphaBars = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget ansiBands() {\n\t\treturn this._ansiBands;\n\t}\n\tset ansiBands( value ) {\n\t\tthis._ansiBands = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget barSpace() {\n\t\treturn this._barSpace;\n\t}\n\tset barSpace( value ) {\n\t\tthis._barSpace = +value || 0;\n\t\tthis._calcBars();\n\t}\n\n\tget channelLayout() {\n\t\treturn this._chLayout;\n\t}\n\tset channelLayout( value ) {\n\t\tthis._chLayout = validateFromList( value, [ CHANNEL_SINGLE, CHANNEL_HORIZONTAL, CHANNEL_VERTICAL, CHANNEL_COMBINED ] );\n\n\t\t// update node connections\n\t\tthis._input.disconnect();\n\t\tthis._input.connect( this._chLayout != CHANNEL_SINGLE ? this._splitter : this._analyzer[0] );\n\t\tthis._analyzer[0].disconnect();\n\t\tif ( this._outNodes.length ) // connect analyzer only if the output is connected to other nodes\n\t\t\tthis._analyzer[0].connect( this._chLayout != CHANNEL_SINGLE ? this._merger : this._output );\n\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget colorMode() {\n\t\treturn this._colorMode;\n\t}\n\tset colorMode( value ) {\n\t\tthis._colorMode = validateFromList( value, [ COLOR_GRADIENT, COLOR_BAR_INDEX, COLOR_BAR_LEVEL ] );\n\t}\n\n\tget fadePeaks() {\n\t\treturn this._fadePeaks;\n\t}\n\tset fadePeaks( value ) {\n\t\tthis._fadePeaks = !! value;\n\t}\n\n\tget fftSize() {\n\t\treturn this._analyzer[0].fftSize;\n\t}\n\tset fftSize( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].fftSize = value;\n\t\tconst binCount = this._analyzer[0].frequencyBinCount;\n\t\tthis._fftData = [ new Float32Array( binCount ), new Float32Array( binCount ) ];\n\t\tthis._calcBars();\n\t}\n\n\tget frequencyScale() {\n\t\treturn this._frequencyScale;\n\t}\n\tset frequencyScale( value ) {\n\t\tthis._frequencyScale = validateFromList( value, [ SCALE_LOG, SCALE_BARK, SCALE_MEL, SCALE_LINEAR ] );\n\t\tthis._calcBars();\n\t}\n\n\tget gradient() {\n\t\treturn this._selectedGrads[0];\n\t}\n\tset gradient( value ) {\n\t\tthis._setGradient( value );\n\t}\n\n\tget gradientLeft() {\n\t\treturn this._selectedGrads[0];\n\t}\n\tset gradientLeft( value ) {\n\t\tthis._setGradient( value, 0 );\n\t}\n\n\tget gradientRight() {\n\t\treturn this._selectedGrads[1];\n\t}\n\tset gradientRight( value ) {\n\t\tthis._setGradient( value, 1 );\n\t}\n\n\tget gravity() {\n\t\treturn this._gravity;\n\t}\n\tset gravity( value ) {\n\t\tthis._gravity = value > 0 ? +value : this._gravity || DEFAULT_SETTINGS.gravity;\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\tset height( h ) {\n\t\tthis._height = h;\n\t\tthis._setCanvas( REASON_USER );\n\t}\n\n\tget ledBars() {\n\t\treturn this._showLeds;\n\t}\n\tset ledBars( value ) {\n\t\tthis._showLeds = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget linearAmplitude() {\n\t\treturn this._linearAmplitude;\n\t}\n\tset linearAmplitude( value ) {\n\t\tthis._linearAmplitude = !! value;\n\t}\n\n\tget linearBoost() {\n\t\treturn this._linearBoost;\n\t}\n\tset linearBoost( value ) {\n\t\tthis._linearBoost = value >= 1 ? +value : 1;\n\t}\n\n\tget lineWidth() {\n\t\treturn this._lineWidth;\n\t}\n\tset lineWidth( value ) {\n\t\tthis._lineWidth = +value || 0;\n\t}\n\n\tget loRes() {\n\t\treturn this._loRes;\n\t}\n\tset loRes( value ) {\n\t\tthis._loRes = !! value;\n\t\tthis._setCanvas( REASON_LORES );\n\t}\n\n\tget lumiBars() {\n\t\treturn this._lumiBars;\n\t}\n\tset lumiBars( value ) {\n\t\tthis._lumiBars = !! value;\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget maxDecibels() {\n\t\treturn this._analyzer[0].maxDecibels;\n\t}\n\tset maxDecibels( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].maxDecibels = value;\n\t}\n\n\tget maxFPS() {\n\t\treturn this._maxFPS;\n\t}\n\tset maxFPS( value ) {\n\t\tthis._maxFPS = value < 0 ? 0 : +value || 0;\n\t}\n\n\tget maxFreq() {\n\t\treturn this._maxFreq;\n\t}\n\tset maxFreq( value ) {\n\t\tif ( value < 1 )\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\n\t\telse {\n\t\t\tthis._maxFreq = Math.min( value, this.audioCtx.sampleRate / 2 );\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\tget minDecibels() {\n\t\treturn this._analyzer[0].minDecibels;\n\t}\n\tset minDecibels( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].minDecibels = value;\n\t}\n\n\tget minFreq() {\n\t\treturn this._minFreq;\n\t}\n\tset minFreq( value ) {\n\t\tif ( value < 1 )\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\n\t\telse {\n\t\t\tthis._minFreq = +value;\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\tget mirror() {\n\t\treturn this._mirror;\n\t}\n\tset mirror( value ) {\n\t\tthis._mirror = Math.sign( value ) | 0; // ensure only -1, 0 or 1\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget mode() {\n\t\treturn this._mode;\n\t}\n\tset mode( value ) {\n\t\tconst mode = value | 0;\n\t\tif ( mode >= 0 && mode <= 10 && mode != 9 ) {\n\t\t\tthis._mode = mode;\n\t\t\tthis._calcBars();\n\t\t\tthis._makeGrad();\n\t\t}\n\t\telse\n\t\t\tthrow new AudioMotionError( ERR_INVALID_MODE, value );\n\t}\n\n\tget noteLabels() {\n\t\treturn this._noteLabels;\n\t}\n\tset noteLabels( value ) {\n\t\tthis._noteLabels = !! value;\n\t\tthis._createScales();\n\t}\n\n\tget outlineBars() {\n\t\treturn this._outlineBars;\n\t}\n\tset outlineBars( value ) {\n\t\tthis._outlineBars = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget peakFadeTime() {\n\t\treturn this._peakFadeTime;\n\t}\n\tset peakFadeTime( value ) {\n\t\tthis._peakFadeTime = value >= 0 ? +value : this._peakFadeTime || DEFAULT_SETTINGS.peakFadeTime;\n\t}\n\n\tget peakHoldTime() {\n\t\treturn this._peakHoldTime;\n\t}\n\tset peakHoldTime( value ) {\n\t\tthis._peakHoldTime = +value || 0;\n\t}\n\n\tget peakLine() {\n\t\treturn this._peakLine;\n\t}\n\tset peakLine( value ) {\n\t\tthis._peakLine = !! value;\n\t}\n\n\tget radial() {\n\t\treturn this._radial;\n\t}\n\tset radial( value ) {\n\t\tthis._radial = !! value;\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget radialInvert() {\n\t\treturn this._radialInvert;\n\t}\n\tset radialInvert( value ) {\n\t\tthis._radialInvert = !! value;\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget radius() {\n\t\treturn this._radius;\n\t}\n\tset radius( value ) {\n\t\tthis._radius = +value || 0;\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget reflexRatio() {\n\t\treturn this._reflexRatio;\n\t}\n\tset reflexRatio( value ) {\n\t\tvalue = +value || 0;\n\t\tif ( value < 0 || value >= 1 )\n\t\t\tthrow new AudioMotionError( ERR_REFLEX_OUT_OF_RANGE );\n\t\telse {\n\t\t\tthis._reflexRatio = value;\n\t\t\tthis._calcBars();\n\t\t\tthis._makeGrad();\n\t\t}\n\t}\n\n\tget roundBars() {\n\t\treturn this._roundBars;\n\t}\n\tset roundBars( value ) {\n\t\tthis._roundBars = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget smoothing() {\n\t\treturn this._analyzer[0].smoothingTimeConstant;\n\t}\n\tset smoothing( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].smoothingTimeConstant = value;\n\t}\n\n\tget spinSpeed() {\n\t\treturn this._spinSpeed;\n\t}\n\tset spinSpeed( value ) {\n\t\tvalue = +value || 0;\n\t\tif ( this._spinSpeed === undefined || value == 0 )\n\t\t\tthis._spinAngle = -HALF_PI; // initialize or reset the rotation angle\n\t\tthis._spinSpeed = value;\n\t}\n\n\tget splitGradient() {\n\t\treturn this._splitGradient;\n\t}\n\tset splitGradient( value ) {\n\t\tthis._splitGradient = !! value;\n\t\tthis._makeGrad();\n\t}\n\n\tget stereo() {\n\t\tdeprecate( 'stereo', 'channelLayout' );\n\t\treturn this._chLayout != CHANNEL_SINGLE;\n\t}\n\tset stereo( value ) {\n\t\tdeprecate( 'stereo', 'channelLayout' );\n\t\tthis.channelLayout = value ? CHANNEL_VERTICAL : CHANNEL_SINGLE;\n\t}\n\n\tget trueLeds() {\n\t\treturn this._trueLeds;\n\t}\n\tset trueLeds( value ) {\n\t\tthis._trueLeds = !! value;\n\t}\n\n\tget volume() {\n\t\treturn this._output.gain.value;\n\t}\n\tset volume( value ) {\n\t\tthis._output.gain.value = value;\n\t}\n\n\tget weightingFilter() {\n\t\treturn this._weightingFilter;\n\t}\n\tset weightingFilter( value ) {\n\t\tthis._weightingFilter = validateFromList( value, [ FILTER_NONE, FILTER_A, FILTER_B, FILTER_C, FILTER_D, FILTER_468 ], 'toUpperCase' );\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\tset width( w ) {\n\t\tthis._width = w;\n\t\tthis._setCanvas( REASON_USER );\n\t}\n\n\t// Read only properties\n\n\tget audioCtx() {\n\t\treturn this._input.context;\n\t}\n\tget canvas() {\n\t\treturn this._ctx.canvas;\n\t}\n\tget canvasCtx() {\n\t\treturn this._ctx;\n\t}\n\tget connectedSources() {\n\t\treturn this._sources;\n\t}\n\tget connectedTo() {\n\t\treturn this._outNodes;\n\t}\n\tget fps() {\n\t\treturn this._fps;\n\t}\n\tget fsHeight() {\n\t\treturn this._fsHeight;\n\t}\n\tget fsWidth() {\n\t\treturn this._fsWidth;\n\t}\n\tget isAlphaBars() {\n\t\treturn this._flg.isAlpha;\n\t}\n\tget isBandsMode() {\n\t\treturn this._flg.isBands;\n\t}\n\tget isDestroyed() {\n\t\treturn this._destroyed;\n\t}\n\tget isFullscreen() {\n\t\treturn this._fsEl && ( document.fullscreenElement || document.webkitFullscreenElement ) === this._fsEl;\n\t}\n\tget isLedBars() {\n\t\treturn this._flg.isLeds;\n\t}\n\tget isLumiBars() {\n\t\treturn this._flg.isLumi;\n\t}\n\tget isOctaveBands() {\n\t\treturn this._flg.isOctaves;\n\t}\n\tget isOn() {\n\t\treturn !! this._runId;\n\t}\n\tget isOutlineBars() {\n\t\treturn this._flg.isOutline;\n\t}\n\tget pixelRatio() {\n\t\treturn this._pixelRatio;\n\t}\n\tget isRoundBars() {\n\t\treturn this._flg.isRound;\n\t}\n\tstatic get version() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * ==========================================================================\n     *\n\t * PUBLIC METHODS\n\t *\n\t * ==========================================================================\n\t */\n\n\t/**\n\t * Connects an HTML media element or audio node to the analyzer\n\t *\n\t * @param {object} an instance of HTMLMediaElement or AudioNode\n\t * @returns {object} a MediaElementAudioSourceNode object if created from HTML element, or the same input object otherwise\n\t */\n\tconnectInput( source ) {\n\t\tconst isHTML = source instanceof HTMLMediaElement;\n\n\t\tif ( ! ( isHTML || source.connect ) )\n\t\t\tthrow new AudioMotionError( ERR_INVALID_AUDIO_SOURCE );\n\n\t\t// if source is an HTML element, create an audio node for it; otherwise, use the provided audio node\n\t\tconst node = isHTML ? this.audioCtx.createMediaElementSource( source ) : source;\n\n\t\tif ( ! this._sources.includes( node ) ) {\n\t\t\tnode.connect( this._input );\n\t\t\tthis._sources.push( node );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Connects the analyzer output to another audio node\n\t *\n\t * @param [{object}] an AudioNode; if undefined, the output is connected to the audio context destination (speakers)\n\t */\n\tconnectOutput( node = this.audioCtx.destination ) {\n\t\tif ( this._outNodes.includes( node ) )\n\t\t\treturn;\n\n\t\tthis._output.connect( node );\n\t\tthis._outNodes.push( node );\n\n\t\t// when connecting the first node, also connect the analyzer nodes to the merger / output nodes\n\t\tif ( this._outNodes.length == 1 ) {\n\t\t\tfor ( const i of [0,1] )\n\t\t\t\tthis._analyzer[ i ].connect( ( this._chLayout == CHANNEL_SINGLE && ! i ? this._output : this._merger ), 0, i );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys instance\n\t */\n\tdestroy() {\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst { audioCtx, canvas, _controller, _input, _merger, _observer, _ownCanvas, _ownContext, _splitter } = this;\n\n\t\tthis._destroyed = true;\n\t\tthis._ready = false;\n\t\tthis.stop();\n\n\t\t// remove event listeners\n\t\t_controller.abort();\n\t\tif ( _observer )\n\t\t\t_observer.disconnect();\n\n\t\t// clear callbacks and fullscreen element\n\t\tthis.onCanvasResize = null;\n\t\tthis.onCanvasDraw = null;\n\t\tthis._fsEl = null;\n\n\t\t// disconnect audio nodes\n\t\tthis.disconnectInput();\n\t\tthis.disconnectOutput(); // also disconnects analyzer nodes\n\t\t_input.disconnect();\n\t\t_splitter.disconnect();\n\t\t_merger.disconnect();\n\n\t\t// if audio context is our own (not provided by the user), close it\n\t\tif ( _ownContext )\n\t\t\taudioCtx.close();\n\n\t\t// remove canvas from the DOM (if not provided by the user)\n\t\tif ( _ownCanvas )\n\t\t\tcanvas.remove();\n\n\t\t// reset flags\n\t\tthis._calcBars();\n\t}\n\n\t/**\n\t * Disconnects audio sources from the analyzer\n\t *\n\t * @param [{object|array}] a connected AudioNode object or an array of such objects; if falsy, all connected nodes are disconnected\n\t * @param [{boolean}] if true, stops/releases audio tracks from disconnected media streams (e.g. microphone)\n\t */\n\tdisconnectInput( sources, stopTracks ) {\n\t\tif ( ! sources )\n\t\t\tsources = Array.from( this._sources );\n\t\telse if ( ! Array.isArray( sources ) )\n\t\t\tsources = [ sources ];\n\n\t\tfor ( const node of sources ) {\n\t\t\tconst idx = this._sources.indexOf( node );\n\t\t\tif ( stopTracks && node.mediaStream ) {\n\t\t\t\tfor ( const track of node.mediaStream.getAudioTracks() ) {\n\t\t\t\t\ttrack.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( idx >= 0 ) {\n\t\t\t\tnode.disconnect( this._input );\n\t\t\t\tthis._sources.splice( idx, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Disconnects the analyzer output from other audio nodes\n\t *\n\t * @param [{object}] a connected AudioNode object; if undefined, all connected nodes are disconnected\n\t */\n\tdisconnectOutput( node ) {\n\t\tif ( node && ! this._outNodes.includes( node ) )\n\t\t\treturn;\n\n\t\tthis._output.disconnect( node );\n\t\tthis._outNodes = node ? this._outNodes.filter( e => e !== node ) : [];\n\n\t\t// if disconnected from all nodes, also disconnect the analyzer nodes so they keep working on Chromium\n\t\t// see https://github.com/hvianna/audioMotion-analyzer/issues/13#issuecomment-808764848\n\t\tif ( this._outNodes.length == 0 ) {\n\t\t\tfor ( const i of [0,1] )\n\t\t\t\tthis._analyzer[ i ].disconnect();\n\t\t}\n\t}\n\n\t/**\n\t * Returns analyzer bars data\n     *\n\t * @returns {array}\n\t */\n\tgetBars() {\n\t\treturn Array.from( this._bars, ( { posX, freq, freqLo, freqHi, hold, peak, value } ) => ( { posX, freq, freqLo, freqHi, hold, peak, value } ) );\n\t}\n\n\t/**\n\t * Returns the energy of a frequency, or average energy of a range of frequencies\n\t *\n\t * @param [{number|string}] single or initial frequency (Hz), or preset name; if undefined, returns the overall energy\n\t * @param [{number}] ending frequency (Hz)\n\t * @returns {number|null} energy value (0 to 1) or null, if the specified preset is unknown\n\t */\n\tgetEnergy( startFreq, endFreq ) {\n\t\tif ( startFreq === undefined )\n\t\t\treturn this._energy.val;\n\n\t\t// if startFreq is a string, check for presets\n\t\tif ( startFreq != +startFreq ) {\n\t\t\tif ( startFreq == 'peak' )\n\t\t\t\treturn this._energy.peak;\n\n\t\t\tconst presets = {\n\t\t\t\tbass:    [ 20, 250 ],\n\t\t\t\tlowMid:  [ 250, 500 ],\n\t\t\t\tmid:     [ 500, 2e3 ],\n\t\t\t\thighMid: [ 2e3, 4e3 ],\n\t\t\t\ttreble:  [ 4e3, 16e3 ]\n\t\t\t}\n\n\t\t\tif ( ! presets[ startFreq ] )\n\t\t\t\treturn null;\n\n\t\t\t[ startFreq, endFreq ] = presets[ startFreq ];\n\t\t}\n\n\t\tconst startBin = this._freqToBin( startFreq ),\n\t\t      endBin   = endFreq ? this._freqToBin( endFreq ) : startBin,\n\t\t      chnCount = this._chLayout == CHANNEL_SINGLE ? 1 : 2;\n\n\t\tlet energy = 0;\n\t\tfor ( let channel = 0; channel < chnCount; channel++ ) {\n\t\t\tfor ( let i = startBin; i <= endBin; i++ )\n\t\t\t\tenergy += this._normalizedB( this._fftData[ channel ][ i ] );\n\t\t}\n\n\t\treturn energy / ( endBin - startBin + 1 ) / chnCount;\n\t}\n\n\t/**\n\t * Returns current analyzer settings in object format\n\t *\n\t * @param [{string|array}] a property name or an array of property names to not include in the returned object\n\t * @returns {object} Options object\n\t */\n\tgetOptions( ignore ) {\n\t\tif ( ! Array.isArray( ignore ) )\n\t\t\tignore = [ ignore ];\n\t\tlet options = {};\n\t\tfor ( const prop of Object.keys( DEFAULT_SETTINGS ) ) {\n\t\t\tif ( ! ignore.includes( prop ) ) {\n\t\t\t\tif ( prop == 'gradient' && this.gradientLeft != this.gradientRight ) {\n\t\t\t\t\toptions.gradientLeft = this.gradientLeft;\n\t\t\t\t\toptions.gradientRight = this.gradientRight;\n\t\t\t\t}\n\t\t\t\telse if ( prop != 'start' )\n\t\t\t\t\toptions[ prop ] = this[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\t/**\n\t * Registers a custom gradient\n\t *\n\t * @param {string} name\n\t * @param {object} options\n\t */\n\tregisterGradient( name, options ) {\n\t\tif ( typeof name != 'string' || name.trim().length == 0 )\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_INVALID_NAME );\n\n\t\tif ( typeof options != 'object' )\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_NOT_AN_OBJECT );\n\n\t\tconst { colorStops } = options;\n\n\t\tif ( ! Array.isArray( colorStops ) || ! colorStops.length )\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_MISSING_COLOR );\n\n\t\tconst count     = colorStops.length,\n\t\t\t  isInvalid = val => +val != val || val < 0 || val > 1;\n\n\t\t// normalize all colorStops as objects with `pos`, `color` and `level` properties\n\t\tcolorStops.forEach( ( colorStop, index ) => {\n\t\t\tconst pos = index / Math.max( 1, count - 1 );\n\t\t\tif ( typeof colorStop != 'object' ) // only color string was defined\n\t\t\t\tcolorStops[ index ] = {\tpos, color: colorStop };\n\t\t\telse if ( isInvalid( colorStop.pos ) )\n\t\t\t\tcolorStop.pos = pos;\n\n\t\t\tif ( isInvalid( colorStop.level ) )\n\t\t\t\tcolorStops[ index ].level = 1 - index / count;\n\t\t});\n\n\t\t// make sure colorStops is in descending `level` order and that the first one has `level == 1`\n\t\t// this is crucial for proper operation of 'bar-level' colorMode!\n\t\tcolorStops.sort( ( a, b ) => a.level < b.level ? 1 : a.level > b.level ? -1 : 0 );\n\t\tcolorStops[0].level = 1;\n\n\t\tthis._gradients[ name ] = {\n\t\t\tbgColor:    options.bgColor || GRADIENT_DEFAULT_BGCOLOR,\n\t\t\tdir:        options.dir,\n\t\t\tcolorStops: colorStops\n\t\t};\n\n\t\t// if the registered gradient is one of the currently selected gradients, regenerate them\n\t\tif ( this._selectedGrads.includes( name ) )\n\t\t\tthis._makeGrad();\n\t}\n\n\t/**\n\t * Set dimensions of analyzer's canvas\n\t *\n\t * @param {number} w width in pixels\n\t * @param {number} h height in pixels\n\t */\n\tsetCanvasSize( w, h ) {\n\t\tthis._width = w;\n\t\tthis._height = h;\n\t\tthis._setCanvas( REASON_USER );\n\t}\n\n\t/**\n\t * Set desired frequency range\n\t *\n\t * @param {number} min lowest frequency represented in the x-axis\n\t * @param {number} max highest frequency represented in the x-axis\n\t */\n\tsetFreqRange( min, max ) {\n\t\tif ( min < 1 || max < 1 )\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\n\t\telse {\n\t\t\tthis._minFreq = Math.min( min, max );\n\t\t\tthis.maxFreq  = Math.max( min, max ); // use the setter for maxFreq\n\t\t}\n\t}\n\n\t/**\n\t * Set custom parameters for LED effect\n\t * If called with no arguments or if any property is invalid, clears any previous custom parameters\n\t *\n\t * @param {object} [params]\n\t */\n\tsetLedParams( params ) {\n\t\tlet maxLeds, spaceV, spaceH;\n\n\t\t// coerce parameters to Number; `NaN` results are rejected in the condition below\n\t\tif ( params ) {\n\t\t\tmaxLeds = params.maxLeds | 0, // ensure integer\n\t\t\tspaceV  = +params.spaceV,\n\t\t\tspaceH  = +params.spaceH;\n\t\t}\n\n\t\tthis._ledParams = maxLeds > 0 && spaceV > 0 && spaceH >= 0 ? [ maxLeds, spaceV, spaceH ] : undefined;\n\t\tthis._calcBars();\n\t}\n\n\t/**\n\t * Shorthand function for setting several options at once\n\t *\n\t * @param {object} options\n\t */\n\tsetOptions( options ) {\n\t\tthis._setProps( options );\n\t}\n\n\t/**\n\t * Adjust the analyzer's sensitivity\n\t *\n\t * @param {number} min minimum decibels value\n\t * @param {number} max maximum decibels value\n\t */\n\tsetSensitivity( min, max ) {\n\t\tfor ( const i of [0,1] ) {\n\t\t\tthis._analyzer[ i ].minDecibels = Math.min( min, max );\n\t\t\tthis._analyzer[ i ].maxDecibels = Math.max( min, max );\n\t\t}\n\t}\n\n\t/**\n\t * Start the analyzer\n\t */\n\tstart() {\n\t\tthis.toggleAnalyzer( true );\n\t}\n\n\t/**\n\t * Stop the analyzer\n\t */\n\tstop() {\n\t\tthis.toggleAnalyzer( false );\n\t}\n\n\t/**\n\t * Start / stop canvas animation\n\t *\n\t * @param {boolean} [force] if undefined, inverts the current state\n\t * @returns {boolean} resulting state after the change\n\t */\n\ttoggleAnalyzer( force ) {\n\t\tconst hasStarted = this.isOn;\n\n\t\tif ( force === undefined )\n\t\t\tforce = ! hasStarted;\n\n\t\t// Stop the analyzer if it was already running and must be disabled\n\t\tif ( hasStarted && ! force ) {\n\t\t\tcancelAnimationFrame( this._runId );\n\t\t\tthis._runId = 0;\n\t\t}\n\t\t// Start the analyzer if it was stopped and must be enabled\n\t\telse if ( ! hasStarted && force && ! this._destroyed ) {\n\t\t\tthis._frames = 0;\n\t\t\tthis._time = performance.now();\n\t\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) ); // arrow function preserves the scope of *this*\n\t\t}\n\n\t\treturn this.isOn;\n\t}\n\n\t/**\n\t * Toggles canvas full-screen mode\n\t */\n\ttoggleFullscreen() {\n\t\tif ( this.isFullscreen ) {\n\t\t\tif ( document.exitFullscreen )\n\t\t\t\tdocument.exitFullscreen();\n\t\t\telse if ( document.webkitExitFullscreen )\n\t\t\t\tdocument.webkitExitFullscreen();\n\t\t}\n\t\telse {\n\t\t\tconst fsEl = this._fsEl;\n\t\t\tif ( ! fsEl )\n\t\t\t\treturn;\n\t\t\tif ( fsEl.requestFullscreen )\n\t\t\t\tfsEl.requestFullscreen();\n\t\t\telse if ( fsEl.webkitRequestFullscreen )\n\t\t\t\tfsEl.webkitRequestFullscreen();\n\t\t}\n\t}\n\n\t/**\n\t * ==========================================================================\n\t *\n\t * PRIVATE METHODS\n\t *\n\t * ==========================================================================\n\t */\n\n\t/**\n\t * Return the frequency (in Hz) for a given FFT bin\n\t */\n\t_binToFreq( bin ) {\n\t\treturn bin * this.audioCtx.sampleRate / this.fftSize || 1; // returns 1 for bin 0\n\t}\n\n\t/**\n\t * Compute all internal data required for the analyzer, based on its current settings\n\t */\n\t_calcBars() {\n\t\tconst bars = this._bars = []; // initialize object property\n\n\t\tif ( ! this._ready ) {\n\t\t\tthis._flg = { isAlpha: false, isBands: false, isLeds: false, isLumi: false, isOctaves: false, isOutline: false, isRound: false, noLedGap: false };\n\t\t\treturn;\n\t\t}\n\n\t\tconst { _ansiBands, _barSpace, canvas, _chLayout, _maxFreq, _minFreq, _mirror, _mode, _radial, _radialInvert, _reflexRatio } = this,\n\t\t\t  centerX          = canvas.width >> 1,\n\t\t\t  centerY          = canvas.height >> 1,\n\t\t\t  isDualVertical   = _chLayout == CHANNEL_VERTICAL && ! _radial,\n\t\t\t  isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL,\n\n\t\t\t  // COMPUTE FLAGS\n\n\t\t\t  isBands   = _mode % 10 != 0, // true for modes 1 to 9\n\t\t\t  isOctaves = isBands && this._frequencyScale == SCALE_LOG,\n\t\t\t  isLeds    = this._showLeds && isBands && ! _radial,\n\t\t\t  isLumi    = this._lumiBars && isBands && ! _radial,\n\t\t\t  isAlpha   = this._alphaBars && ! isLumi && _mode != MODE_GRAPH,\n\t\t\t  isOutline = this._outlineBars && isBands && ! isLumi && ! isLeds,\n\t\t\t  isRound   = this._roundBars && isBands && ! isLumi && ! isLeds,\n\t\t\t  noLedGap  = _chLayout != CHANNEL_VERTICAL || _reflexRatio > 0 && ! isLumi,\n\n\t\t\t  // COMPUTE AUXILIARY VALUES\n\n\t\t\t  // channelHeight is the total canvas height dedicated to each channel, including the reflex area, if any)\n\t\t\t  channelHeight  = canvas.height - ( isDualVertical && ! isLeds ? .5 : 0 ) >> isDualVertical,\n\t\t\t  // analyzerHeight is the effective height used to render the analyzer, excluding the reflex area\n\t\t\t  analyzerHeight = channelHeight * ( isLumi || _radial ? 1 : 1 - _reflexRatio ) | 0,\n\n\t\t\t  analyzerWidth  = canvas.width - centerX * ( isDualHorizontal || _mirror != 0 ),\n\n\t\t\t  // channelGap is **0** if isLedDisplay == true (LEDs already have spacing); **1** if canvas height is odd (windowed); **2** if it's even\n\t\t\t  // TODO: improve this, make it configurable?\n\t\t\t  channelGap     = isDualVertical ? canvas.height - channelHeight * 2 : 0,\n\n\t\t\t  initialX       = centerX * ( _mirror == -1 && ! isDualHorizontal && ! _radial );\n\n\t\tlet innerRadius = Math.min( canvas.width, canvas.height ) * .375 * ( _chLayout == CHANNEL_VERTICAL ? 1 : this._radius ) | 0,\n\t\t\touterRadius = Math.min( centerX, centerY );\n\n\t\tif ( _radialInvert && _chLayout != CHANNEL_VERTICAL )\n\t\t\t[ innerRadius, outerRadius ] = [ outerRadius, innerRadius ];\n\n\t\t/**\n\t\t *\tCREATE ANALYZER BANDS\n\t\t *\n\t\t *\tUSES:\n\t\t *\t\tanalyzerWidth\n\t\t *\t\tinitialX\n\t\t *\t\tisBands\n\t\t *\t\tisOctaves\n\t\t *\n\t\t *\tGENERATES:\n\t\t *\t\tbars (populates this._bars)\n\t\t *\t\tbardWidth\n\t\t *\t\tscaleMin\n\t\t *\t\tunitWidth\n\t\t */\n\n\t\t// helper function to add a bar to the bars array\n\t\t// bar object format:\n\t\t// {\n\t\t//\t posX,\n\t\t//   freq,\n\t\t//   freqLo,\n\t\t//   freqHi,\n\t\t//   binLo,\n\t\t//   binHi,\n\t\t//   ratioLo,\n\t\t//   ratioHi,\n\t\t//   peak,    // peak value\n\t\t//   hold,    // peak hold frames (negative value indicates peak falling / fading)\n\t\t//   alpha,   // peak alpha (used by fadePeaks)\n\t\t//   value    // current bar value\n\t\t// }\n\t\tconst barsPush = args => bars.push( { ...args, peak: [0,0], hold: [0], alpha: [0], value: [0] } );\n\n\t\t/*\n\t\t\tA simple interpolation is used to obtain an approximate amplitude value for any given frequency,\n\t\t\tfrom the available FFT data. We find the FFT bin which closer matches the desired frequency\tand\n\t\t\tinterpolate its value with that of the next adjacent bin, like so:\n\n\t\t\t\tv = v0 + ( v1 - v0 ) * ( log2( f / f0 ) / log2( f1 / f0 ) )\n\t\t\t\t                       \\__________________________________/\n\t\t\t\t                                        |\n\t\t\t\t                                      ratio\n\t\t\t\twhere:\n\n\t\t\t\tf  - desired frequency\n\t\t\t\tv  - amplitude (volume) of desired frequency\n\t\t\t\tf0 - frequency represented by the lower FFT bin\n\t\t\t\tf1 - frequency represented by the upper FFT bin\n\t\t\t\tv0 - amplitude of f0\n\t\t\t\tv1 - amplitude of f1\n\n\t\t\tratio is calculated in advance here, to reduce computational complexity during real-time rendering.\n\t\t*/\n\n\t\t// helper function to calculate FFT bin and interpolation ratio for a given frequency\n\t\tconst calcRatio = freq => {\n\t\t\tconst bin   = this._freqToBin( freq, 'floor' ), // find closest FFT bin\n\t\t\t\t  lower = this._binToFreq( bin ),\n\t\t\t\t  upper = this._binToFreq( bin + 1 ),\n\t\t\t\t  ratio = Math.log2( freq / lower ) / Math.log2( upper / lower );\n\n\t\t\treturn [ bin, ratio ];\n\t\t}\n\n\t\tlet barWidth, scaleMin, unitWidth;\n\n\t\tif ( isOctaves ) {\n\t\t\t// helper function to round a value to a given number of significant digits\n\t\t\t// `atLeast` set to true prevents reducing the number of integer significant digits\n\t\t\tconst roundSD = ( value, digits, atLeast ) => +value.toPrecision( atLeast ? Math.max( digits, 1 + Math.log10( value ) | 0 ) : digits );\n\n\t\t\t// helper function to find the nearest preferred number (Renard series) for a given value\n\t\t\tconst nearestPreferred = value => {\n\t\t\t\t// R20 series is used here, as it provides closer approximations for 1/2 octave bands (non-standard)\n\t\t\t\tconst preferred = [ 1, 1.12, 1.25, 1.4, 1.6, 1.8, 2, 2.24, 2.5, 2.8, 3.15, 3.55, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10 ],\n\t\t\t\t\t  power = Math.log10( value ) | 0,\n\t\t\t\t\t  normalized = value / 10 ** power;\n\n\t\t\t\tlet i = 1;\n\t\t\t\twhile ( i < preferred.length && normalized > preferred[ i ] )\n\t\t\t\t\ti++;\n\n\t\t\t\tif ( normalized - preferred[ i - 1 ] < preferred[ i ] - normalized )\n\t\t\t\t\ti--;\n\n\t\t\t\treturn ( preferred[ i ] * 10 ** ( power + 5 ) | 0 ) / 1e5; // keep 5 significant digits\n\t\t\t}\n\n\t\t\t// ANSI standard octave bands use the base-10 frequency ratio, as preferred by [ANSI S1.11-2004, p.2]\n\t\t\t// The equal-tempered scale uses the base-2 ratio\n\t\t\tconst bands = [0,24,12,8,6,4,3,2,1][ _mode ],\n\t\t\t\t  bandWidth = _ansiBands ? 10 ** ( 3 / ( bands * 10 ) ) : 2 ** ( 1 / bands ), // 10^(3/10N) or 2^(1/N)\n\t\t\t\t  halfBand  = bandWidth ** .5;\n\n\t\t\tlet analyzerBars = [],\n\t\t\t\tcurrFreq = _ansiBands ? 7.94328235 / ( bands % 2 ? 1 : halfBand ) : C_1;\n\t\t\t\t// For ANSI bands with even denominators (all except 1/1 and 1/3), the reference frequency (1 kHz)\n\t\t\t\t// must fall on the edges of a pair of adjacent bands, instead of midband [ANSI S1.11-2004, p.2]\n\t\t\t\t// In the equal-tempered scale, all midband frequencies represent a musical note or quarter-tone.\n\n\t\t\tdo {\n\t\t\t\tlet freq = currFreq; // midband frequency\n\n\t\t\t\tconst freqLo = roundSD( freq / halfBand, 4, true ), // lower edge frequency\n\t\t\t\t\t  freqHi = roundSD( freq * halfBand, 4, true ), // upper edge frequency\n\t\t\t\t\t  [ binLo, ratioLo ] = calcRatio( freqLo ),\n\t\t\t\t\t  [ binHi, ratioHi ] = calcRatio( freqHi );\n\n\t\t\t\t// for 1/1, 1/2 and 1/3 ANSI bands, use the preferred numbers to find the nominal midband frequency\n\t\t\t\t// for 1/4 to 1/24, round to 2 or 3 significant digits, according to the MSD [ANSI S1.11-2004, p.12]\n\t\t\t\tif ( _ansiBands )\n\t\t\t\t\tfreq = bands < 4 ? nearestPreferred( freq ) : roundSD( freq, freq.toString()[0] < 5 ? 3 : 2 );\n\t\t\t\telse\n\t\t\t\t\tfreq = roundSD( freq, 4, true );\n\n\t\t\t\tif ( freq >= _minFreq )\n\t\t\t\t\tbarsPush( { posX: 0, freq, freqLo, freqHi, binLo, binHi, ratioLo, ratioHi } );\n\n\t\t\t\tcurrFreq *= bandWidth;\n\t\t\t} while ( currFreq <= _maxFreq );\n\n\t\t\tbarWidth = analyzerWidth / bars.length;\n\n\t\t\tbars.forEach( ( bar, index ) => bar.posX = initialX + index * barWidth );\n\n\t\t\tconst firstBar = bars[0],\n\t\t\t\t  lastBar  = bars[ bars.length - 1 ];\n\n\t\t\tscaleMin = this._freqScaling( firstBar.freqLo );\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( lastBar.freqHi ) - scaleMin );\n\n\t\t\t// clamp edge frequencies to minFreq / maxFreq, if necessary\n\t\t\t// this is done after computing scaleMin and unitWidth, for the proper positioning of labels on the X-axis\n\t\t\tif ( firstBar.freqLo < _minFreq ) {\n\t\t\t\tfirstBar.freqLo = _minFreq;\n\t\t\t\t[ firstBar.binLo, firstBar.ratioLo ] = calcRatio( _minFreq );\n\t\t\t}\n\n\t\t\tif ( lastBar.freqHi > _maxFreq ) {\n\t\t\t\tlastBar.freqHi = _maxFreq;\n\t\t\t\t[ lastBar.binHi, lastBar.ratioHi ] = calcRatio( _maxFreq );\n\t\t\t}\n\t\t}\n\t\telse if ( isBands ) { // a bands mode is selected, but frequency scale is not logarithmic\n\n\t\t\tconst bands = [0,24,12,8,6,4,3,2,1][ _mode ] * 10;\n\n\t\t\tconst invFreqScaling = x => {\n\t\t\t\tswitch ( this._frequencyScale ) {\n\t\t\t\t\tcase SCALE_BARK :\n\t\t\t\t\t\treturn 1960 / ( 26.81 / ( x + .53 ) - 1 );\n\t\t\t\t\tcase SCALE_MEL :\n\t\t\t\t\t\treturn 700 * ( 2 ** x - 1 );\n\t\t\t\t\tcase SCALE_LINEAR :\n\t\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbarWidth = analyzerWidth / bands;\n\n\t\t\tscaleMin = this._freqScaling( _minFreq );\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( _maxFreq ) - scaleMin );\n\n\t\t\tfor ( let i = 0, posX = 0; i < bands; i++, posX += barWidth ) {\n\t\t\t\tconst freqLo = invFreqScaling( scaleMin + posX / unitWidth ),\n\t\t\t\t\t  freq   = invFreqScaling( scaleMin + ( posX + barWidth / 2 ) / unitWidth ),\n\t\t\t\t\t  freqHi = invFreqScaling( scaleMin + ( posX + barWidth ) / unitWidth ),\n\t\t\t\t\t  [ binLo, ratioLo ] = calcRatio( freqLo ),\n\t\t\t\t\t  [ binHi, ratioHi ] = calcRatio( freqHi );\n\n\t\t\t\tbarsPush( { posX: initialX + posX, freq, freqLo, freqHi, binLo, binHi, ratioLo, ratioHi } );\n\t\t\t}\n\n\t\t}\n\t\telse {\t// Discrete frequencies modes\n\t\t\tbarWidth = 1;\n\n\t\t\tscaleMin = this._freqScaling( _minFreq );\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( _maxFreq ) - scaleMin );\n\n\t\t\tconst minIndex = this._freqToBin( _minFreq, 'floor' ),\n\t\t\t\t  maxIndex = this._freqToBin( _maxFreq );\n\n\t \t\tlet lastPos = -999;\n\n\t\t\tfor ( let i = minIndex; i <= maxIndex; i++ ) {\n\t\t\t\tconst freq = this._binToFreq( i ), // frequency represented by this index\n\t\t\t\t\t  posX = initialX + Math.round( unitWidth * ( this._freqScaling( freq ) - scaleMin ) ); // avoid fractionary pixel values\n\n\t\t\t\t// if it's on a different X-coordinate, create a new bar for this frequency\n\t\t\t\tif ( posX > lastPos ) {\n\t\t\t\t\tbarsPush( { posX, freq, freqLo: freq, freqHi: freq, binLo: i, binHi: i, ratioLo: 0, ratioHi: 0 } );\n\t\t\t\t\tlastPos = posX;\n\t\t\t\t} // otherwise, add this frequency to the last bar's range\n\t\t\t\telse if ( bars.length ) {\n\t\t\t\t\tconst lastBar = bars[ bars.length - 1 ];\n\t\t\t\t\tlastBar.binHi = i;\n\t\t\t\t\tlastBar.freqHi = freq;\n\t\t\t\t\tlastBar.freq = ( lastBar.freqLo * freq ) ** .5; // compute center frequency (geometric mean)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *  COMPUTE ATTRIBUTES FOR THE LED BARS\n\t\t *\n\t\t *\tUSES:\n\t\t *\t\tanalyzerHeight\n\t\t *\t\tbarWidth\n\t\t *\t\tnoLedGap\n\t\t *\n\t\t *\tGENERATES:\n\t\t * \t\tspaceH\n\t\t * \t\tspaceV\n\t\t *\t\tthis._leds\n\t\t */\n\n\t\tlet spaceH = 0,\n\t\t\tspaceV = 0;\n\n\t\tif ( isLeds ) {\n\t\t\t// adjustment for high pixel-ratio values on low-resolution screens (Android TV)\n\t\t\tconst dPR = this._pixelRatio / ( window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1 );\n\n\t\t\tconst params = [ [],\n\t\t\t\t[ 128,  3, .45  ], // mode 1\n\t\t\t\t[ 128,  4, .225 ], // mode 2\n\t\t\t\t[  96,  6, .225 ], // mode 3\n\t\t\t\t[  80,  6, .225 ], // mode 4\n\t\t\t\t[  80,  6, .125 ], // mode 5\n\t\t\t\t[  64,  6, .125 ], // mode 6\n\t\t\t\t[  48,  8, .125 ], // mode 7\n\t\t\t\t[  24, 16, .125 ], // mode 8\n\t\t\t];\n\n\t\t\t// use custom LED parameters if set, or the default parameters for the current mode\n\t\t\tconst customParams = this._ledParams,\n\t\t\t\t  [ maxLeds, spaceVRatio, spaceHRatio ] = customParams || params[ _mode ];\n\n\t\t\tlet ledCount, maxHeight = analyzerHeight;\n\n\t\t\tif ( customParams ) {\n\t\t\t\tconst minHeight = 2 * dPR;\n\t\t\t\tlet blockHeight;\n\t\t\t\tledCount = maxLeds + 1;\n\t\t\t\tdo {\n\t\t\t\t\tledCount--;\n\t\t\t\t\tblockHeight = maxHeight / ledCount / ( 1 + spaceVRatio );\n\t\t\t\t\tspaceV = blockHeight * spaceVRatio;\n\t\t\t\t} while ( ( blockHeight < minHeight || spaceV < minHeight ) && ledCount > 1 );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// calculate vertical spacing - aim for the reference ratio, but make sure it's at least 2px\n\t\t\t\tconst refRatio = 540 / spaceVRatio;\n\t\t\t\tspaceV = Math.min( spaceVRatio * dPR, Math.max( 2, maxHeight / refRatio + .1 | 0 ) );\n\t\t\t}\n\n\t\t\t// remove the extra spacing below the last line of LEDs\n\t\t\tif ( noLedGap )\n\t\t\t\tmaxHeight += spaceV;\n\n\t\t\t// recalculate the number of leds, considering the effective spaceV\n\t\t\tif ( ! customParams )\n\t\t\t\tledCount = Math.min( maxLeds, maxHeight / ( spaceV * 2 ) | 0 );\n\n\t\t\tspaceH = spaceHRatio >= 1 ? spaceHRatio : barWidth * spaceHRatio;\n\n\t\t\tthis._leds = [\n\t\t\t\tledCount,\n\t\t\t\tspaceH,\n\t\t\t\tspaceV,\n\t\t\t\tmaxHeight / ledCount - spaceV // ledHeight\n\t\t\t];\n\t\t}\n\n\t\t// COMPUTE ADDITIONAL BAR POSITIONING, ACCORDING TO THE CURRENT SETTINGS\n\t\t// uses: _barSpace, barWidth, spaceH\n\n\t\tconst barSpacePx = Math.min( barWidth - 1, _barSpace * ( _barSpace > 0 && _barSpace < 1 ? barWidth : 1 ) );\n\n\t\tif ( isBands )\n\t\t\tbarWidth -= Math.max( isLeds ? spaceH : 0, barSpacePx );\n\n\t\tbars.forEach( ( bar, index ) => {\n\t\t\tlet posX  = bar.posX,\n\t\t\t\twidth = barWidth;\n\n\t\t\t// in bands modes we need to update bar.posX to account for bar/led spacing\n\n\t\t\tif ( isBands ) {\n\t\t\t\tif ( _barSpace == 0 && ! isLeds ) {\n\t\t\t\t\t// when barSpace == 0 use integer values for perfect gapless positioning\n\t\t\t\t\tposX |= 0;\n\t\t\t\t\twidth |= 0;\n\t\t\t\t\tif ( index > 0 && posX > bars[ index - 1 ].posX + bars[ index - 1 ].width ) {\n\t\t\t\t\t\tposX--;\n\t\t\t\t\t\twidth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tposX += Math.max( ( isLeds ? spaceH : 0 ), barSpacePx ) / 2;\n\n\t\t\t\tbar.posX = posX; // update\n\t\t\t}\n\n\t\t\tbar.barCenter = posX + ( barWidth == 1 ? 0 : width / 2 );\n\t\t\tbar.width = width;\n\t\t});\n\n\t\t// COMPUTE CHANNEL COORDINATES (uses spaceV)\n\n\t\tconst channelCoords = [];\n\t\tfor ( const channel of [0,1] ) {\n\t\t\tconst channelTop     = _chLayout == CHANNEL_VERTICAL ? ( channelHeight + channelGap ) * channel : 0,\n\t\t\t\t  channelBottom  = channelTop + channelHeight,\n\t\t\t\t  analyzerBottom = channelTop + analyzerHeight - ( ! isLeds || noLedGap ? 0 : spaceV );\n\n\t\t\tchannelCoords.push( { channelTop, channelBottom, analyzerBottom } );\n\t\t}\n\n\t\t// SAVE INTERNAL PROPERTIES\n\n\t\tthis._aux = { analyzerHeight, analyzerWidth, centerX, centerY, channelCoords, channelHeight, channelGap, initialX, innerRadius, outerRadius, scaleMin, unitWidth };\n\t\tthis._flg = { isAlpha, isBands, isLeds, isLumi, isOctaves, isOutline, isRound, noLedGap };\n\n\t\t// generate the X-axis and radial scales\n\t\tthis._createScales();\n\t}\n\n\t/**\n\t * Generate the X-axis and radial scales in auxiliary canvases\n\t */\n\t_createScales() {\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst { analyzerWidth, initialX, innerRadius, scaleMin, unitWidth } = this._aux,\n\t\t\t  { canvas, _frequencyScale, _mirror, _noteLabels, _radial, _scaleX, _scaleR } = this,\n\t\t\t  canvasX          = _scaleX.canvas,\n\t\t\t  canvasR          = _scaleR.canvas,\n\t\t\t  freqLabels       = [],\n\t\t\t  isDualHorizontal = this._chLayout == CHANNEL_HORIZONTAL,\n\t\t\t  isDualVertical   = this._chLayout == CHANNEL_VERTICAL,\n\t\t\t  minDimension     = Math.min( canvas.width, canvas.height ),\n\t\t\t  scale            = [ 'C',, 'D',, 'E', 'F',, 'G',, 'A',, 'B' ], // for note labels (no sharp notes)\n\t\t\t  scaleHeight      = minDimension / 34 | 0, // circular scale height (radial mode)\n  \t\t\t  fontSizeX        = canvasX.height >> 1,\n\t\t\t  fontSizeR        = scaleHeight >> 1,\n\t\t\t  labelWidthX      = fontSizeX * ( _noteLabels ? .7 : 1.5 ),\n\t\t\t  labelWidthR      = fontSizeR * ( _noteLabels ? 1 : 2 ),\n\t\t  \t  root12           = 2 ** ( 1 / 12 );\n\n\t\tif ( ! _noteLabels && ( this._ansiBands || _frequencyScale != SCALE_LOG ) ) {\n\t\t\tfreqLabels.push( 16, 31.5, 63, 125, 250, 500, 1e3, 2e3, 4e3 );\n\t\t\tif ( _frequencyScale == SCALE_LINEAR )\n\t\t\t\tfreqLabels.push( 6e3, 8e3, 10e3, 12e3, 14e3, 16e3, 18e3, 20e3, 22e3 );\n\t\t\telse\n\t\t\t\tfreqLabels.push( 8e3, 16e3 );\n\t\t}\n\t\telse {\n\t\t\tlet freq = C_1;\n\t\t\tfor ( let octave = -1; octave < 11; octave++ ) {\n\t\t\t\tfor ( let note = 0; note < 12; note++ ) {\n\t\t\t\t\tif ( freq >= this._minFreq && freq <= this._maxFreq ) {\n\t\t\t\t\t\tconst pitch = scale[ note ],\n\t\t\t\t\t\t\t  isC   = pitch == 'C';\n\t\t\t\t\t\tif ( ( pitch && _noteLabels && ! _mirror && ! isDualHorizontal ) || isC )\n\t\t\t\t\t\t\tfreqLabels.push( _noteLabels ? [ freq, pitch + ( isC ? octave : '' ) ] : freq );\n\t\t\t\t\t}\n\t\t\t\t\tfreq *= root12;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// in radial dual-vertical layout, the scale is positioned exactly between both channels, by making the canvas a bit larger than the inner diameter\n\t\tcanvasR.width = canvasR.height = Math.max( minDimension * .15, ( innerRadius << 1 ) + ( isDualVertical * scaleHeight ) );\n\n\t\tconst centerR = canvasR.width >> 1,\n\t\t\t  radialY = centerR - scaleHeight * .7;\t// vertical position of text labels in the circular scale\n\n\t\t// helper function\n\t\tconst radialLabel = ( x, label ) => {\n\t\t\tconst angle  = TAU * ( x / canvas.width ),\n\t\t\t\t  adjAng = angle - HALF_PI, // rotate angles so 0 is at the top\n\t\t\t\t  posX   = radialY * Math.cos( adjAng ),\n\t\t\t\t  posY   = radialY * Math.sin( adjAng );\n\n\t\t\t_scaleR.save();\n\t\t\t_scaleR.translate( centerR + posX, centerR + posY );\n\t\t\t_scaleR.rotate( angle );\n\t\t\t_scaleR.fillText( label, 0, 0 );\n\t\t\t_scaleR.restore();\n\t\t}\n\n\t\t// clear scale canvas\n\t\tcanvasX.width |= 0;\n\n\t\t_scaleX.fillStyle = _scaleR.strokeStyle = SCALEX_BACKGROUND_COLOR;\n\t\t_scaleX.fillRect( 0, 0, canvasX.width, canvasX.height );\n\n\t\t_scaleR.arc( centerR, centerR, centerR - scaleHeight / 2, 0, TAU );\n\t\t_scaleR.lineWidth = scaleHeight;\n\t\t_scaleR.stroke();\n\n\t\t_scaleX.fillStyle = _scaleR.fillStyle = SCALEX_LABEL_COLOR;\n\t\t_scaleX.font = `${ fontSizeX }px ${FONT_FAMILY}`;\n\t\t_scaleR.font = `${ fontSizeR }px ${FONT_FAMILY}`;\n\t\t_scaleX.textAlign = _scaleR.textAlign = 'center';\n\n\t\tlet prevX = -labelWidthX / 4,\n\t\t\tprevR = -labelWidthR;\n\n\t\tfor ( const item of freqLabels ) {\n\t\t\tconst [ freq, label ] = Array.isArray( item ) ? item : [ item, item < 1e3 ? item | 0 : `${ ( item / 100 | 0 ) / 10 }k` ],\n\t\t\t\t  x    = unitWidth * ( this._freqScaling( freq ) - scaleMin ),\n\t\t\t\t  y    = canvasX.height * .75,\n\t\t\t\t  isC  = label[0] == 'C',\n\t  \t\t\t  maxW = fontSizeX * ( _noteLabels && ! _mirror && ! isDualHorizontal ? ( isC ? 1.2 : .6 ) : 3 );\n\n\t  \t\t// set label color - no highlight when mirror effect is active (only Cs displayed)\n\t\t\t_scaleX.fillStyle = _scaleR.fillStyle = isC && ! _mirror && ! isDualHorizontal ? SCALEX_HIGHLIGHT_COLOR : SCALEX_LABEL_COLOR;\n\n\t\t\t// prioritizes which note labels are displayed, due to the restricted space on some ranges/scales\n\t\t\tif ( _noteLabels ) {\n\t\t\t\tconst isLog = _frequencyScale == SCALE_LOG,\n\t\t\t\t\t  isLinear = _frequencyScale == SCALE_LINEAR;\n\n\t\t\t\tlet allowedLabels = ['C'];\n\n\t\t\t\tif ( isLog || freq > 2e3 || ( ! isLinear && freq > 250 ) ||\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( ! isLinear && freq > 125 || freq > 1e3 ) ) )\n\t\t\t\t\tallowedLabels.push('G');\n\t\t\t\tif ( isLog || freq > 4e3 || ( ! isLinear && freq > 500 ) ||\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( ! isLinear && freq > 250 || freq > 2e3 ) ) )\n\t\t\t\t\tallowedLabels.push('E');\n\t\t\t\tif ( isLinear && freq > 4e3 ||\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( isLog || freq > 2e3 || ( ! isLinear && freq > 500 ) ) ) )\n\t\t\t\t\tallowedLabels.push('D','F','A','B');\n\t\t\t\tif ( ! allowedLabels.includes( label[0] ) )\n\t\t\t\t\tcontinue; // skip this label\n\t\t\t}\n\n\t\t\t// linear scale\n\t\t\tif ( x >= prevX + labelWidthX / 2 && x <= analyzerWidth ) {\n\t\t\t\t_scaleX.fillText( label, isDualHorizontal && _mirror == -1 ? analyzerWidth - x : initialX + x, y, maxW );\n\t\t\t\tif ( isDualHorizontal || ( _mirror && ( x > labelWidthX || _mirror == 1 ) ) )\n\t\t\t\t\t_scaleX.fillText( label, isDualHorizontal && _mirror != 1 ? analyzerWidth + x : ( initialX || canvas.width ) - x, y, maxW );\n\t\t\t\tprevX = x + Math.min( maxW, _scaleX.measureText( label ).width ) / 2;\n\t\t\t}\n\n\t\t\t// radial scale\n\t\t\tif ( x >= prevR + labelWidthR && x < analyzerWidth - labelWidthR ) { // avoid overlapping the last label over the first one\n\t\t\t\tradialLabel( isDualHorizontal && _mirror == 1 ? analyzerWidth - x : x, label );\n\t\t\t\tif ( isDualHorizontal || ( _mirror && ( x > labelWidthR || _mirror == 1 ) ) ) // avoid overlapping of first labels on mirror mode\n\t\t\t\t\tradialLabel( isDualHorizontal && _mirror != -1 ? analyzerWidth + x : -x, label );\n\t\t\t\tprevR = x;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Redraw the canvas\n\t * this is called 60 times per second by requestAnimationFrame()\n\t */\n\t_draw( timestamp ) {\n\t\t// schedule next canvas update\n\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) );\n\n\t\t// frame rate control\n\t\tconst elapsed        = timestamp - this._time, // time since last FPS computation\n\t\t\t  frameTime      = timestamp - this._last, // time since last rendered frame\n\t\t\t  targetInterval = this._maxFPS ? 975 / this._maxFPS : 0; // small tolerance for best results\n\n\t\tif ( frameTime < targetInterval )\n\t\t\treturn;\n\n\t\tthis._last = timestamp - ( targetInterval ? frameTime % targetInterval : 0 ); // thanks https://stackoverflow.com/a/19772220/2370385\n\t\tthis._frames++;\n\n\t\tif ( elapsed >= 1000 ) { // update FPS every second\n\t\t\tthis._fps = this._frames / elapsed * 1000;\n\t\t\tthis._frames = 0;\n\t\t\tthis._time = timestamp;\n\t\t}\n\n\t\t// initialize local constants\n\n\t\tconst { isAlpha,\n\t\t\t    isBands,\n\t\t\t    isLeds,\n\t\t\t    isLumi,\n\t\t\t    isOctaves,\n\t\t\t    isOutline,\n\t\t\t    isRound,\n\t\t\t    noLedGap }     = this._flg,\n\n\t\t\t  { analyzerHeight,\n\t\t\t    centerX,\n\t\t\t    centerY,\n\t\t\t    channelCoords,\n\t\t\t    channelHeight,\n\t\t\t    channelGap,\n\t\t\t    initialX,\n\t\t\t    innerRadius,\n\t\t\t    outerRadius }  = this._aux,\n\n\t\t\t  { _bars,\n\t\t\t    canvas,\n\t\t\t    _canvasGradients,\n\t\t\t    _chLayout,\n\t\t\t    _colorMode,\n\t\t\t    _ctx,\n\t\t\t    _energy,\n\t\t\t    _fadePeaks,\n\t\t\t    fillAlpha,\n\t\t\t    _fps,\n\t\t\t    _linearAmplitude,\n\t\t\t    _lineWidth,\n\t\t\t    maxDecibels,\n\t\t\t    minDecibels,\n\t\t\t    _mirror,\n\t\t\t    _mode,\n\t\t\t    overlay,\n\t\t\t    _radial,\n\t\t\t    showBgColor,\n\t\t\t    showPeaks,\n\t\t\t    useCanvas,\n\t\t\t    _weightingFilter } = this,\n\n\t\t\t  canvasX          = this._scaleX.canvas,\n\t\t\t  canvasR          = this._scaleR.canvas,\n\t\t\t  fadeFrames       = _fps * this._peakFadeTime / 1e3,\n\t\t\t  fpsSquared       = _fps ** 2,\n\t\t\t  gravity          = this._gravity * 1e3,\n\t\t\t  holdFrames       = _fps * this._peakHoldTime / 1e3,\n\t\t\t  isDualCombined   = _chLayout == CHANNEL_COMBINED,\n\t\t\t  isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL,\n\t\t\t  isDualVertical   = _chLayout == CHANNEL_VERTICAL,\n\t\t\t  isSingle         = _chLayout == CHANNEL_SINGLE,\n\t\t\t  isTrueLeds       = isLeds && this._trueLeds && _colorMode == COLOR_GRADIENT,\n\t\t\t  analyzerWidth    = _radial ? canvas.width : this._aux.analyzerWidth,\n\t\t\t  finalX           = initialX + analyzerWidth,\n\t\t\t  showPeakLine     = showPeaks && this._peakLine && _mode == MODE_GRAPH,\n\t\t\t  maxBarHeight     = _radial ? outerRadius - innerRadius : analyzerHeight,\n\t\t\t  nominalMaxHeight = maxBarHeight / this._pixelRatio, // for consistent gravity on lo-res or hi-dpi\n\t\t\t  dbRange \t\t   = maxDecibels - minDecibels,\n\t\t\t  [ ledCount, ledSpaceH, ledSpaceV, ledHeight ] = this._leds || [];\n\n\t\tif ( _energy.val > 0 && _fps > 0 )\n\t\t\tthis._spinAngle += this._spinSpeed * TAU / 60 / _fps; // spinSpeed * angle increment per frame for 1 RPM\n\n\t\t/* HELPER FUNCTIONS */\n\n\t\t// create Reflex effect\n\t\tconst doReflex = channel => {\n\t\t\tif ( this._reflexRatio > 0 && ! isLumi && ! _radial ) {\n\t\t\t\tlet posY, height;\n\t\t\t\tif ( this.reflexFit || isDualVertical ) { // always fit reflex in vertical stereo mode\n\t\t\t\t\tposY   = isDualVertical && channel == 0 ? channelHeight + channelGap : 0;\n\t\t\t\t\theight = channelHeight - analyzerHeight;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposY   = canvas.height - analyzerHeight * 2;\n\t\t\t\t\theight = analyzerHeight;\n\t\t\t\t}\n\n\t\t\t\t_ctx.save();\n\n\t\t\t\t// set alpha and brightness for the reflection\n\t\t\t\t_ctx.globalAlpha = this.reflexAlpha;\n\t\t\t\tif ( this.reflexBright != 1 )\n\t\t\t\t\t_ctx.filter = `brightness(${this.reflexBright})`;\n\n\t\t\t\t// create the reflection\n\t\t\t\t_ctx.setTransform( 1, 0, 0, -1, 0, canvas.height );\n\t\t\t\t_ctx.drawImage( canvas, 0, channelCoords[ channel ].channelTop, canvas.width, analyzerHeight, 0, posY, canvas.width, height );\n\n\t\t\t\t_ctx.restore();\n\t\t\t}\n\t\t}\n\n\t\t// draw scale on X-axis\n\t\tconst drawScaleX = () => {\n\t\t\tif ( this.showScaleX ) {\n\t\t\t\tif ( _radial ) {\n\t\t\t\t\t_ctx.save();\n\t\t\t\t\t_ctx.translate( centerX, centerY );\n\t\t\t\t\tif ( this._spinSpeed )\n\t\t\t\t\t\t_ctx.rotate( this._spinAngle + HALF_PI );\n\t\t\t\t\t_ctx.drawImage( canvasR, -canvasR.width >> 1, -canvasR.width >> 1 );\n\t\t\t\t\t_ctx.restore();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_ctx.drawImage( canvasX, 0, canvas.height - canvasX.height );\n\t\t\t}\n\t\t}\n\n\t\t// returns the gain (in dB) for a given frequency, considering the currently selected weighting filter\n\t\tconst weightingdB = freq => {\n\t\t\tconst f2 = freq ** 2,\n\t\t\t\t  SQ20_6  = 424.36,\n\t\t\t\t  SQ107_7 = 11599.29,\n\t\t\t\t  SQ158_5 = 25122.25,\n\t\t\t\t  SQ737_9 = 544496.41,\n\t\t\t\t  SQ12194 = 148693636,\n\t\t\t\t  linearTodB = value => 20 * Math.log10( value );\n\n\t\t\tswitch ( _weightingFilter ) {\n\t\t\t\tcase FILTER_A : // A-weighting https://en.wikipedia.org/wiki/A-weighting\n\t\t\t\t\tconst rA = ( SQ12194 * f2 ** 2 ) / ( ( f2 + SQ20_6 ) * Math.sqrt( ( f2 + SQ107_7 ) * ( f2 + SQ737_9 ) ) * ( f2 + SQ12194 ) );\n\t\t\t\t\treturn 2 + linearTodB( rA );\n\n\t\t\t\tcase FILTER_B :\n\t\t\t\t\tconst rB = ( SQ12194 * f2 * freq ) / ( ( f2 + SQ20_6 ) * Math.sqrt( f2 + SQ158_5 ) * ( f2 + SQ12194 ) );\n\t\t\t\t\treturn .17 + linearTodB( rB );\n\n\t\t\t\tcase FILTER_C :\n\t\t\t\t\tconst rC = ( SQ12194 * f2 ) / ( ( f2 + SQ20_6 ) * ( f2 + SQ12194 ) );\n\t\t\t\t\treturn .06 + linearTodB( rC );\n\n\t\t\t\tcase FILTER_D :\n\t\t\t\t\tconst h = ( ( 1037918.48 - f2 ) ** 2 + 1080768.16 * f2 ) / ( ( 9837328 - f2 ) ** 2 + 11723776 * f2 ),\n\t\t\t\t\t\t  rD = ( freq / 6.8966888496476e-5 ) * Math.sqrt( h / ( ( f2 + 79919.29 ) * ( f2 + 1345600 ) ) );\n\t\t\t\t\treturn linearTodB( rD );\n\n\t\t\t\tcase FILTER_468 : // ITU-R 468 https://en.wikipedia.org/wiki/ITU-R_468_noise_weighting\n\t\t\t\t\tconst h1 = -4.737338981378384e-24 * freq ** 6 + 2.043828333606125e-15 * freq ** 4 - 1.363894795463638e-7 * f2 + 1,\n\t\t\t\t\t\t  h2 = 1.306612257412824e-19 * freq ** 5 - 2.118150887518656e-11 * freq ** 3 + 5.559488023498642e-4 * freq,\n\t\t\t\t\t\t  rI = 1.246332637532143e-4 * freq / Math.hypot( h1, h2 );\n\t\t\t\t\treturn 18.2 + linearTodB( rI );\n\t\t\t}\n\n\t\t\treturn 0; // unknown filter\n\t\t}\n\n\t\t// draws (stroke) a bar from x,y1 to x,y2\n\t\tconst strokeBar = ( x, y1, y2 ) => {\n\t\t\t_ctx.beginPath();\n\t\t\t_ctx.moveTo( x, y1 );\n\t\t\t_ctx.lineTo( x, y2 );\n\t\t\t_ctx.stroke();\n\t\t}\n\n\t\t// conditionally strokes current path on canvas\n\t\tconst strokeIf = flag => {\n\t\t\tif ( flag && _lineWidth ) {\n\t\t\t\tconst alpha = _ctx.globalAlpha;\n\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t_ctx.stroke();\n\t\t\t\t_ctx.globalAlpha = alpha;\n\t\t\t}\n\t\t}\n\n\t\t// converts a value in [0;1] range to a height in pixels that fits into the current LED elements\n\t\tconst ledPosY = value => Math.max( 0, ( value * ledCount | 0 ) * ( ledHeight + ledSpaceV ) - ledSpaceV );\n\n\t\t// update energy information\n\t\tconst updateEnergy = newVal => {\n\t\t\t_energy.val = newVal;\n\t\t\tif ( _energy.peak > 0 ) {\n\t\t\t\t_energy.hold--;\n\t\t\t\tif ( _energy.hold < 0 )\n\t\t\t\t\t_energy.peak += _energy.hold * gravity / fpsSquared / canvas.height * this._pixelRatio;\n\t\t\t\t\t// TO-DO: replace `canvas.height * this._pixelRatio` with `maxNominalHeight` when implementing dual-channel energy\n\t\t\t}\n\t\t\tif ( newVal >= _energy.peak ) {\n\t\t\t\t_energy.peak = newVal;\n\t\t\t\t_energy.hold = holdFrames;\n\t\t\t}\n\t\t}\n\n\t\t/* MAIN FUNCTION */\n\n\t\tif ( overlay )\n\t\t\t_ctx.clearRect( 0, 0, canvas.width, canvas.height );\n\n\t\tlet currentEnergy = 0;\n\n\t\tconst nBars     = _bars.length,\n\t\t\t  nChannels = isSingle ? 1 : 2;\n\n\t\tfor ( let channel = 0; channel < nChannels; channel++ ) {\n\n\t\t\tconst { channelTop, channelBottom, analyzerBottom } = channelCoords[ channel ],\n\t\t\t\t  channelGradient  = this._gradients[ this._selectedGrads[ channel ] ],\n\t\t\t\t  colorStops       = channelGradient.colorStops,\n\t\t\t\t  colorCount       = colorStops.length,\n\t\t\t\t  bgColor          = ( ! showBgColor || isLeds && ! overlay ) ? '#000' : channelGradient.bgColor,\n\t\t\t\t  radialDirection  = isDualVertical && _radial && channel ? -1 : 1, // 1 = outwards, -1 = inwards\n\t\t\t\t  invertedChannel  = ( ! channel && _mirror == -1 ) || ( channel && _mirror == 1 ),\n\t\t\t\t  radialOffsetX    = ! isDualHorizontal || ( channel && _mirror != 1 ) ? 0 : analyzerWidth >> ( channel || ! invertedChannel ),\n\t\t\t\t  angularDirection = isDualHorizontal && invertedChannel ? -1 : 1;  // 1 = clockwise, -1 = counterclockwise\n/*\n\t\t\tExpanded logic for radialOffsetX and angularDirection:\n\n\t\t\tlet radialOffsetX = 0,\n\t\t\t\tangularDirection = 1;\n\n\t\t\tif ( isDualHorizontal ) {\n\t\t\t\tif ( channel == 0 ) { // LEFT channel\n\t\t\t\t\tif ( _mirror == -1 ) {\n\t\t\t\t\t\tradialOffsetX = analyzerWidth;\n\t\t\t\t\t\tangularDirection = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tradialOffsetX = analyzerWidth >> 1;\n\t\t\t\t}\n\t\t\t\telse {                // RIGHT channel\n\t\t\t\t\tif ( _mirror == 1 ) {\n\t\t\t\t\t\tradialOffsetX = analyzerWidth >> 1;\n\t\t\t\t\t\tangularDirection = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n*/\n\t\t\t// draw scale on Y-axis (uses: channel, channelTop)\n\t\t\tconst drawScaleY = () => {\n\t\t\t\tconst scaleWidth = canvasX.height,\n\t\t\t\t\t  fontSize   = scaleWidth >> 1,\n\t\t\t\t\t  max        = _linearAmplitude ? 100 : maxDecibels,\n\t\t\t\t\t  min        = _linearAmplitude ? 0 : minDecibels,\n\t\t\t\t\t  incr       = _linearAmplitude ? 20 : 5,\n\t\t\t\t\t  interval   = analyzerHeight / ( max - min ),\n\t\t\t\t\t  atStart    = _mirror != -1 && ( ! isDualHorizontal || channel == 0 || _mirror == 1 ),\n\t\t\t\t\t  atEnd      = _mirror != 1 && ( ! isDualHorizontal || channel != _mirror );\n\n\t\t\t\t_ctx.save();\n\t\t\t\t_ctx.fillStyle = SCALEY_LABEL_COLOR;\n\t\t\t\t_ctx.font = `${fontSize}px ${FONT_FAMILY}`;\n\t\t\t\t_ctx.textAlign = 'right';\n\t\t\t\t_ctx.lineWidth = 1;\n\n\t\t\t\tfor ( let val = max; val > min; val -= incr ) {\n\t\t\t\t\tconst posY = channelTop + ( max - val ) * interval,\n\t\t\t\t\t\t  even = ( val % 2 == 0 ) | 0;\n\n\t\t\t\t\tif ( even ) {\n\t\t\t\t\t\tconst labelY = posY + fontSize * ( posY == channelTop ? .8 : .35 );\n\t\t\t\t\t\tif ( atStart )\n\t\t\t\t\t\t\t_ctx.fillText( val, scaleWidth * .85, labelY );\n\t\t\t\t\t\tif ( atEnd )\n\t\t\t\t\t\t\t_ctx.fillText( val, ( isDualHorizontal ? analyzerWidth : canvas.width ) - scaleWidth * .1, labelY );\n\t\t\t\t\t\t_ctx.strokeStyle = SCALEY_LABEL_COLOR;\n\t\t\t\t\t\t_ctx.setLineDash([2,4]);\n\t\t\t\t\t\t_ctx.lineDashOffset = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_ctx.strokeStyle = SCALEY_MIDLINE_COLOR;\n\t\t\t\t\t\t_ctx.setLineDash([2,8]);\n\t\t\t\t\t\t_ctx.lineDashOffset = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t_ctx.beginPath();\n\t\t\t\t\t_ctx.moveTo( initialX + scaleWidth * even * atStart, ~~posY + .5 ); // for sharp 1px line (https://stackoverflow.com/a/13879402/2370385)\n\t\t\t\t\t_ctx.lineTo( finalX - scaleWidth * even * atEnd, ~~posY + .5 );\n\t\t\t\t\t_ctx.stroke();\n\t\t\t\t}\n\t\t\t\t_ctx.restore();\n\t\t\t}\n\n\t\t\t// FFT bin data interpolation (uses fftData)\n\t\t\tconst interpolate = ( bin, ratio ) => {\n\t\t\t\tconst value = fftData[ bin ] + ( bin < fftData.length - 1 ? ( fftData[ bin + 1 ] - fftData[ bin ] ) * ratio : 0 );\n\t\t\t\treturn isNaN( value ) ? -Infinity : value;\n\t\t\t}\n\n\t\t\t// converts a given X-coordinate to its corresponding angle in radial mode (uses angularDirection)\n\t\t\tconst getAngle = ( x, dir = angularDirection ) => dir * TAU * ( ( x + radialOffsetX ) / canvas.width ) + this._spinAngle;\n\n\t\t\t// converts planar X,Y coordinates to radial coordinates (uses: getAngle(), radialDirection)\n\t\t\tconst radialXY = ( x, y, dir ) => {\n\t\t\t\tconst height = innerRadius + y * radialDirection,\n\t\t\t\t\t  angle  = getAngle( x, dir );\n\t\t\t\treturn [ centerX + height * Math.cos( angle ), centerY + height * Math.sin( angle ) ];\n\t\t\t}\n\n\t\t\t// draws a polygon of width `w` and height `h` at (x,y) in radial mode (uses: angularDirection, radialDirection)\n\t\t\tconst radialPoly = ( x, y, w, h, stroke ) => {\n\t\t\t\t_ctx.beginPath();\n\t\t\t\tfor ( const dir of ( _mirror && ! isDualHorizontal ? [1,-1] : [ angularDirection ] ) ) {\n\t\t\t\t\tconst [ startAngle, endAngle ] = isRound ? [ getAngle( x, dir ), getAngle( x + w, dir ) ] : [];\n\t\t\t\t\t_ctx.moveTo( ...radialXY( x, y, dir ) );\n\t\t\t\t\t_ctx.lineTo( ...radialXY( x, y + h, dir ) );\n\t\t\t\t\tif ( isRound )\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius + ( y + h ) * radialDirection, startAngle, endAngle, dir != 1 );\n\t\t\t\t\telse\n\t\t\t\t\t\t_ctx.lineTo( ...radialXY( x + w, y + h, dir ) );\n\t\t\t\t\t_ctx.lineTo( ...radialXY( x + w, y, dir ) );\n\t\t\t\t\tif ( isRound && ! stroke ) // close the bottom line only when not in outline mode\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius + y * radialDirection, endAngle, startAngle, dir == 1 );\n\t\t\t\t}\n\t\t\t\tstrokeIf( stroke );\n\t\t\t\t_ctx.fill();\n\t\t\t}\n\n\t\t\t// set fillStyle and strokeStyle according to current colorMode (uses: channel, colorStops, colorCount)\n\t\t\tconst setBarColor = ( value = 0, barIndex = 0 ) => {\n\t\t\t\tlet color;\n\t\t\t\t// for graph mode, always use the channel gradient (ignore colorMode)\n\t\t\t\tif ( ( _colorMode == COLOR_GRADIENT && ! isTrueLeds ) || _mode == MODE_GRAPH )\n\t\t\t\t\tcolor = _canvasGradients[ channel ];\n\t\t\t\telse {\n\t\t\t\t\tconst selectedIndex = _colorMode == COLOR_BAR_INDEX ? barIndex % colorCount : colorStops.findLastIndex( item => isLeds ? ledPosY( value ) <= ledPosY( item.level ) : value <= item.level );\n\t\t\t\t\tcolor = colorStops[ selectedIndex ].color;\n\t\t\t\t}\n\t\t\t\t_ctx.fillStyle = _ctx.strokeStyle = color;\n\t\t\t}\n\n\t\t\t// CHANNEL START\n\n\t\t\tif ( useCanvas ) {\n\t\t\t\t// set transform (horizontal flip and translation) for dual-horizontal layout\n\t\t\t\tif ( isDualHorizontal && ! _radial ) {\n\t\t\t\t  \tconst translateX = analyzerWidth * ( channel + invertedChannel ),\n\t\t\t\t  \t\t  flipX      = invertedChannel ? -1 : 1;\n\n\t\t\t\t\t_ctx.setTransform( flipX, 0, 0, 1, translateX, 0 );\n\t\t\t\t}\n\n\t\t\t\t// fill the analyzer background if needed (not overlay or overlay + showBgColor)\n\t\t\t\tif ( ! overlay || showBgColor ) {\n\t\t\t\t\tif ( overlay )\n\t\t\t\t\t\t_ctx.globalAlpha = this.bgAlpha;\n\n\t\t\t\t\t_ctx.fillStyle = bgColor;\n\n\t\t\t\t\t// exclude the reflection area when overlay is true and reflexAlpha == 1 (avoids alpha over alpha difference, in case bgAlpha < 1)\n\t\t\t\t\tif ( channel == 0 || ( ! _radial && ! isDualCombined ) )\n\t\t\t\t\t\t_ctx.fillRect( initialX, channelTop - channelGap, analyzerWidth, ( overlay && this.reflexAlpha == 1 ? analyzerHeight : channelHeight ) + channelGap );\n\n\t\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t}\n\n\t\t\t\t// draw dB scale (Y-axis) - avoid drawing it twice on 'dual-combined' channel layout\n\t\t\t\tif ( this.showScaleY && ! isLumi && ! _radial && ( channel == 0 || ! isDualCombined ) )\n\t\t\t\t\tdrawScaleY();\n\n\t\t\t\t// set line width and dash for LEDs effect\n\t\t\t\tif ( isLeds ) {\n\t\t\t\t\t_ctx.setLineDash( [ ledHeight, ledSpaceV ] );\n\t\t\t\t\t_ctx.lineWidth = _bars[0].width;\n\t\t\t\t}\n\t\t\t\telse // for outline effect ensure linewidth is not greater than half the bar width\n\t\t\t\t\t_ctx.lineWidth = isOutline ? Math.min( _lineWidth, _bars[0].width / 2 ) : _lineWidth;\n\n\t\t\t\t// set clipping region\n\t\t\t\t_ctx.save();\n\t\t\t\tif ( ! _radial ) {\n\t\t\t\t\tconst region = new Path2D();\n\t\t\t\t\tregion.rect( 0, channelTop, canvas.width, analyzerHeight );\n\t\t\t\t\t_ctx.clip( region );\n\t\t\t\t}\n\n\t\t\t} // if ( useCanvas )\n\n\t\t\t// get a new array of data from the FFT\n\t\t\tlet fftData = this._fftData[ channel ];\n\t\t\tthis._analyzer[ channel ].getFloatFrequencyData( fftData );\n\n\t\t\t// apply weighting\n\t\t\tif ( _weightingFilter )\n\t\t\t\tfftData = fftData.map( ( val, idx ) => val + weightingdB( this._binToFreq( idx ) ) );\n\n\t\t\t// start drawing path (for graph mode)\n\t\t\t_ctx.beginPath();\n\n\t\t\t// store line graph points to create mirror effect in radial mode\n\t\t\tlet points = [];\n\n\t\t\t// draw bars / lines\n\n\t\t\tfor ( let barIndex = 0; barIndex < nBars; barIndex++ ) {\n\n\t\t\t\tconst bar = _bars[ barIndex ],\n\t\t\t\t\t  { posX, barCenter, width, freq, binLo, binHi, ratioLo, ratioHi } = bar;\n\n\t\t\t\tlet barValue = Math.max( interpolate( binLo, ratioLo ), interpolate( binHi, ratioHi ) );\n\n\t\t\t\t// check additional bins (if any) for this bar and keep the highest value\n\t\t\t\tfor ( let j = binLo + 1; j < binHi; j++ ) {\n\t\t\t\t\tif ( fftData[ j ] > barValue )\n\t\t\t\t\t\tbarValue = fftData[ j ];\n\t\t\t\t}\n\n\t\t\t\t// normalize bar amplitude in [0;1] range\n\t\t\t\tbarValue = this._normalizedB( barValue );\n\n\t\t\t\tbar.value[ channel ] = barValue;\n\t\t\t\tcurrentEnergy += barValue;\n\n\t\t\t\t// update bar peak\n\t\t\t\tif ( bar.peak[ channel ] > 0 && bar.alpha[ channel ] > 0 ) {\n\t\t\t\t\tbar.hold[ channel ]--;\n\t\t\t\t\t// if hold is negative, start peak drop or fade out\n\t\t\t\t\tif ( bar.hold[ channel ] < 0 ) {\n\t\t\t\t\t\tif ( _fadePeaks && ! showPeakLine ) {\n\t\t\t\t\t\t\tconst initialAlpha = ! isAlpha || ( isOutline && _lineWidth > 0 ) ? 1 : isAlpha ? bar.peak[ channel ] : fillAlpha;\n\t\t\t\t\t\t\tbar.alpha[ channel ] = initialAlpha * ( 1 + bar.hold[ channel ] / fadeFrames ); // hold is negative, so this is <= 1\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbar.peak[ channel ] += bar.hold[ channel ] * gravity / fpsSquared / nominalMaxHeight;\n\t\t\t\t\t\t// make sure the peak value is reset when using fadePeaks\n\t\t\t\t\t\tif ( bar.alpha[ channel ] <= 0 )\n\t\t\t\t\t\t\tbar.peak[ channel ] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// check if it's a new peak for this bar\n\t\t\t\tif ( barValue >= bar.peak[ channel ] ) {\n\t\t\t\t\tbar.peak[ channel ] = barValue;\n\t\t\t\t\tbar.hold[ channel ] = holdFrames;\n\t\t\t\t\t// check whether isAlpha or isOutline are active to start the peak alpha with the proper value\n\t\t\t\t\tbar.alpha[ channel ] = ! isAlpha || ( isOutline && _lineWidth > 0 ) ? 1 : isAlpha ? barValue : fillAlpha;\n\t\t\t\t}\n\n\t\t\t\t// if not using the canvas, move earlier to the next bar\n\t\t\t\tif ( ! useCanvas )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// set opacity for bar effects\n\t\t\t\t_ctx.globalAlpha = ( isLumi || isAlpha ) ? barValue : ( isOutline ) ? fillAlpha : 1;\n\n\t\t\t\t// set fillStyle and strokeStyle for the current bar\n\t\t\t\tsetBarColor( barValue, barIndex );\n\n\t\t\t\t// compute actual bar height on screen\n\t\t\t\tconst barHeight = isLumi ? maxBarHeight : isLeds ? ledPosY( barValue ) : barValue * maxBarHeight | 0;\n\n\t\t\t\t// Draw current bar or line segment\n\n\t\t\t\tif ( _mode == MODE_GRAPH ) {\n\t\t\t\t\t// compute the average between the initial bar (barIndex==0) and the next one\n\t\t\t\t\t// used to smooth the curve when the initial posX is off the screen, in mirror and radial modes\n\t\t\t\t\tconst nextBarAvg = barIndex ? 0 : ( this._normalizedB( fftData[ _bars[1].binLo ] ) * maxBarHeight + barHeight ) / 2;\n\n\t\t\t\t\tif ( _radial ) {\n\t\t\t\t\t\tif ( barIndex == 0 ) {\n\t\t\t\t\t\t\tif ( isDualHorizontal )\n\t\t\t\t\t\t\t\t_ctx.moveTo( ...radialXY( 0, 0 ) );\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( 0, ( posX < 0 ? nextBarAvg : barHeight ) ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// draw line to the current point, avoiding overlapping wrap-around frequencies\n\t\t\t\t\t\tif ( posX >= 0 ) {\n\t\t\t\t\t\t\tconst point = [ posX, barHeight ];\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...point ) );\n\t\t\t\t\t\t\tpoints.push( point );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse { // Linear\n\t\t\t\t\t\tif ( barIndex == 0 ) {\n\t\t\t\t\t\t\t// start the line off-screen using the previous FFT bin value as the initial amplitude\n\t\t\t\t\t\t\tif ( _mirror == -1 && ! isDualHorizontal )\n\t\t\t\t\t\t\t\t_ctx.moveTo( initialX, analyzerBottom - ( posX < initialX ? nextBarAvg : barHeight ) );\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tconst prevFFTData = binLo ? this._normalizedB( fftData[ binLo - 1 ] ) * maxBarHeight : barHeight; // use previous FFT bin value, when available\n\t\t\t\t\t\t\t\t_ctx.moveTo( initialX - _lineWidth, analyzerBottom - prevFFTData );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// draw line to the current point\n\t\t\t\t\t\t// avoid X values lower than the origin when mirroring left, otherwise draw them for best graph accuracy\n\t\t\t\t\t\tif ( isDualHorizontal || _mirror != -1 || posX >= initialX )\n\t\t\t\t\t\t\t_ctx.lineTo( posX, analyzerBottom - barHeight );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( isLeds ) {\n\t\t\t\t\t\t// draw \"unlit\" leds - avoid drawing it twice on 'dual-combined' channel layout\n\t\t\t\t\t\tif ( showBgColor && ! overlay && ( channel == 0 || ! isDualCombined ) ) {\n\t\t\t\t\t\t\tconst alpha = _ctx.globalAlpha;\n\t\t\t\t\t\t\t_ctx.strokeStyle = LEDS_UNLIT_COLOR;\n\t\t\t\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t\t\t\tstrokeBar( barCenter, channelTop, analyzerBottom );\n\t\t\t\t\t\t\t// restore properties\n\t\t\t\t\t\t\t_ctx.strokeStyle = _ctx.fillStyle;\n\t\t\t\t\t\t\t_ctx.globalAlpha = alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( isTrueLeds ) {\n\t\t\t\t\t\t\t// ledPosY() is used below to fit one entire led height into the selected range\n\t\t\t\t\t\t\tconst colorIndex = isLumi ? 0 : colorStops.findLastIndex( item => ledPosY( barValue ) <= ledPosY( item.level ) );\n\t\t\t\t\t\t\tlet last = analyzerBottom;\n\t\t\t\t\t\t\tfor ( let i = colorCount - 1; i >= colorIndex; i-- ) {\n\t\t\t\t\t\t\t\t_ctx.strokeStyle = colorStops[ i ].color;\n\t\t\t\t\t\t\t\tlet y = analyzerBottom - ( i == colorIndex ? barHeight : ledPosY( colorStops[ i ].level ) );\n\t\t\t\t\t\t\t\tstrokeBar( barCenter, last, y );\n\t\t\t\t\t\t\t\tlast = y - ledSpaceV;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstrokeBar( barCenter, analyzerBottom, analyzerBottom - barHeight );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( posX >= initialX ) {\n\t\t\t\t\t\tif ( _radial )\n\t\t\t\t\t\t\tradialPoly( posX, 0, width, barHeight, isOutline );\n\t\t\t\t\t\telse if ( isRound ) {\n\t\t\t\t\t\t\tconst halfWidth = width / 2,\n\t\t\t\t\t\t\t\t  y = analyzerBottom + halfWidth; // round caps have an additional height of half bar width\n\n\t\t\t\t\t\t\t_ctx.beginPath();\n\t\t\t\t\t\t\t_ctx.moveTo( posX, y );\n\t\t\t\t\t\t\t_ctx.lineTo( posX, y - barHeight );\n\t\t\t\t\t\t\t_ctx.arc( barCenter, y - barHeight, halfWidth, PI, TAU );\n\t\t\t\t\t\t\t_ctx.lineTo( posX + width, y );\n\t\t\t\t\t\t\tstrokeIf( isOutline );\n\t\t\t\t\t\t\t_ctx.fill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst offset = isOutline ? _ctx.lineWidth : 0;\n\t\t\t\t\t\t\t_ctx.beginPath();\n\t\t\t\t\t\t\t_ctx.rect( posX, analyzerBottom + offset, width, -barHeight - offset );\n\t\t\t\t\t\t\tstrokeIf( isOutline );\n\t\t\t\t\t\t\t_ctx.fill();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Draw peak\n\t\t\t\tconst peakValue = bar.peak[ channel ],\n\t\t\t\t\t  peakAlpha = bar.alpha[ channel ];\n\n\t\t\t\tif ( peakValue > 0 && peakAlpha > 0 && showPeaks && ! showPeakLine && ! isLumi && posX >= initialX && posX < finalX ) {\n\t\t\t\t\t// set opacity for peak\n\t\t\t\t\tif ( _fadePeaks )\n\t\t\t\t\t\t_ctx.globalAlpha = peakAlpha;\n\t\t\t\t\telse if ( isOutline && _lineWidth > 0 ) // when lineWidth == 0 ctx.globalAlpha remains set to `fillAlpha`\n\t\t\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t\telse if ( isAlpha )\t\t\t\t\t\t// isAlpha (alpha based on peak value) supersedes fillAlpha if lineWidth == 0\n\t\t\t\t\t\t_ctx.globalAlpha = peakValue;\n\n\t\t\t\t\t// select the peak color for 'bar-level' colorMode or 'trueLeds'\n\t\t\t\t\tif ( _colorMode == COLOR_BAR_LEVEL || isTrueLeds )\n\t\t\t\t\t\tsetBarColor( peakValue );\n\n\t\t\t\t\t// render peak according to current mode / effect\n\t\t\t\t\tif ( isLeds ) {\n\t\t\t\t\t\tconst ledPeak = ledPosY( peakValue );\n\t\t\t\t\t\tif ( ledPeak >= ledSpaceV ) // avoid peak below first led\n\t\t\t\t\t\t\t_ctx.fillRect( posX, analyzerBottom - ledPeak, width, ledHeight );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( ! _radial )\n\t\t\t\t\t\t_ctx.fillRect( posX, analyzerBottom - peakValue * maxBarHeight, width, 2 );\n\t\t\t\t\telse if ( _mode != MODE_GRAPH ) { // radial (peaks for graph mode are done by the peakLine code)\n\t\t\t\t\t\tconst y = peakValue * maxBarHeight;\n\t\t\t\t\t\tradialPoly( posX, y, width, ! this._radialInvert || isDualVertical || y + innerRadius >= 2 ? -2 : 2 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} // for ( let barIndex = 0; barIndex < nBars; barIndex++ )\n\n\t\t\t// if not using the canvas, move earlier to the next channel\n\t\t\tif ( ! useCanvas )\n\t\t\t\tcontinue;\n\n\t\t\t// restore global alpha\n\t\t\t_ctx.globalAlpha = 1;\n\n\t\t\t// Fill/stroke drawing path for graph mode\n\t\t\tif ( _mode == MODE_GRAPH ) {\n\t\t\t\tsetBarColor(); // select channel gradient\n\n\t\t\t\tif ( _radial && ! isDualHorizontal ) {\n\t\t\t\t\tif ( _mirror ) {\n\t\t\t\t\t\tlet p;\n\t\t\t\t\t\twhile ( p = points.pop() )\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...p, -1 ) );\n\t\t\t\t\t}\n\t\t\t\t\t_ctx.closePath();\n\t\t\t\t}\n\n\t\t\t\tif ( _lineWidth > 0 )\n\t\t\t\t\t_ctx.stroke();\n\n\t\t\t\tif ( fillAlpha > 0 ) {\n\t\t\t\t\tif ( _radial ) {\n\t\t\t\t\t\t// exclude the center circle from the fill area\n\t\t\t\t\t\tconst start = isDualHorizontal ? getAngle( analyzerWidth >> 1 ) : 0,\n\t\t\t\t\t\t\t  end   = isDualHorizontal ? getAngle( analyzerWidth ) : TAU;\n\t\t\t\t\t\t_ctx.moveTo( ...radialXY( isDualHorizontal ? analyzerWidth >> 1 : 0, 0 ) );\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius, start, end, isDualHorizontal ? ! invertedChannel : true );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// close the fill area\n\t\t\t\t\t\t_ctx.lineTo( finalX, analyzerBottom );\n\t\t\t\t\t\t_ctx.lineTo( initialX, analyzerBottom );\n\t\t\t\t\t}\n\n\t\t\t\t\t_ctx.globalAlpha = fillAlpha;\n\t\t\t\t\t_ctx.fill();\n\t\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t}\n\n\t\t\t\t// draw peak line (and standard peaks on radial)\n\t\t\t\tif ( showPeakLine || ( _radial && showPeaks ) ) {\n\t\t\t\t\tpoints = []; // for mirror line on radial\n\t\t\t\t\t_ctx.beginPath();\n\t\t\t\t\t_bars.forEach( ( b, i ) => {\n\t\t\t\t\t\tlet x = b.posX,\n\t\t\t\t\t\t\th = b.peak[ channel ],\n\t\t\t\t\t\t\tm = i ? 'lineTo' : 'moveTo';\n\t\t\t\t\t\tif ( _radial && x < 0 ) {\n\t\t\t\t\t\t\tconst nextBar = _bars[ i + 1 ];\n\t\t\t\t\t\t\th = findY( x, h, nextBar.posX, nextBar.peak[ channel ], 0 );\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\th *= maxBarHeight;\n\t\t\t\t\t\tif ( showPeakLine ) {\n\t\t\t\t\t\t\t_ctx[ m ]( ...( _radial ? radialXY( x, h ) : [ x, analyzerBottom - h ] ) );\n\t\t\t\t\t\t\tif ( _radial && _mirror && ! isDualHorizontal )\n\t\t\t\t\t\t\t\tpoints.push( [ x, h ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( h > 0 )\n\t\t\t\t\t\t\tradialPoly( x, h, 1, -2 ); // standard peaks (also does mirror)\n\t\t\t\t\t});\n\t\t\t\t\tif ( showPeakLine ) {\n\t\t\t\t\t\tlet p;\n\t\t\t\t\t\twhile ( p = points.pop() )\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...p, -1 ) ); // mirror line points\n\t\t\t\t\t\t_ctx.lineWidth = 1;\n\t\t\t\t\t\t_ctx.stroke(); // stroke peak line\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_ctx.restore(); // restore clip region\n\n\t\t\tif ( isDualHorizontal && ! _radial )\n\t\t\t\t_ctx.setTransform( 1, 0, 0, 1, 0, 0 );\n\n\t\t\t// create Reflex effect - for dual-combined and dual-horizontal do it only once, after channel 1\n\t\t\tif ( ( ! isDualHorizontal && ! isDualCombined ) || channel )\n\t\t\t\tdoReflex( channel );\n\n\t\t} // for ( let channel = 0; channel < nChannels; channel++ ) {\n\n\t\tupdateEnergy( currentEnergy / ( nBars << ( nChannels - 1 ) ) );\n\n\t\tif ( useCanvas ) {\n\t\t\t// Mirror effect\n\t\t\tif ( _mirror && ! _radial && ! isDualHorizontal ) {\n\t\t\t\t_ctx.setTransform( -1, 0, 0, 1, canvas.width - initialX, 0 );\n\t\t\t\t_ctx.drawImage( canvas, initialX, 0, centerX, canvas.height, 0, 0, centerX, canvas.height );\n\t\t\t\t_ctx.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\t\t}\n\n\t\t\t// restore solid lines\n\t\t\t_ctx.setLineDash([]);\n\n\t\t\t// draw frequency scale (X-axis)\n\t\t\tdrawScaleX();\n\t\t}\n\n\t\t// display current frame rate\n\t\tif ( this.showFPS ) {\n\t\t\tconst size = canvasX.height;\n\t\t\t_ctx.font = `bold ${size}px ${FONT_FAMILY}`;\n\t\t\t_ctx.fillStyle = FPS_COLOR;\n\t\t\t_ctx.textAlign = 'right';\n\t\t\t_ctx.fillText( Math.round( _fps ), canvas.width - size, size * 2 );\n\t\t}\n\n\t\t// call callback function, if defined\n\t\tif ( this.onCanvasDraw ) {\n\t\t\t_ctx.save();\n\t\t\t_ctx.fillStyle = _ctx.strokeStyle = _canvasGradients[0];\n\t\t\tthis.onCanvasDraw( this, { timestamp, canvasGradients: _canvasGradients } );\n\t\t\t_ctx.restore();\n\t\t}\n\t}\n\n\t/**\n\t * Return scaled frequency according to the selected scale\n\t */\n\t_freqScaling( freq ) {\n\t\tswitch ( this._frequencyScale ) {\n\t\t\tcase SCALE_LOG :\n\t\t\t\treturn Math.log2( freq );\n\t\t\tcase SCALE_BARK :\n\t\t\t\treturn ( 26.81 * freq ) / ( 1960 + freq ) - .53;\n\t\t\tcase SCALE_MEL :\n\t\t\t\treturn Math.log2( 1 + freq / 700 );\n\t\t\tcase SCALE_LINEAR :\n\t\t\t\treturn freq;\n\t\t}\n\t}\n\n\t/**\n\t * Return the FFT data bin (array index) which represents a given frequency\n\t */\n\t_freqToBin( freq, method = 'round' ) {\n\t\tconst max = this._analyzer[0].frequencyBinCount - 1,\n\t\t\t  bin = Math[ method ]( freq * this.fftSize / this.audioCtx.sampleRate );\n\n\t\treturn bin < max ? bin : max;\n\t}\n\n\t/**\n\t * Generate currently selected gradient\n\t */\n\t_makeGrad() {\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst { canvas, _ctx, _radial, _reflexRatio } = this,\n\t\t\t  { analyzerWidth, centerX, centerY, initialX, innerRadius, outerRadius } = this._aux,\n\t\t\t  { isLumi }     = this._flg,\n\t\t\t  isDualVertical = this._chLayout == CHANNEL_VERTICAL,\n\t\t\t  analyzerRatio  = 1 - _reflexRatio,\n\t\t\t  gradientHeight = isLumi ? canvas.height : canvas.height * ( 1 - _reflexRatio * ( ! isDualVertical ) ) | 0;\n\t\t\t  \t\t\t\t   // for vertical stereo we keep the full canvas height and handle the reflex areas while generating the color stops\n\n\t\tfor ( const channel of [0,1] ) {\n\t\t\tconst currGradient = this._gradients[ this._selectedGrads[ channel ] ],\n\t\t\t\t  colorStops   = currGradient.colorStops,\n\t\t\t\t  isHorizontal = currGradient.dir == 'h';\n\n\t\t\tlet grad;\n\n\t\t\tif ( _radial )\n\t\t\t\tgrad = _ctx.createRadialGradient( centerX, centerY, outerRadius, centerX, centerY, innerRadius - ( outerRadius - innerRadius ) * isDualVertical );\n\t\t\telse\n\t\t\t\tgrad = _ctx.createLinearGradient( ...( isHorizontal ? [ initialX, 0, initialX + analyzerWidth, 0 ] : [ 0, 0, 0, gradientHeight ] ) );\n\n\t\t\tif ( colorStops ) {\n\t\t\t\tconst dual = isDualVertical && ! this._splitGradient && ( ! isHorizontal || _radial );\n\n\t\t\t\tfor ( let channelArea = 0; channelArea < 1 + dual; channelArea++ ) {\n\t\t\t\t\tconst maxIndex = colorStops.length - 1;\n\n\t\t\t\t\tcolorStops.forEach( ( colorStop, index ) => {\n\t\t\t\t\t\tlet offset = colorStop.pos;\n\n\t\t\t\t\t\t// in dual mode (not split), use half the original offset for each channel\n\t\t\t\t\t\tif ( dual )\n\t\t\t\t\t\t\toffset /= 2;\n\n\t\t\t\t\t\t// constrain the offset within the useful analyzer areas (avoid reflex areas)\n\t\t\t\t\t\tif ( isDualVertical && ! isLumi && ! _radial && ! isHorizontal ) {\n\t\t\t\t\t\t\toffset *= analyzerRatio;\n\t\t\t\t\t\t\t// skip the first reflex area in split mode\n\t\t\t\t\t\t\tif ( ! dual && offset > .5 * analyzerRatio )\n\t\t\t\t\t\t\t\toffset += .5 * _reflexRatio;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only for dual-vertical non-split gradient (creates full gradient on both halves of the canvas)\n\t\t\t\t\t\tif ( channelArea == 1 ) {\n\t\t\t\t\t\t\t// add colors in reverse order if radial or lumi are active\n\t\t\t\t\t\t\tif ( _radial || isLumi ) {\n\t\t\t\t\t\t\t\tconst revIndex = maxIndex - index;\n\t\t\t\t\t\t\t\tcolorStop = colorStops[ revIndex ];\n\t\t\t\t\t\t\t\toffset = 1 - colorStop.pos / 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// if the first offset is not 0, create an additional color stop to prevent bleeding from the first channel\n\t\t\t\t\t\t\t\tif ( index == 0 && offset > 0 )\n\t\t\t\t\t\t\t\t\tgrad.addColorStop( .5, colorStop.color );\n\t\t\t\t\t\t\t\t// bump the offset to the second half of the gradient\n\t\t\t\t\t\t\t\toffset += .5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// add gradient color stop\n\t\t\t\t\t\tgrad.addColorStop( offset, colorStop.color );\n\n\t\t\t\t\t\t// create additional color stop at the end of first channel to prevent bleeding\n\t\t\t\t\t\tif ( isDualVertical && index == maxIndex && offset < .5 )\n\t\t\t\t\t\t\tgrad.addColorStop( .5, colorStop.color );\n\t\t\t\t\t});\n\t\t\t\t} // for ( let channelArea = 0; channelArea < 1 + dual; channelArea++ )\n\t\t\t}\n\n\t\t\tthis._canvasGradients[ channel ] = grad;\n\t\t} // for ( const channel of [0,1] )\n\t}\n\n\t/**\n\t * Normalize a dB value in the [0;1] range\n\t */\n\t_normalizedB( value ) {\n\t\tconst isLinear   = this._linearAmplitude,\n\t\t\t  boost      = isLinear ? 1 / this._linearBoost : 1,\n\t\t\t  clamp      = ( val, min, max ) => val <= min ? min : val >= max ? max : val,\n\t\t\t  dBToLinear = val => 10 ** ( val / 20 );\n\n\t\tlet maxValue = this.maxDecibels,\n\t\t\tminValue = this.minDecibels;\n\n\t\tif ( isLinear ) {\n\t\t\tmaxValue = dBToLinear( maxValue );\n\t\t\tminValue = dBToLinear( minValue );\n\t\t\tvalue = dBToLinear( value ) ** boost;\n\t\t}\n\n\t\treturn clamp( ( value - minValue ) / ( maxValue - minValue ) ** boost, 0, 1 );\n\t}\n\n\t/**\n\t * Internal function to change canvas dimensions on demand\n\t */\n\t_setCanvas( reason ) {\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst { canvas, _ctx } = this,\n\t\t\t  canvasX    = this._scaleX.canvas,\n\t\t\t  pixelRatio = window.devicePixelRatio / ( this._loRes + 1 );\n\n\t\tlet screenWidth  = window.screen.width  * pixelRatio,\n\t\t\tscreenHeight = window.screen.height * pixelRatio;\n\n\t\t// Fix for iOS Safari - swap width and height when in landscape\n\t\tif ( Math.abs( window.orientation ) == 90 && screenWidth < screenHeight )\n\t\t\t[ screenWidth, screenHeight ] = [ screenHeight, screenWidth ];\n\n\t\tconst isFullscreen = this.isFullscreen,\n\t\t\t  isCanvasFs   = isFullscreen && this._fsEl == canvas,\n\t\t\t  newWidth     = isCanvasFs ? screenWidth  : ( this._width  || this._container.clientWidth  || this._defaultWidth  ) * pixelRatio | 0,\n\t\t\t  newHeight    = isCanvasFs ? screenHeight : ( this._height || this._container.clientHeight || this._defaultHeight ) * pixelRatio | 0;\n\n\t\t// set/update object properties\n\t\tthis._pixelRatio = pixelRatio;\n\t\tthis._fsWidth    = screenWidth;\n\t\tthis._fsHeight   = screenHeight;\n\n\t\t// if this is not the constructor call and canvas dimensions haven't changed, quit\n\t\tif ( reason != REASON_CREATE && canvas.width == newWidth && canvas.height == newHeight )\n\t\t\treturn;\n\n\t\t// apply new dimensions\n\t\tcanvas.width  = newWidth;\n\t\tcanvas.height = newHeight;\n\n\t\t// if not in overlay mode, paint the canvas black\n\t\tif ( ! this.overlay ) {\n\t\t\t_ctx.fillStyle = '#000';\n\t\t\t_ctx.fillRect( 0, 0, newWidth, newHeight );\n\t\t}\n\n\t\t// set lineJoin property for area fill mode (this is reset whenever the canvas size changes)\n\t\t_ctx.lineJoin = 'bevel';\n\n\t\t// update dimensions of the scale canvas\n\t\tcanvasX.width = newWidth;\n\t\tcanvasX.height = Math.max( 20 * pixelRatio, Math.min( newWidth, newHeight ) / 32 | 0 );\n\n\t\t// calculate bar positions and led options\n\t\tthis._calcBars();\n\n\t\t// (re)generate gradient\n\t\tthis._makeGrad();\n\n\t\t// detect fullscreen changes (for Safari)\n\t\tif ( this._fsStatus !== undefined && this._fsStatus !== isFullscreen )\n\t\t\treason = REASON_FSCHANGE;\n\t\tthis._fsStatus = isFullscreen;\n\n\t\t// call the callback function, if defined\n\t\tif ( this.onCanvasResize )\n\t\t\tthis.onCanvasResize( reason, this );\n\t}\n\n\t/**\n\t * Select a gradient for one or both channels\n\t *\n\t * @param {string} name gradient name\n\t * @param [{number}] desired channel (0 or 1) - if empty or invalid, sets both channels\n\t */\n\t_setGradient( name, channel ) {\n\t\tif ( ! this._gradients.hasOwnProperty( name ) )\n\t\t\tthrow new AudioMotionError( ERR_UNKNOWN_GRADIENT, name );\n\n\t\tif ( ! [0,1].includes( channel ) ) {\n\t\t\tthis._selectedGrads[1] = name;\n\t\t\tchannel = 0;\n\t\t}\n\n\t\tthis._selectedGrads[ channel ] = name;\n\t\tthis._makeGrad();\n\t}\n\n\t/**\n\t * Set object properties\n\t */\n\t_setProps( options, useDefaults ) {\n\t\t// callback functions properties\n\t\tconst callbacks = [ 'onCanvasDraw', 'onCanvasResize' ];\n\n\t\t// properties not in the defaults (`stereo` is deprecated)\n\t\tconst extraProps = [ 'gradientLeft', 'gradientRight', 'stereo' ];\n\n\t\t// build an array of valid properties; `start` is not an actual property and is handled after setting everything else\n\t\tconst validProps = Object.keys( DEFAULT_SETTINGS ).filter( e => e != 'start' ).concat( callbacks, extraProps );\n\n\t\tif ( useDefaults || options === undefined )\n\t\t\toptions = { ...DEFAULT_SETTINGS, ...options }; // merge options with defaults\n\n\t\tfor ( const prop of Object.keys( options ) ) {\n\t\t\tif ( callbacks.includes( prop ) && typeof options[ prop ] !== 'function' ) // check invalid callback\n\t\t\t\tthis[ prop ] = undefined;\n\t\t\telse if ( validProps.includes( prop ) ) // set only valid properties\n\t\t\t\tthis[ prop ] = options[ prop ];\n\t\t}\n\n\t\t// deprecated - move this to the constructor in the next major release (`start` should be constructor-specific)\n\t\tif ( options.start !== undefined )\n\t\t\tthis.toggleAnalyzer( options.start );\n\t}\n\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioMotionAnalyzer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXVkaW9tb3Rpb24tYW5hbHl6ZXIvc3JjL2F1ZGlvTW90aW9uLWFuYWx5emVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzQ0FBc0M7QUFDNUMsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsTUFBTSxxQkFBcUIsYUFBYTs7QUFFcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLHNEQUFzRDtBQUN6RSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQiw4QkFBOEI7QUFDOUI7QUFDQSxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0EsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEI7QUFDQSw4QkFBOEI7QUFDOUIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsU0FBUzs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRyxJQUFJLFNBQVM7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSxTQUFTOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTyxnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0dBQWdH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QUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLHFCQUFxQjs7QUFFOUMsV0FBVyw0Q0FBNEM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTLEtBQUssWUFBWTtBQUM3QztBQUNBOztBQUVBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0EsZUFBZSxtQ0FBbUM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFK0I7QUFDL0IsaUVBQWUsbUJBQW1CLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY3N0b25cXERvY3VtZW50c1xccHJvamVjdHNcXGdpYmJlcmxpbmtcXGhhY2thdGhvbl9kZW1vXFxub2RlX21vZHVsZXNcXGF1ZGlvbW90aW9uLWFuYWx5emVyXFxzcmNcXGF1ZGlvTW90aW9uLWFuYWx5emVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiAqIGF1ZGlvTW90aW9uLWFuYWx5emVyXG4gKiBIaWdoLXJlc29sdXRpb24gcmVhbC10aW1lIGdyYXBoaWMgYXVkaW8gc3BlY3RydW0gYW5hbHl6ZXIgSlMgbW9kdWxlXG4gKlxuICogQHZlcnNpb24gNC41LjBcbiAqIEBhdXRob3IgIEhlbnJpcXVlIEF2aWxhIFZpYW5uYSA8aHZpYW5uYUBnbWFpbC5jb20+IDxodHRwczovL2hlbnJpcXVldmlhbm5hLmNvbT5cbiAqIEBsaWNlbnNlIEFHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuY29uc3QgVkVSU0lPTiA9ICc0LjUuMCc7XG5cbi8vIGludGVybmFsIGNvbnN0YW50c1xuY29uc3QgUEkgICAgICA9IE1hdGguUEksXG5cdCAgVEFVICAgICA9IDIgKiBQSSxcblx0ICBIQUxGX1BJID0gUEkgLyAyLFxuXHQgIENfMSAgICAgPSA4LjE3NTc5ODkyOyAgLy8gZnJlcXVlbmN5IGZvciBDIC0xXG5cbmNvbnN0IENBTlZBU19CQUNLR1JPVU5EX0NPTE9SICA9ICcjMDAwJyxcblx0ICBDSEFOTkVMX0NPTUJJTkVEICAgICAgICAgPSAnZHVhbC1jb21iaW5lZCcsXG5cdCAgQ0hBTk5FTF9IT1JJWk9OVEFMICAgICAgID0gJ2R1YWwtaG9yaXpvbnRhbCcsXG5cdCAgQ0hBTk5FTF9TSU5HTEUgICAgICAgICAgID0gJ3NpbmdsZScsXG5cdCAgQ0hBTk5FTF9WRVJUSUNBTCAgICAgICAgID0gJ2R1YWwtdmVydGljYWwnLFxuXHQgIENPTE9SX0JBUl9JTkRFWCAgICAgICAgICA9ICdiYXItaW5kZXgnLFxuXHQgIENPTE9SX0JBUl9MRVZFTCAgICAgICAgICA9ICdiYXItbGV2ZWwnLFxuXHQgIENPTE9SX0dSQURJRU5UICAgICAgICAgICA9ICdncmFkaWVudCcsXG5cdCAgREVCT1VOQ0VfVElNRU9VVCAgICAgICAgID0gNjAsXG5cdCAgRVZFTlRfQ0xJQ0sgICAgICAgICAgICAgID0gJ2NsaWNrJyxcblx0ICBFVkVOVF9GVUxMU0NSRUVOQ0hBTkdFICAgPSAnZnVsbHNjcmVlbmNoYW5nZScsXG5cdCAgRVZFTlRfUkVTSVpFICAgICAgICAgICAgID0gJ3Jlc2l6ZScsXG4gXHQgIEdSQURJRU5UX0RFRkFVTFRfQkdDT0xPUiA9ICcjMTExJyxcbiBcdCAgRklMVEVSX05PTkUgICAgICAgICAgICAgID0gJycsXG4gXHQgIEZJTFRFUl9BICAgICAgICAgICAgICAgICA9ICdBJyxcbiBcdCAgRklMVEVSX0IgICAgICAgICAgICAgICAgID0gJ0InLFxuIFx0ICBGSUxURVJfQyAgICAgICAgICAgICAgICAgPSAnQycsXG4gXHQgIEZJTFRFUl9EICAgICAgICAgICAgICAgICA9ICdEJyxcbiBcdCAgRklMVEVSXzQ2OCAgICAgICAgICAgICAgID0gJzQ2OCcsXG5cdCAgRk9OVF9GQU1JTFkgICAgICAgICAgICAgID0gJ3NhbnMtc2VyaWYnLFxuXHQgIEZQU19DT0xPUiAgICAgICAgICAgICAgICA9ICcjMGYwJyxcblx0ICBMRURTX1VOTElUX0NPTE9SICAgICAgICAgPSAnIzdmN2Y3ZjIyJyxcblx0ICBNT0RFX0dSQVBIICAgICAgICAgICAgICAgPSAxMCxcblx0ICBSRUFTT05fQ1JFQVRFICAgICAgICAgICAgPSAnY3JlYXRlJyxcblx0ICBSRUFTT05fRlNDSEFOR0UgICAgICAgICAgPSAnZnNjaGFuZ2UnLFxuXHQgIFJFQVNPTl9MT1JFUyAgICAgICAgICAgICA9ICdsb3JlcycsXG5cdCAgUkVBU09OX1JFU0laRSAgICAgICAgICAgID0gRVZFTlRfUkVTSVpFLFxuXHQgIFJFQVNPTl9VU0VSICAgICAgICAgICAgICA9ICd1c2VyJyxcblx0ICBTQ0FMRVhfQkFDS0dST1VORF9DT0xPUiAgPSAnIzAwMGMnLFxuXHQgIFNDQUxFWF9MQUJFTF9DT0xPUiAgICAgICA9ICcjZmZmJyxcblx0ICBTQ0FMRVhfSElHSExJR0hUX0NPTE9SICAgPSAnIzRmNCcsXG5cdCAgU0NBTEVZX0xBQkVMX0NPTE9SICAgICAgID0gJyM4ODgnLFxuXHQgIFNDQUxFWV9NSURMSU5FX0NPTE9SICAgICA9ICcjNTU1Jyxcblx0ICBTQ0FMRV9CQVJLICAgICAgICAgICAgICAgPSAnYmFyaycsXG5cdCAgU0NBTEVfTElORUFSICAgICAgICAgICAgID0gJ2xpbmVhcicsXG5cdCAgU0NBTEVfTE9HICAgICAgICAgICAgICAgID0gJ2xvZycsXG5cdCAgU0NBTEVfTUVMICAgICAgICAgICAgICAgID0gJ21lbCc7XG5cbi8vIGJ1aWx0LWluIGdyYWRpZW50c1xuY29uc3QgUFJJU00gPSBbICcjYTM1JywgJyNjNjYnLCAnI2U5NCcsICcjZWQwJywgJyM5ZDUnLCAnIzRkOCcsICcjMmNiJywgJyMwYmMnLCAnIzA5YycsICcjMzZiJyBdLFxuXHQgIEdSQURJRU5UUyA9IFtcblx0ICBbICdjbGFzc2ljJywge1xuXHRcdFx0Y29sb3JTdG9wczogW1xuXHRcdFx0XHQncmVkJyxcblx0XHRcdFx0eyBjb2xvcjogJ3llbGxvdycsIGxldmVsOiAuODUsIHBvczogLjYgfSxcblx0XHRcdFx0eyBjb2xvcjogJ2xpbWUnLCBsZXZlbDogLjQ3NSB9XG5cdFx0XHRdXG5cdCAgfV0sXG5cdCAgWyAncHJpc20nLCB7XG5cdFx0XHRjb2xvclN0b3BzOiBQUklTTVxuXHQgIH1dLFxuXHQgIFsgJ3JhaW5ib3cnLCB7XG5cdFx0XHRkaXI6ICdoJyxcblx0XHRcdGNvbG9yU3RvcHM6IFsgJyM4MTcnLCAuLi5QUklTTSwgJyM2MzknIF1cblx0ICB9XSxcblx0ICBbICdvcmFuZ2VyZWQnLCB7XG5cdCAgXHRcdGJnQ29sb3I6ICcjM2UyZjI5Jyxcblx0ICBcdFx0Y29sb3JTdG9wczogWyAnT3JhbmdlUmVkJyBdXG5cdCAgfV0sXG5cdCAgWyAnc3RlZWxibHVlJywge1xuXHQgIFx0XHRiZ0NvbG9yOiAnIzIyMmMzNScsXG5cdCAgXHRcdGNvbG9yU3RvcHM6IFsgJ1N0ZWVsQmx1ZScgXVxuXHQgIH1dXG5dO1xuXG4vLyBzZXR0aW5ncyBkZWZhdWx0c1xuY29uc3QgREVGQVVMVF9TRVRUSU5HUyA9IHtcblx0YWxwaGFCYXJzICAgICAgOiBmYWxzZSxcblx0YW5zaUJhbmRzICAgICAgOiBmYWxzZSxcblx0YmFyU3BhY2UgICAgICAgOiAwLjEsXG5cdGJnQWxwaGEgICAgICAgIDogMC43LFxuXHRjaGFubmVsTGF5b3V0ICA6IENIQU5ORUxfU0lOR0xFLFxuXHRjb2xvck1vZGUgICAgICA6IENPTE9SX0dSQURJRU5ULFxuXHRmYWRlUGVha3MgICAgICA6IGZhbHNlLFxuXHRmZnRTaXplICAgICAgICA6IDgxOTIsXG5cdGZpbGxBbHBoYSAgICAgIDogMSxcblx0ZnJlcXVlbmN5U2NhbGUgOiBTQ0FMRV9MT0csXG5cdGdyYWRpZW50ICAgICAgIDogR1JBRElFTlRTWzBdWzBdLFxuXHRncmF2aXR5ICAgICAgICA6IDMuOCxcblx0aGVpZ2h0ICAgICAgICAgOiB1bmRlZmluZWQsXG5cdGxlZEJhcnMgICAgICAgIDogZmFsc2UsXG5cdGxpbmVhckFtcGxpdHVkZTogZmFsc2UsXG5cdGxpbmVhckJvb3N0ICAgIDogMSxcblx0bGluZVdpZHRoICAgICAgOiAwLFxuXHRsb1JlcyAgICAgICAgICA6IGZhbHNlLFxuXHRsdW1pQmFycyAgICAgICA6IGZhbHNlLFxuXHRtYXhEZWNpYmVscyAgICA6IC0yNSxcblx0bWF4RlBTICAgICAgICAgOiAwLFxuXHRtYXhGcmVxICAgICAgICA6IDIyMDAwLFxuXHRtaW5EZWNpYmVscyAgICA6IC04NSxcblx0bWluRnJlcSAgICAgICAgOiAyMCxcblx0bWlycm9yICAgICAgICAgOiAwLFxuXHRtb2RlICAgICAgICAgICA6IDAsXG5cdG5vdGVMYWJlbHMgICAgIDogZmFsc2UsXG5cdG91dGxpbmVCYXJzICAgIDogZmFsc2UsXG5cdG92ZXJsYXkgICAgICAgIDogZmFsc2UsXG5cdHBlYWtGYWRlVGltZSAgIDogNzUwLFxuXHRwZWFrSG9sZFRpbWUgICA6IDUwMCxcblx0cGVha0xpbmUgICAgICAgOiBmYWxzZSxcblx0cmFkaWFsXHRcdCAgIDogZmFsc2UsXG5cdHJhZGlhbEludmVydCAgIDogZmFsc2UsXG5cdHJhZGl1cyAgICAgICAgIDogMC4zLFxuXHRyZWZsZXhBbHBoYSAgICA6IDAuMTUsXG5cdHJlZmxleEJyaWdodCAgIDogMSxcblx0cmVmbGV4Rml0ICAgICAgOiB0cnVlLFxuXHRyZWZsZXhSYXRpbyAgICA6IDAsXG5cdHJvdW5kQmFycyAgICAgIDogZmFsc2UsXG5cdHNob3dCZ0NvbG9yICAgIDogdHJ1ZSxcblx0c2hvd0ZQUyAgICAgICAgOiBmYWxzZSxcblx0c2hvd1BlYWtzICAgICAgOiB0cnVlLFxuXHRzaG93U2NhbGVYICAgICA6IHRydWUsXG5cdHNob3dTY2FsZVkgICAgIDogZmFsc2UsXG5cdHNtb290aGluZyAgICAgIDogMC41LFxuXHRzcGluU3BlZWQgICAgICA6IDAsXG5cdHNwbGl0R3JhZGllbnQgIDogZmFsc2UsXG5cdHN0YXJ0ICAgICAgICAgIDogdHJ1ZSxcblx0dHJ1ZUxlZHMgICAgICAgOiBmYWxzZSxcblx0dXNlQ2FudmFzICAgICAgOiB0cnVlLFxuXHR2b2x1bWUgICAgICAgICA6IDEsXG5cdHdlaWdodGluZ0ZpbHRlcjogRklMVEVSX05PTkUsXG5cdHdpZHRoICAgICAgICAgIDogdW5kZWZpbmVkXG59O1xuXG4vLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbmNvbnN0IEVSUl9BVURJT19DT05URVhUX0ZBSUwgICAgID0gWyAnRVJSX0FVRElPX0NPTlRFWFRfRkFJTCcsICdDb3VsZCBub3QgY3JlYXRlIGF1ZGlvIGNvbnRleHQuIFdlYiBBdWRpbyBBUEkgbm90IHN1cHBvcnRlZD8nIF0sXG5cdCAgRVJSX0lOVkFMSURfQVVESU9fQ09OVEVYVCAgPSBbICdFUlJfSU5WQUxJRF9BVURJT19DT05URVhUJywgJ1Byb3ZpZGVkIGF1ZGlvIGNvbnRleHQgaXMgbm90IHZhbGlkJyBdLFxuXHQgIEVSUl9VTktOT1dOX0dSQURJRU5UICAgICAgID0gWyAnRVJSX1VOS05PV05fR1JBRElFTlQnLCAnVW5rbm93biBncmFkaWVudCcgXSxcblx0ICBFUlJfRlJFUVVFTkNZX1RPT19MT1cgICAgICA9IFsgJ0VSUl9GUkVRVUVOQ1lfVE9PX0xPVycsICdGcmVxdWVuY3kgdmFsdWVzIG11c3QgYmUgPj0gMScgXSxcblx0ICBFUlJfSU5WQUxJRF9NT0RFICAgICAgICAgICA9IFsgJ0VSUl9JTlZBTElEX01PREUnLCAnSW52YWxpZCBtb2RlJyBdLFxuXHQgIEVSUl9SRUZMRVhfT1VUX09GX1JBTkdFICAgID0gWyAnRVJSX1JFRkxFWF9PVVRfT0ZfUkFOR0UnLCAnUmVmbGV4IHJhdGlvIG11c3QgYmUgPj0gMCBhbmQgPCAxJyBdLFxuXHQgIEVSUl9JTlZBTElEX0FVRElPX1NPVVJDRSAgID0gWyAnRVJSX0lOVkFMSURfQVVESU9fU09VUkNFJywgJ0F1ZGlvIHNvdXJjZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhUTUxNZWRpYUVsZW1lbnQgb3IgQXVkaW9Ob2RlJyBdLFxuXHQgIEVSUl9HUkFESUVOVF9JTlZBTElEX05BTUUgID0gWyAnRVJSX0dSQURJRU5UX0lOVkFMSURfTkFNRScsICdHcmFkaWVudCBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyBdLFxuXHQgIEVSUl9HUkFESUVOVF9OT1RfQU5fT0JKRUNUID0gWyAnRVJSX0dSQURJRU5UX05PVF9BTl9PQkpFQ1QnLCAnR3JhZGllbnQgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcgXSxcblx0ICBFUlJfR1JBRElFTlRfTUlTU0lOR19DT0xPUiA9IFsgJ0VSUl9HUkFESUVOVF9NSVNTSU5HX0NPTE9SJywgJ0dyYWRpZW50IGNvbG9yU3RvcHMgbXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheScgXTtcblxuY2xhc3MgQXVkaW9Nb3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoIGVycm9yLCB2YWx1ZSApIHtcblx0XHRjb25zdCBbIGNvZGUsIG1lc3NhZ2UgXSA9IGVycm9yO1xuXHRcdHN1cGVyKCBtZXNzYWdlICsgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gYDogJHt2YWx1ZX1gIDogJycgKSApO1xuXHRcdHRoaXMubmFtZSA9ICdBdWRpb01vdGlvbkVycm9yJztcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHR9XG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbiAtIG91dHB1dCBkZXByZWNhdGlvbiB3YXJuaW5nIG1lc3NhZ2Ugb24gY29uc29sZVxuY29uc3QgZGVwcmVjYXRlID0gKCBuYW1lLCBhbHRlcm5hdGl2ZSApID0+IGNvbnNvbGUud2FybiggYCR7bmFtZX0gaXMgZGVwcmVjYXRlZC4gVXNlICR7YWx0ZXJuYXRpdmV9IGluc3RlYWQuYCApO1xuXG4vLyBoZWxwZXIgZnVuY3Rpb24gLSBjaGVjayBpZiBhIGdpdmVuIG9iamVjdCBpcyBlbXB0eSAoYWxzbyByZXR1cm5zIGB0cnVlYCBvbiBudWxsLCB1bmRlZmluZWQgb3IgYW55IG5vbi1vYmplY3QgdmFsdWUpXG5jb25zdCBpc0VtcHR5ID0gb2JqID0+IHtcblx0Zm9yICggY29uc3QgcCBpbiBvYmogKVxuXHRcdHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbiAtIHZhbGlkYXRlIGEgZ2l2ZW4gdmFsdWUgd2l0aCBhbiBhcnJheSBvZiBzdHJpbmdzIChieSBkZWZhdWx0LCBhbGwgbG93ZXJjYXNlKVxuLy8gcmV0dXJucyB0aGUgdmFsaWRhdGVkIHZhbHVlLCBvciB0aGUgZmlyc3QgZWxlbWVudCBvZiBgbGlzdGAgaWYgYHZhbHVlYCBpcyBub3QgZm91bmQgaW4gdGhlIGFycmF5XG5jb25zdCB2YWxpZGF0ZUZyb21MaXN0ID0gKCB2YWx1ZSwgbGlzdCwgbW9kaWZpZXIgPSAndG9Mb3dlckNhc2UnICkgPT4gbGlzdFsgTWF0aC5tYXgoIDAsIGxpc3QuaW5kZXhPZiggKCAnJyArIHZhbHVlIClbIG1vZGlmaWVyIF0oKSApICkgXTtcblxuLy8gaGVscGVyIGZ1bmN0aW9uIC0gZmluZCB0aGUgWS1jb29yZGluYXRlIG9mIGEgcG9pbnQgbG9jYXRlZCBiZXR3ZWVuIHR3byBvdGhlciBwb2ludHMsIGdpdmVuIGl0cyBYLWNvb3JkaW5hdGVcbmNvbnN0IGZpbmRZID0gKCB4MSwgeTEsIHgyLCB5MiwgeCApID0+IHkxICsgKCB5MiAtIHkxICkgKiAoIHggLSB4MSApIC8gKCB4MiAtIHgxICk7XG5cbi8vIFBvbHlmaWxsIGZvciBBcnJheS5maW5kTGFzdEluZGV4KClcbmlmICggISBBcnJheS5wcm90b3R5cGUuZmluZExhc3RJbmRleCApIHtcblx0QXJyYXkucHJvdG90eXBlLmZpbmRMYXN0SW5kZXggPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0bGV0IGluZGV4ID0gdGhpcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpbmRleC0tID4gMCApIHtcblx0XHRcdGlmICggY2FsbGJhY2soIHRoaXNbIGluZGV4IF0gKSApXG5cdFx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG59XG5cbi8vIEF1ZGlvTW90aW9uQW5hbHl6ZXIgY2xhc3NcblxuY2xhc3MgQXVkaW9Nb3Rpb25BbmFseXplciB7XG5cbi8qKlxuICogQ09OU1RSVUNUT1JcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRhaW5lcl0gRE9NIGVsZW1lbnQgd2hlcmUgdG8gaW5zZXJ0IHRoZSBhbmFseXplcjsgaWYgdW5kZWZpbmVkLCB1c2VzIHRoZSBkb2N1bWVudCBib2R5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBdWRpb01vdGlvbkFuYWx5emVyIG9iamVjdFxuICovXG5cdGNvbnN0cnVjdG9yKCBjb250YWluZXIsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHRoaXMuX3JlYWR5ID0gZmFsc2U7XG5cblx0XHQvLyBJbml0aWFsaXplIGludGVybmFsIG9iamVjdHNcblx0XHR0aGlzLl9hdXggPSB7fTtcdFx0XHRcdC8vIGF1eGlsaWFyeSB2YXJpYWJsZXNcblx0XHR0aGlzLl9jYW52YXNHcmFkaWVudHMgPSBbXTsgLy8gQ2FudmFzR3JhZGllbnQgb2JqZWN0cyBmb3IgY2hhbm5lbHMgMCBhbmQgMVxuXHRcdHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2VuZXJneSA9IHsgdmFsOiAwLCBwZWFrOiAwLCBob2xkOiAwIH07XG5cdFx0dGhpcy5fZmxnID0ge307XHRcdFx0XHQvLyBmbGFnc1xuXHRcdHRoaXMuX2ZwcyA9IDA7XG5cdFx0dGhpcy5fZ3JhZGllbnRzID0ge307ICAgICAgIC8vIHJlZ2lzdGVyZWQgZ3JhZGllbnRzXG5cdFx0dGhpcy5fbGFzdCA9IDA7XHRcdFx0XHQvLyB0aW1lc3RhbXAgb2YgbGFzdCByZW5kZXJlZCBmcmFtZVxuXHRcdHRoaXMuX291dE5vZGVzID0gW107XHRcdC8vIG91dHB1dCBub2Rlc1xuXHRcdHRoaXMuX293bkNvbnRleHQgPSBmYWxzZTtcblx0XHR0aGlzLl9zZWxlY3RlZEdyYWRzID0gW107ICAgLy8gbmFtZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBncmFkaWVudHMgZm9yIGNoYW5uZWxzIDAgYW5kIDFcblx0XHR0aGlzLl9zb3VyY2VzID0gW107XHRcdFx0Ly8gaW5wdXQgbm9kZXNcblxuXHRcdC8vIENoZWNrIGlmIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudFxuXHRcdGlmICggISAoIGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQgKSApIHtcblx0XHRcdGlmICggaXNFbXB0eSggb3B0aW9ucyApICYmICEgaXNFbXB0eSggY29udGFpbmVyICkgKVxuXHRcdFx0XHRvcHRpb25zID0gY29udGFpbmVyO1xuXHRcdFx0Y29udGFpbmVyID0gbnVsbDtcblx0XHR9XG5cblx0XHR0aGlzLl9vd25DYW52YXMgPSAhICggb3B0aW9ucy5jYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApO1xuXG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGNhbnZhcyBvciB1c2UgdGhlIG9uZSBwcm92aWRlZCBieSB0aGUgdXNlclxuXHRcdGNvbnN0IGNhbnZhcyA9IHRoaXMuX293bkNhbnZhcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpIDogb3B0aW9ucy5jYW52YXM7XG5cdFx0Y2FudmFzLnN0eWxlID0gJ21heC13aWR0aDogMTAwJTsnO1xuXHRcdHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0Ly8gUmVnaXN0ZXIgYnVpbHQtaW4gZ3JhZGllbnRzXG5cdFx0Zm9yICggY29uc3QgWyBuYW1lLCBvcHRpb25zIF0gb2YgR1JBRElFTlRTIClcblx0XHRcdHRoaXMucmVnaXN0ZXJHcmFkaWVudCggbmFtZSwgb3B0aW9ucyApO1xuXG5cdFx0Ly8gU2V0IGNvbnRhaW5lclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lciB8fCAoICEgdGhpcy5fb3duQ2FudmFzICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50ICkgfHwgZG9jdW1lbnQuYm9keTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIG1pbmltYWwgd2lkdGggYW5kIGhlaWdodCBkaW1lbnNpb25zIGluIGNhc2Ugb2YgYW4gaW5saW5lIGNvbnRhaW5lclxuXHRcdHRoaXMuX2RlZmF1bHRXaWR0aCAgPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggIHx8IDY0MDtcblx0XHR0aGlzLl9kZWZhdWx0SGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAyNzA7XG5cblx0XHQvLyBVc2UgYXVkaW8gY29udGV4dCBwcm92aWRlZCBieSB1c2VyLCBvciBjcmVhdGUgYSBuZXcgb25lXG5cblx0XHRsZXQgYXVkaW9DdHg7XG5cblx0XHRpZiAoIG9wdGlvbnMuc291cmNlICYmICggYXVkaW9DdHggPSBvcHRpb25zLnNvdXJjZS5jb250ZXh0ICkgKSB7XG5cdFx0XHQvLyBnZXQgYXVkaW9Db250ZXh0IGZyb20gcHJvdmlkZWQgc291cmNlIGF1ZGlvTm9kZVxuXHRcdH1cblx0XHRlbHNlIGlmICggYXVkaW9DdHggPSBvcHRpb25zLmF1ZGlvQ3R4ICkge1xuXHRcdFx0Ly8gdXNlIGF1ZGlvQ29udGV4dCBwcm92aWRlZCBieSB1c2VyXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXVkaW9DdHggPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXHRcdFx0XHR0aGlzLl9vd25Db250ZXh0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGNhdGNoKCBlcnIgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfQVVESU9fQ09OVEVYVF9GQUlMICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbWFrZSBzdXJlIGF1ZGlvQ29udGV4dCBpcyB2YWxpZFxuXHRcdGlmICggISBhdWRpb0N0eC5jcmVhdGVHYWluIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfSU5WQUxJRF9BVURJT19DT05URVhUICk7XG5cblx0XHQvKlxuXHRcdFx0Q29ubmVjdGlvbiByb3V0aW5nOlxuXHRcdFx0PT09PT09PT09PT09PT09PT09PVxuXG5cdFx0XHRmb3IgZHVhbCBjaGFubmVsIGxheW91dHM6ICAgICAgICAgICAgICAgICstLS0+ICBhbmFseXplclswXSAgLS0tK1xuXHRcdCAgICBcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIHxcblx0XHRcdChzb3VyY2UpIC0tLT4gIGlucHV0ICAtLS0+ICBzcGxpdHRlciAgLS0tKyAgICAgICAgICAgICAgICAgICAgICArLS0tPiAgbWVyZ2VyICAtLS0+ICBvdXRwdXQgIC0tLT4gKGRlc3RpbmF0aW9uKVxuXHRcdCAgICBcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIHxcblx0XHQgICAgICAgIFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLT4gIGFuYWx5emVyWzFdICAtLS0rXG5cblx0XHRcdGZvciBzaW5nbGUgY2hhbm5lbCBsYXlvdXQ6XG5cblx0XHRcdChzb3VyY2UpIC0tLT4gIGlucHV0ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4gIGFuYWx5emVyWzBdICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0+ICBvdXRwdXQgIC0tLT4gKGRlc3RpbmF0aW9uKVxuXG5cdFx0Ki9cblxuXHRcdC8vIGNyZWF0ZSB0aGUgYW5hbHl6ZXIgbm9kZXMsIGNoYW5uZWwgc3BsaXR0ZXIgYW5kIG1lcmdlciwgYW5kIGdhaW4gbm9kZXMgZm9yIGlucHV0L291dHB1dCBjb25uZWN0aW9uc1xuXHRcdGNvbnN0IGFuYWx5emVyID0gdGhpcy5fYW5hbHl6ZXIgPSBbIGF1ZGlvQ3R4LmNyZWF0ZUFuYWx5c2VyKCksIGF1ZGlvQ3R4LmNyZWF0ZUFuYWx5c2VyKCkgXTtcblx0XHRjb25zdCBzcGxpdHRlciA9IHRoaXMuX3NwbGl0dGVyID0gYXVkaW9DdHguY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuIFx0XHRjb25zdCBtZXJnZXIgICA9IHRoaXMuX21lcmdlciAgID0gYXVkaW9DdHguY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcbiBcdFx0dGhpcy5faW5wdXQgICAgPSBhdWRpb0N0eC5jcmVhdGVHYWluKCk7XG4gXHRcdHRoaXMuX291dHB1dCAgID0gYXVkaW9DdHguY3JlYXRlR2FpbigpO1xuXG4gXHRcdC8vIGNvbm5lY3QgYXVkaW8gc291cmNlIGlmIHByb3ZpZGVkIGluIHRoZSBvcHRpb25zXG5cdFx0aWYgKCBvcHRpb25zLnNvdXJjZSApXG5cdFx0XHR0aGlzLmNvbm5lY3RJbnB1dCggb3B0aW9ucy5zb3VyY2UgKTtcblxuIFx0XHQvLyBjb25uZWN0IHNwbGl0dGVyIC0+IGFuYWx5emVyc1xuIFx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdHNwbGl0dGVyLmNvbm5lY3QoIGFuYWx5emVyWyBpIF0sIGkgKTtcblxuXHRcdC8vIGNvbm5lY3QgbWVyZ2VyIC0+IG91dHB1dFxuXHRcdG1lcmdlci5jb25uZWN0KCB0aGlzLl9vdXRwdXQgKTtcblxuXHRcdC8vIGNvbm5lY3Qgb3V0cHV0IC0+IGRlc3RpbmF0aW9uIChzcGVha2Vycylcblx0XHRpZiAoIG9wdGlvbnMuY29ubmVjdFNwZWFrZXJzICE9PSBmYWxzZSApXG5cdFx0XHR0aGlzLmNvbm5lY3RPdXRwdXQoKTtcblxuXHRcdC8vIGNyZWF0ZSBhdXhpbGlhcnkgY2FudmFzZXMgZm9yIHRoZSBYLWF4aXMgYW5kIHJhZGlhbCBzY2FsZSBsYWJlbHNcblx0XHRmb3IgKCBjb25zdCBjdHggb2YgWyAnX3NjYWxlWCcsICdfc2NhbGVSJyBdIClcblx0XHRcdHRoaXNbIGN0eCBdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdC8vIHNldCBmdWxsc2NyZWVuIGVsZW1lbnQgKGRlZmF1bHRzIHRvIGNhbnZhcylcblx0XHR0aGlzLl9mc0VsID0gb3B0aW9ucy5mc0VsZW1lbnQgfHwgY2FudmFzO1xuXG5cdFx0Ly8gVXBkYXRlIGNhbnZhcyBzaXplIG9uIGNvbnRhaW5lciAvIHdpbmRvdyByZXNpemUgYW5kIGZ1bGxzY3JlZW4gZXZlbnRzXG5cblx0XHQvLyBGdWxsc2NyZWVuIGNoYW5nZXMgYXJlIGhhbmRsZWQgcXVpdGUgZGlmZmVyZW50bHkgYWNyb3NzIGJyb3dzZXJzOlxuXHRcdC8vIDEuIENocm9taXVtIGJyb3dzZXJzIHdpbGwgdHJpZ2dlciBhIGByZXNpemVgIGV2ZW50IGZvbGxvd2VkIGJ5IGEgYGZ1bGxzY3JlZW5jaGFuZ2VgXG5cdFx0Ly8gMi4gRmlyZWZveCB0cmlnZ2VycyB0aGUgYGZ1bGxzY3JlZW5jaGFuZ2VgIGZpcnN0IGFuZCB0aGVuIHRoZSBgcmVzaXplYFxuXHRcdC8vIDMuIENocm9tZSBvbiBBbmRyb2lkIChUVikgd29uJ3QgdHJpZ2dlciBhIGByZXNpemVgIGV2ZW50LCBvbmx5IGBmdWxsc2NyZWVuY2hhbmdlYFxuXHRcdC8vIDQuIFNhZmFyaSB3b24ndCB0cmlnZ2VyIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudHMgYXQgYWxsLCBhbmQgb24gaVBhZE9TIHRoZSBgcmVzaXplYFxuXHRcdC8vICAgIGV2ZW50IGlzIHRyaWdnZXJlZCAqKm9uIHRoZSB3aW5kb3cqKiBvbmx5IChsYXN0IHRlc3RlZCBvbiBpUGFkT1MgMTQpXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIHJlc2l6ZSBldmVudHNcblx0XHRjb25zdCBvblJlc2l6ZSA9ICgpID0+IHtcblx0XHRcdGlmICggISB0aGlzLl9mc1RpbWVvdXQgKSB7XG5cdFx0XHRcdC8vIGRlbGF5IHRoZSByZXNpemUgdG8gcHJpb3JpdGl6ZSBhIHBvc3NpYmxlIGZvbGxvd2luZyBgZnVsbHNjcmVlbmNoYW5nZWAgZXZlbnRcblx0XHRcdFx0dGhpcy5fZnNUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdFx0XHRpZiAoICEgdGhpcy5fZnNDaGFuZ2luZyApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3NldENhbnZhcyggUkVBU09OX1JFU0laRSApO1xuXHRcdFx0XHRcdFx0dGhpcy5fZnNUaW1lb3V0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIERFQk9VTkNFX1RJTUVPVVQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBpZiBicm93c2VyIHN1cHBvcnRzIFJlc2l6ZU9ic2VydmVyLCBsaXN0ZW4gZm9yIHJlc2l6ZSBvbiB0aGUgY29udGFpbmVyXG5cdFx0aWYgKCB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgKSB7XG5cdFx0XHR0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlciggb25SZXNpemUgKTtcblx0XHRcdHRoaXMuX29ic2VydmVyLm9ic2VydmUoIHRoaXMuX2NvbnRhaW5lciApO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBhbiBBYm9ydENvbnRyb2xsZXIgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBvbiBkZXN0cm95KClcblx0XHR0aGlzLl9jb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHRcdGNvbnN0IHNpZ25hbCA9IHRoaXMuX2NvbnRyb2xsZXIuc2lnbmFsO1xuXG5cdFx0Ly8gbGlzdGVuIGZvciByZXNpemUgZXZlbnRzIG9uIHRoZSB3aW5kb3cgLSByZXF1aXJlZCBmb3IgZnVsbHNjcmVlbiBvbiBpUGFkT1Ncblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggRVZFTlRfUkVTSVpFLCBvblJlc2l6ZSwgeyBzaWduYWwgfSApO1xuXG5cdFx0Ly8gbGlzdGVuIGZvciBmdWxsc2NyZWVuY2hhbmdlIGV2ZW50cyBvbiB0aGUgY2FudmFzIC0gbm90IGF2YWlsYWJsZSBvbiBTYWZhcmlcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggRVZFTlRfRlVMTFNDUkVFTkNIQU5HRSwgKCkgPT4ge1xuXHRcdFx0Ly8gc2V0IGZsYWcgdG8gaW5kaWNhdGUgYSBmdWxsc2NyZWVuIGNoYW5nZSBpbiBwcm9ncmVzc1xuXHRcdFx0dGhpcy5fZnNDaGFuZ2luZyA9IHRydWU7XG5cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEgc2NoZWR1bGVkIHJlc2l6ZSBldmVudCwgY2xlYXIgaXRcblx0XHRcdGlmICggdGhpcy5fZnNUaW1lb3V0IClcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGhpcy5fZnNUaW1lb3V0ICk7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgY2FudmFzXG5cdFx0XHR0aGlzLl9zZXRDYW52YXMoIFJFQVNPTl9GU0NIQU5HRSApO1xuXG5cdFx0XHQvLyBkZWxheSBjbGVhcmluZyB0aGUgZmxhZyB0byBwcmV2ZW50IGFueSBzaG9ydGx5IGZvbGxvd2luZyByZXNpemUgZXZlbnRcblx0XHRcdHRoaXMuX2ZzVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX2ZzQ2hhbmdpbmcgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fZnNUaW1lb3V0ID0gMDtcblx0XHRcdH0sIERFQk9VTkNFX1RJTUVPVVQgKTtcblx0XHR9LCB7IHNpZ25hbCB9ICk7XG5cblx0XHQvLyBSZXN1bWUgYXVkaW8gY29udGV4dCBpZiBpbiBzdXNwZW5kZWQgc3RhdGUgKGJyb3dzZXJzJyBhdXRvcGxheSBwb2xpY3kpXG5cdFx0Y29uc3QgdW5sb2NrQ29udGV4dCA9ICgpID0+IHtcblx0XHRcdGlmICggYXVkaW9DdHguc3RhdGUgPT0gJ3N1c3BlbmRlZCcgKVxuXHRcdFx0XHRhdWRpb0N0eC5yZXN1bWUoKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBFVkVOVF9DTElDSywgdW5sb2NrQ29udGV4dCApO1xuXHRcdH1cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggRVZFTlRfQ0xJQ0ssIHVubG9ja0NvbnRleHQgKTtcblxuXHRcdC8vIHJlc2V0IEZQUy1yZWxhdGVkIHZhcmlhYmxlcyB3aGVuIHdpbmRvdyBiZWNvbWVzIHZpc2libGUgKGF2b2lkIEZQUyBkcm9wIGR1ZSB0byBmcmFtZXMgbm90IHJlbmRlcmVkIHdoaWxlIGhpZGRlbilcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcblx0XHRcdGlmICggZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9ICdoaWRkZW4nICkge1xuXHRcdFx0XHR0aGlzLl9mcmFtZXMgPSAwO1xuXHRcdFx0XHR0aGlzLl90aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHR9XG5cdFx0fSwgeyBzaWduYWwgfSApO1xuXG5cdFx0Ly8gU2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhbmQgdXNlIGRlZmF1bHRzIGZvciBhbnkgbWlzc2luZyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fc2V0UHJvcHMoIG9wdGlvbnMsIHRydWUgKTtcblxuXHRcdC8vIEFkZCBjYW52YXMgdG8gdGhlIGNvbnRhaW5lciAob25seSB3aGVuIGNhbnZhcyBub3QgcHJvdmlkZWQgYnkgdXNlcilcblx0XHRpZiAoIHRoaXMudXNlQ2FudmFzICYmIHRoaXMuX293bkNhbnZhcyApXG5cdFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoIGNhbnZhcyApO1xuXG5cdFx0Ly8gRmluaXNoIGNhbnZhcyBzZXR1cFxuXHRcdHRoaXMuX3JlYWR5ID0gdHJ1ZTtcblx0XHR0aGlzLl9zZXRDYW52YXMoIFJFQVNPTl9DUkVBVEUgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKlxuXHQgKiBQVUJMSUMgUFJPUEVSVElFUyBHRVRURVJTIEFORCBTRVRURVJTXG5cdCAqXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqL1xuXG5cdGdldCBhbHBoYUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FscGhhQmFycztcblx0fVxuXHRzZXQgYWxwaGFCYXJzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9hbHBoYUJhcnMgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IGFuc2lCYW5kcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5zaUJhbmRzO1xuXHR9XG5cdHNldCBhbnNpQmFuZHMoIHZhbHVlICkge1xuXHRcdHRoaXMuX2Fuc2lCYW5kcyA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdH1cblxuXHRnZXQgYmFyU3BhY2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JhclNwYWNlO1xuXHR9XG5cdHNldCBiYXJTcGFjZSggdmFsdWUgKSB7XG5cdFx0dGhpcy5fYmFyU3BhY2UgPSArdmFsdWUgfHwgMDtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IGNoYW5uZWxMYXlvdXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoTGF5b3V0O1xuXHR9XG5cdHNldCBjaGFubmVsTGF5b3V0KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9jaExheW91dCA9IHZhbGlkYXRlRnJvbUxpc3QoIHZhbHVlLCBbIENIQU5ORUxfU0lOR0xFLCBDSEFOTkVMX0hPUklaT05UQUwsIENIQU5ORUxfVkVSVElDQUwsIENIQU5ORUxfQ09NQklORUQgXSApO1xuXG5cdFx0Ly8gdXBkYXRlIG5vZGUgY29ubmVjdGlvbnNcblx0XHR0aGlzLl9pbnB1dC5kaXNjb25uZWN0KCk7XG5cdFx0dGhpcy5faW5wdXQuY29ubmVjdCggdGhpcy5fY2hMYXlvdXQgIT0gQ0hBTk5FTF9TSU5HTEUgPyB0aGlzLl9zcGxpdHRlciA6IHRoaXMuX2FuYWx5emVyWzBdICk7XG5cdFx0dGhpcy5fYW5hbHl6ZXJbMF0uZGlzY29ubmVjdCgpO1xuXHRcdGlmICggdGhpcy5fb3V0Tm9kZXMubGVuZ3RoICkgLy8gY29ubmVjdCBhbmFseXplciBvbmx5IGlmIHRoZSBvdXRwdXQgaXMgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzXG5cdFx0XHR0aGlzLl9hbmFseXplclswXS5jb25uZWN0KCB0aGlzLl9jaExheW91dCAhPSBDSEFOTkVMX1NJTkdMRSA/IHRoaXMuX21lcmdlciA6IHRoaXMuX291dHB1dCApO1xuXG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0Z2V0IGNvbG9yTW9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29sb3JNb2RlO1xuXHR9XG5cdHNldCBjb2xvck1vZGUoIHZhbHVlICkge1xuXHRcdHRoaXMuX2NvbG9yTW9kZSA9IHZhbGlkYXRlRnJvbUxpc3QoIHZhbHVlLCBbIENPTE9SX0dSQURJRU5ULCBDT0xPUl9CQVJfSU5ERVgsIENPTE9SX0JBUl9MRVZFTCBdICk7XG5cdH1cblxuXHRnZXQgZmFkZVBlYWtzKCkge1xuXHRcdHJldHVybiB0aGlzLl9mYWRlUGVha3M7XG5cdH1cblx0c2V0IGZhZGVQZWFrcyggdmFsdWUgKSB7XG5cdFx0dGhpcy5fZmFkZVBlYWtzID0gISEgdmFsdWU7XG5cdH1cblxuXHRnZXQgZmZ0U2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5hbHl6ZXJbMF0uZmZ0U2l6ZTtcblx0fVxuXHRzZXQgZmZ0U2l6ZSggdmFsdWUgKSB7XG5cdFx0Zm9yICggY29uc3QgaSBvZiBbMCwxXSApXG5cdFx0XHR0aGlzLl9hbmFseXplclsgaSBdLmZmdFNpemUgPSB2YWx1ZTtcblx0XHRjb25zdCBiaW5Db3VudCA9IHRoaXMuX2FuYWx5emVyWzBdLmZyZXF1ZW5jeUJpbkNvdW50O1xuXHRcdHRoaXMuX2ZmdERhdGEgPSBbIG5ldyBGbG9hdDMyQXJyYXkoIGJpbkNvdW50ICksIG5ldyBGbG9hdDMyQXJyYXkoIGJpbkNvdW50ICkgXTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IGZyZXF1ZW5jeVNjYWxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9mcmVxdWVuY3lTY2FsZTtcblx0fVxuXHRzZXQgZnJlcXVlbmN5U2NhbGUoIHZhbHVlICkge1xuXHRcdHRoaXMuX2ZyZXF1ZW5jeVNjYWxlID0gdmFsaWRhdGVGcm9tTGlzdCggdmFsdWUsIFsgU0NBTEVfTE9HLCBTQ0FMRV9CQVJLLCBTQ0FMRV9NRUwsIFNDQUxFX0xJTkVBUiBdICk7XG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0fVxuXG5cdGdldCBncmFkaWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWRHcmFkc1swXTtcblx0fVxuXHRzZXQgZ3JhZGllbnQoIHZhbHVlICkge1xuXHRcdHRoaXMuX3NldEdyYWRpZW50KCB2YWx1ZSApO1xuXHR9XG5cblx0Z2V0IGdyYWRpZW50TGVmdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWRHcmFkc1swXTtcblx0fVxuXHRzZXQgZ3JhZGllbnRMZWZ0KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zZXRHcmFkaWVudCggdmFsdWUsIDAgKTtcblx0fVxuXG5cdGdldCBncmFkaWVudFJpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZEdyYWRzWzFdO1xuXHR9XG5cdHNldCBncmFkaWVudFJpZ2h0KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zZXRHcmFkaWVudCggdmFsdWUsIDEgKTtcblx0fVxuXG5cdGdldCBncmF2aXR5KCkge1xuXHRcdHJldHVybiB0aGlzLl9ncmF2aXR5O1xuXHR9XG5cdHNldCBncmF2aXR5KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9ncmF2aXR5ID0gdmFsdWUgPiAwID8gK3ZhbHVlIDogdGhpcy5fZ3Jhdml0eSB8fCBERUZBVUxUX1NFVFRJTkdTLmdyYXZpdHk7XG5cdH1cblxuXHRnZXQgaGVpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLl9oZWlnaHQ7XG5cdH1cblx0c2V0IGhlaWdodCggaCApIHtcblx0XHR0aGlzLl9oZWlnaHQgPSBoO1xuXHRcdHRoaXMuX3NldENhbnZhcyggUkVBU09OX1VTRVIgKTtcblx0fVxuXG5cdGdldCBsZWRCYXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaG93TGVkcztcblx0fVxuXHRzZXQgbGVkQmFycyggdmFsdWUgKSB7XG5cdFx0dGhpcy5fc2hvd0xlZHMgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IGxpbmVhckFtcGxpdHVkZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGluZWFyQW1wbGl0dWRlO1xuXHR9XG5cdHNldCBsaW5lYXJBbXBsaXR1ZGUoIHZhbHVlICkge1xuXHRcdHRoaXMuX2xpbmVhckFtcGxpdHVkZSA9ICEhIHZhbHVlO1xuXHR9XG5cblx0Z2V0IGxpbmVhckJvb3N0KCkge1xuXHRcdHJldHVybiB0aGlzLl9saW5lYXJCb29zdDtcblx0fVxuXHRzZXQgbGluZWFyQm9vc3QoIHZhbHVlICkge1xuXHRcdHRoaXMuX2xpbmVhckJvb3N0ID0gdmFsdWUgPj0gMSA/ICt2YWx1ZSA6IDE7XG5cdH1cblxuXHRnZXQgbGluZVdpZHRoKCkge1xuXHRcdHJldHVybiB0aGlzLl9saW5lV2lkdGg7XG5cdH1cblx0c2V0IGxpbmVXaWR0aCggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbGluZVdpZHRoID0gK3ZhbHVlIHx8IDA7XG5cdH1cblxuXHRnZXQgbG9SZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvUmVzO1xuXHR9XG5cdHNldCBsb1JlcyggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbG9SZXMgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9zZXRDYW52YXMoIFJFQVNPTl9MT1JFUyApO1xuXHR9XG5cblx0Z2V0IGx1bWlCYXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9sdW1pQmFycztcblx0fVxuXHRzZXQgbHVtaUJhcnMoIHZhbHVlICkge1xuXHRcdHRoaXMuX2x1bWlCYXJzID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0Z2V0IG1heERlY2liZWxzKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbmFseXplclswXS5tYXhEZWNpYmVscztcblx0fVxuXHRzZXQgbWF4RGVjaWJlbHMoIHZhbHVlICkge1xuXHRcdGZvciAoIGNvbnN0IGkgb2YgWzAsMV0gKVxuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5tYXhEZWNpYmVscyA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IG1heEZQUygpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4RlBTO1xuXHR9XG5cdHNldCBtYXhGUFMoIHZhbHVlICkge1xuXHRcdHRoaXMuX21heEZQUyA9IHZhbHVlIDwgMCA/IDAgOiArdmFsdWUgfHwgMDtcblx0fVxuXG5cdGdldCBtYXhGcmVxKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXhGcmVxO1xuXHR9XG5cdHNldCBtYXhGcmVxKCB2YWx1ZSApIHtcblx0XHRpZiAoIHZhbHVlIDwgMSApXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggRVJSX0ZSRVFVRU5DWV9UT09fTE9XICk7XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXhGcmVxID0gTWF0aC5taW4oIHZhbHVlLCB0aGlzLmF1ZGlvQ3R4LnNhbXBsZVJhdGUgLyAyICk7XG5cdFx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBtaW5EZWNpYmVscygpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5hbHl6ZXJbMF0ubWluRGVjaWJlbHM7XG5cdH1cblx0c2V0IG1pbkRlY2liZWxzKCB2YWx1ZSApIHtcblx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdHRoaXMuX2FuYWx5emVyWyBpIF0ubWluRGVjaWJlbHMgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBtaW5GcmVxKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5GcmVxO1xuXHR9XG5cdHNldCBtaW5GcmVxKCB2YWx1ZSApIHtcblx0XHRpZiAoIHZhbHVlIDwgMSApXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggRVJSX0ZSRVFVRU5DWV9UT09fTE9XICk7XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLl9taW5GcmVxID0gK3ZhbHVlO1xuXHRcdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgbWlycm9yKCkge1xuXHRcdHJldHVybiB0aGlzLl9taXJyb3I7XG5cdH1cblx0c2V0IG1pcnJvciggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbWlycm9yID0gTWF0aC5zaWduKCB2YWx1ZSApIHwgMDsgLy8gZW5zdXJlIG9ubHkgLTEsIDAgb3IgMVxuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0fVxuXG5cdGdldCBtb2RlKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb2RlO1xuXHR9XG5cdHNldCBtb2RlKCB2YWx1ZSApIHtcblx0XHRjb25zdCBtb2RlID0gdmFsdWUgfCAwO1xuXHRcdGlmICggbW9kZSA+PSAwICYmIG1vZGUgPD0gMTAgJiYgbW9kZSAhPSA5ICkge1xuXHRcdFx0dGhpcy5fbW9kZSA9IG1vZGU7XG5cdFx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHRcdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0dGhyb3cgbmV3IEF1ZGlvTW90aW9uRXJyb3IoIEVSUl9JTlZBTElEX01PREUsIHZhbHVlICk7XG5cdH1cblxuXHRnZXQgbm90ZUxhYmVscygpIHtcblx0XHRyZXR1cm4gdGhpcy5fbm90ZUxhYmVscztcblx0fVxuXHRzZXQgbm90ZUxhYmVscyggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbm90ZUxhYmVscyA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX2NyZWF0ZVNjYWxlcygpO1xuXHR9XG5cblx0Z2V0IG91dGxpbmVCYXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9vdXRsaW5lQmFycztcblx0fVxuXHRzZXQgb3V0bGluZUJhcnMoIHZhbHVlICkge1xuXHRcdHRoaXMuX291dGxpbmVCYXJzID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0fVxuXG5cdGdldCBwZWFrRmFkZVRpbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BlYWtGYWRlVGltZTtcblx0fVxuXHRzZXQgcGVha0ZhZGVUaW1lKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9wZWFrRmFkZVRpbWUgPSB2YWx1ZSA+PSAwID8gK3ZhbHVlIDogdGhpcy5fcGVha0ZhZGVUaW1lIHx8IERFRkFVTFRfU0VUVElOR1MucGVha0ZhZGVUaW1lO1xuXHR9XG5cblx0Z2V0IHBlYWtIb2xkVGltZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGVha0hvbGRUaW1lO1xuXHR9XG5cdHNldCBwZWFrSG9sZFRpbWUoIHZhbHVlICkge1xuXHRcdHRoaXMuX3BlYWtIb2xkVGltZSA9ICt2YWx1ZSB8fCAwO1xuXHR9XG5cblx0Z2V0IHBlYWtMaW5lKCkge1xuXHRcdHJldHVybiB0aGlzLl9wZWFrTGluZTtcblx0fVxuXHRzZXQgcGVha0xpbmUoIHZhbHVlICkge1xuXHRcdHRoaXMuX3BlYWtMaW5lID0gISEgdmFsdWU7XG5cdH1cblxuXHRnZXQgcmFkaWFsKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpYWw7XG5cdH1cblx0c2V0IHJhZGlhbCggdmFsdWUgKSB7XG5cdFx0dGhpcy5fcmFkaWFsID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0Z2V0IHJhZGlhbEludmVydCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaWFsSW52ZXJ0O1xuXHR9XG5cdHNldCByYWRpYWxJbnZlcnQoIHZhbHVlICkge1xuXHRcdHRoaXMuX3JhZGlhbEludmVydCA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0fVxuXG5cdGdldCByYWRpdXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fVxuXHRzZXQgcmFkaXVzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9yYWRpdXMgPSArdmFsdWUgfHwgMDtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdH1cblxuXHRnZXQgcmVmbGV4UmF0aW8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlZmxleFJhdGlvO1xuXHR9XG5cdHNldCByZWZsZXhSYXRpbyggdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSArdmFsdWUgfHwgMDtcblx0XHRpZiAoIHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfUkVGTEVYX09VVF9PRl9SQU5HRSApO1xuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVmbGV4UmF0aW8gPSB2YWx1ZTtcblx0XHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHRcdH1cblx0fVxuXG5cdGdldCByb3VuZEJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JvdW5kQmFycztcblx0fVxuXHRzZXQgcm91bmRCYXJzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9yb3VuZEJhcnMgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IHNtb290aGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5hbHl6ZXJbMF0uc21vb3RoaW5nVGltZUNvbnN0YW50O1xuXHR9XG5cdHNldCBzbW9vdGhpbmcoIHZhbHVlICkge1xuXHRcdGZvciAoIGNvbnN0IGkgb2YgWzAsMV0gKVxuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBzcGluU3BlZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NwaW5TcGVlZDtcblx0fVxuXHRzZXQgc3BpblNwZWVkKCB2YWx1ZSApIHtcblx0XHR2YWx1ZSA9ICt2YWx1ZSB8fCAwO1xuXHRcdGlmICggdGhpcy5fc3BpblNwZWVkID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT0gMCApXG5cdFx0XHR0aGlzLl9zcGluQW5nbGUgPSAtSEFMRl9QSTsgLy8gaW5pdGlhbGl6ZSBvciByZXNldCB0aGUgcm90YXRpb24gYW5nbGVcblx0XHR0aGlzLl9zcGluU3BlZWQgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBzcGxpdEdyYWRpZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9zcGxpdEdyYWRpZW50O1xuXHR9XG5cdHNldCBzcGxpdEdyYWRpZW50KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zcGxpdEdyYWRpZW50ID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0fVxuXG5cdGdldCBzdGVyZW8oKSB7XG5cdFx0ZGVwcmVjYXRlKCAnc3RlcmVvJywgJ2NoYW5uZWxMYXlvdXQnICk7XG5cdFx0cmV0dXJuIHRoaXMuX2NoTGF5b3V0ICE9IENIQU5ORUxfU0lOR0xFO1xuXHR9XG5cdHNldCBzdGVyZW8oIHZhbHVlICkge1xuXHRcdGRlcHJlY2F0ZSggJ3N0ZXJlbycsICdjaGFubmVsTGF5b3V0JyApO1xuXHRcdHRoaXMuY2hhbm5lbExheW91dCA9IHZhbHVlID8gQ0hBTk5FTF9WRVJUSUNBTCA6IENIQU5ORUxfU0lOR0xFO1xuXHR9XG5cblx0Z2V0IHRydWVMZWRzKCkge1xuXHRcdHJldHVybiB0aGlzLl90cnVlTGVkcztcblx0fVxuXHRzZXQgdHJ1ZUxlZHMoIHZhbHVlICkge1xuXHRcdHRoaXMuX3RydWVMZWRzID0gISEgdmFsdWU7XG5cdH1cblxuXHRnZXQgdm9sdW1lKCkge1xuXHRcdHJldHVybiB0aGlzLl9vdXRwdXQuZ2Fpbi52YWx1ZTtcblx0fVxuXHRzZXQgdm9sdW1lKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9vdXRwdXQuZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IHdlaWdodGluZ0ZpbHRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2VpZ2h0aW5nRmlsdGVyO1xuXHR9XG5cdHNldCB3ZWlnaHRpbmdGaWx0ZXIoIHZhbHVlICkge1xuXHRcdHRoaXMuX3dlaWdodGluZ0ZpbHRlciA9IHZhbGlkYXRlRnJvbUxpc3QoIHZhbHVlLCBbIEZJTFRFUl9OT05FLCBGSUxURVJfQSwgRklMVEVSX0IsIEZJTFRFUl9DLCBGSUxURVJfRCwgRklMVEVSXzQ2OCBdLCAndG9VcHBlckNhc2UnICk7XG5cdH1cblxuXHRnZXQgd2lkdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHR9XG5cdHNldCB3aWR0aCggdyApIHtcblx0XHR0aGlzLl93aWR0aCA9IHc7XG5cdFx0dGhpcy5fc2V0Q2FudmFzKCBSRUFTT05fVVNFUiApO1xuXHR9XG5cblx0Ly8gUmVhZCBvbmx5IHByb3BlcnRpZXNcblxuXHRnZXQgYXVkaW9DdHgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0LmNvbnRleHQ7XG5cdH1cblx0Z2V0IGNhbnZhcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3R4LmNhbnZhcztcblx0fVxuXHRnZXQgY2FudmFzQ3R4KCkge1xuXHRcdHJldHVybiB0aGlzLl9jdHg7XG5cdH1cblx0Z2V0IGNvbm5lY3RlZFNvdXJjZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvdXJjZXM7XG5cdH1cblx0Z2V0IGNvbm5lY3RlZFRvKCkge1xuXHRcdHJldHVybiB0aGlzLl9vdXROb2Rlcztcblx0fVxuXHRnZXQgZnBzKCkge1xuXHRcdHJldHVybiB0aGlzLl9mcHM7XG5cdH1cblx0Z2V0IGZzSGVpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLl9mc0hlaWdodDtcblx0fVxuXHRnZXQgZnNXaWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnNXaWR0aDtcblx0fVxuXHRnZXQgaXNBbHBoYUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZsZy5pc0FscGhhO1xuXHR9XG5cdGdldCBpc0JhbmRzTW9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmxnLmlzQmFuZHM7XG5cdH1cblx0Z2V0IGlzRGVzdHJveWVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZXN0cm95ZWQ7XG5cdH1cblx0Z2V0IGlzRnVsbHNjcmVlbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnNFbCAmJiAoIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50ICkgPT09IHRoaXMuX2ZzRWw7XG5cdH1cblx0Z2V0IGlzTGVkQmFycygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmxnLmlzTGVkcztcblx0fVxuXHRnZXQgaXNMdW1pQmFycygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmxnLmlzTHVtaTtcblx0fVxuXHRnZXQgaXNPY3RhdmVCYW5kcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmxnLmlzT2N0YXZlcztcblx0fVxuXHRnZXQgaXNPbigpIHtcblx0XHRyZXR1cm4gISEgdGhpcy5fcnVuSWQ7XG5cdH1cblx0Z2V0IGlzT3V0bGluZUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZsZy5pc091dGxpbmU7XG5cdH1cblx0Z2V0IHBpeGVsUmF0aW8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG5cdH1cblx0Z2V0IGlzUm91bmRCYXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9mbGcuaXNSb3VuZDtcblx0fVxuXHRzdGF0aWMgZ2V0IHZlcnNpb24oKSB7XG5cdFx0cmV0dXJuIFZFUlNJT047XG5cdH1cblxuXHQvKipcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKlxuXHQgKiBQVUJMSUMgTUVUSE9EU1xuXHQgKlxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKi9cblxuXHQvKipcblx0ICogQ29ubmVjdHMgYW4gSFRNTCBtZWRpYSBlbGVtZW50IG9yIGF1ZGlvIG5vZGUgdG8gdGhlIGFuYWx5emVyXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhbiBpbnN0YW5jZSBvZiBIVE1MTWVkaWFFbGVtZW50IG9yIEF1ZGlvTm9kZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBhIE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSBvYmplY3QgaWYgY3JlYXRlZCBmcm9tIEhUTUwgZWxlbWVudCwgb3IgdGhlIHNhbWUgaW5wdXQgb2JqZWN0IG90aGVyd2lzZVxuXHQgKi9cblx0Y29ubmVjdElucHV0KCBzb3VyY2UgKSB7XG5cdFx0Y29uc3QgaXNIVE1MID0gc291cmNlIGluc3RhbmNlb2YgSFRNTE1lZGlhRWxlbWVudDtcblxuXHRcdGlmICggISAoIGlzSFRNTCB8fCBzb3VyY2UuY29ubmVjdCApIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfSU5WQUxJRF9BVURJT19TT1VSQ0UgKTtcblxuXHRcdC8vIGlmIHNvdXJjZSBpcyBhbiBIVE1MIGVsZW1lbnQsIGNyZWF0ZSBhbiBhdWRpbyBub2RlIGZvciBpdDsgb3RoZXJ3aXNlLCB1c2UgdGhlIHByb3ZpZGVkIGF1ZGlvIG5vZGVcblx0XHRjb25zdCBub2RlID0gaXNIVE1MID8gdGhpcy5hdWRpb0N0eC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoIHNvdXJjZSApIDogc291cmNlO1xuXG5cdFx0aWYgKCAhIHRoaXMuX3NvdXJjZXMuaW5jbHVkZXMoIG5vZGUgKSApIHtcblx0XHRcdG5vZGUuY29ubmVjdCggdGhpcy5faW5wdXQgKTtcblx0XHRcdHRoaXMuX3NvdXJjZXMucHVzaCggbm9kZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbm5lY3RzIHRoZSBhbmFseXplciBvdXRwdXQgdG8gYW5vdGhlciBhdWRpbyBub2RlXG5cdCAqXG5cdCAqIEBwYXJhbSBbe29iamVjdH1dIGFuIEF1ZGlvTm9kZTsgaWYgdW5kZWZpbmVkLCB0aGUgb3V0cHV0IGlzIGNvbm5lY3RlZCB0byB0aGUgYXVkaW8gY29udGV4dCBkZXN0aW5hdGlvbiAoc3BlYWtlcnMpXG5cdCAqL1xuXHRjb25uZWN0T3V0cHV0KCBub2RlID0gdGhpcy5hdWRpb0N0eC5kZXN0aW5hdGlvbiApIHtcblx0XHRpZiAoIHRoaXMuX291dE5vZGVzLmluY2x1ZGVzKCBub2RlICkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fb3V0cHV0LmNvbm5lY3QoIG5vZGUgKTtcblx0XHR0aGlzLl9vdXROb2Rlcy5wdXNoKCBub2RlICk7XG5cblx0XHQvLyB3aGVuIGNvbm5lY3RpbmcgdGhlIGZpcnN0IG5vZGUsIGFsc28gY29ubmVjdCB0aGUgYW5hbHl6ZXIgbm9kZXMgdG8gdGhlIG1lcmdlciAvIG91dHB1dCBub2Rlc1xuXHRcdGlmICggdGhpcy5fb3V0Tm9kZXMubGVuZ3RoID09IDEgKSB7XG5cdFx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5jb25uZWN0KCAoIHRoaXMuX2NoTGF5b3V0ID09IENIQU5ORUxfU0lOR0xFICYmICEgaSA/IHRoaXMuX291dHB1dCA6IHRoaXMuX21lcmdlciApLCAwLCBpICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIGluc3RhbmNlXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdGlmICggISB0aGlzLl9yZWFkeSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHRjb25zdCB7IGF1ZGlvQ3R4LCBjYW52YXMsIF9jb250cm9sbGVyLCBfaW5wdXQsIF9tZXJnZXIsIF9vYnNlcnZlciwgX293bkNhbnZhcywgX293bkNvbnRleHQsIF9zcGxpdHRlciB9ID0gdGhpcztcblxuXHRcdHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG5cdFx0dGhpcy5fcmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcblx0XHRfY29udHJvbGxlci5hYm9ydCgpO1xuXHRcdGlmICggX29ic2VydmVyIClcblx0XHRcdF9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cblx0XHQvLyBjbGVhciBjYWxsYmFja3MgYW5kIGZ1bGxzY3JlZW4gZWxlbWVudFxuXHRcdHRoaXMub25DYW52YXNSZXNpemUgPSBudWxsO1xuXHRcdHRoaXMub25DYW52YXNEcmF3ID0gbnVsbDtcblx0XHR0aGlzLl9mc0VsID0gbnVsbDtcblxuXHRcdC8vIGRpc2Nvbm5lY3QgYXVkaW8gbm9kZXNcblx0XHR0aGlzLmRpc2Nvbm5lY3RJbnB1dCgpO1xuXHRcdHRoaXMuZGlzY29ubmVjdE91dHB1dCgpOyAvLyBhbHNvIGRpc2Nvbm5lY3RzIGFuYWx5emVyIG5vZGVzXG5cdFx0X2lucHV0LmRpc2Nvbm5lY3QoKTtcblx0XHRfc3BsaXR0ZXIuZGlzY29ubmVjdCgpO1xuXHRcdF9tZXJnZXIuZGlzY29ubmVjdCgpO1xuXG5cdFx0Ly8gaWYgYXVkaW8gY29udGV4dCBpcyBvdXIgb3duIChub3QgcHJvdmlkZWQgYnkgdGhlIHVzZXIpLCBjbG9zZSBpdFxuXHRcdGlmICggX293bkNvbnRleHQgKVxuXHRcdFx0YXVkaW9DdHguY2xvc2UoKTtcblxuXHRcdC8vIHJlbW92ZSBjYW52YXMgZnJvbSB0aGUgRE9NIChpZiBub3QgcHJvdmlkZWQgYnkgdGhlIHVzZXIpXG5cdFx0aWYgKCBfb3duQ2FudmFzIClcblx0XHRcdGNhbnZhcy5yZW1vdmUoKTtcblxuXHRcdC8vIHJlc2V0IGZsYWdzXG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNjb25uZWN0cyBhdWRpbyBzb3VyY2VzIGZyb20gdGhlIGFuYWx5emVyXG5cdCAqXG5cdCAqIEBwYXJhbSBbe29iamVjdHxhcnJheX1dIGEgY29ubmVjdGVkIEF1ZGlvTm9kZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2Ygc3VjaCBvYmplY3RzOyBpZiBmYWxzeSwgYWxsIGNvbm5lY3RlZCBub2RlcyBhcmUgZGlzY29ubmVjdGVkXG5cdCAqIEBwYXJhbSBbe2Jvb2xlYW59XSBpZiB0cnVlLCBzdG9wcy9yZWxlYXNlcyBhdWRpbyB0cmFja3MgZnJvbSBkaXNjb25uZWN0ZWQgbWVkaWEgc3RyZWFtcyAoZS5nLiBtaWNyb3Bob25lKVxuXHQgKi9cblx0ZGlzY29ubmVjdElucHV0KCBzb3VyY2VzLCBzdG9wVHJhY2tzICkge1xuXHRcdGlmICggISBzb3VyY2VzIClcblx0XHRcdHNvdXJjZXMgPSBBcnJheS5mcm9tKCB0aGlzLl9zb3VyY2VzICk7XG5cdFx0ZWxzZSBpZiAoICEgQXJyYXkuaXNBcnJheSggc291cmNlcyApIClcblx0XHRcdHNvdXJjZXMgPSBbIHNvdXJjZXMgXTtcblxuXHRcdGZvciAoIGNvbnN0IG5vZGUgb2Ygc291cmNlcyApIHtcblx0XHRcdGNvbnN0IGlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZiggbm9kZSApO1xuXHRcdFx0aWYgKCBzdG9wVHJhY2tzICYmIG5vZGUubWVkaWFTdHJlYW0gKSB7XG5cdFx0XHRcdGZvciAoIGNvbnN0IHRyYWNrIG9mIG5vZGUubWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKSApIHtcblx0XHRcdFx0XHR0cmFjay5zdG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggaWR4ID49IDAgKSB7XG5cdFx0XHRcdG5vZGUuZGlzY29ubmVjdCggdGhpcy5faW5wdXQgKTtcblx0XHRcdFx0dGhpcy5fc291cmNlcy5zcGxpY2UoIGlkeCwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNjb25uZWN0cyB0aGUgYW5hbHl6ZXIgb3V0cHV0IGZyb20gb3RoZXIgYXVkaW8gbm9kZXNcblx0ICpcblx0ICogQHBhcmFtIFt7b2JqZWN0fV0gYSBjb25uZWN0ZWQgQXVkaW9Ob2RlIG9iamVjdDsgaWYgdW5kZWZpbmVkLCBhbGwgY29ubmVjdGVkIG5vZGVzIGFyZSBkaXNjb25uZWN0ZWRcblx0ICovXG5cdGRpc2Nvbm5lY3RPdXRwdXQoIG5vZGUgKSB7XG5cdFx0aWYgKCBub2RlICYmICEgdGhpcy5fb3V0Tm9kZXMuaW5jbHVkZXMoIG5vZGUgKSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9vdXRwdXQuZGlzY29ubmVjdCggbm9kZSApO1xuXHRcdHRoaXMuX291dE5vZGVzID0gbm9kZSA/IHRoaXMuX291dE5vZGVzLmZpbHRlciggZSA9PiBlICE9PSBub2RlICkgOiBbXTtcblxuXHRcdC8vIGlmIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBub2RlcywgYWxzbyBkaXNjb25uZWN0IHRoZSBhbmFseXplciBub2RlcyBzbyB0aGV5IGtlZXAgd29ya2luZyBvbiBDaHJvbWl1bVxuXHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaHZpYW5uYS9hdWRpb01vdGlvbi1hbmFseXplci9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTgwODc2NDg0OFxuXHRcdGlmICggdGhpcy5fb3V0Tm9kZXMubGVuZ3RoID09IDAgKSB7XG5cdFx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5kaXNjb25uZWN0KCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW5hbHl6ZXIgYmFycyBkYXRhXG4gICAgICpcblx0ICogQHJldHVybnMge2FycmF5fVxuXHQgKi9cblx0Z2V0QmFycygpIHtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSggdGhpcy5fYmFycywgKCB7IHBvc1gsIGZyZXEsIGZyZXFMbywgZnJlcUhpLCBob2xkLCBwZWFrLCB2YWx1ZSB9ICkgPT4gKCB7IHBvc1gsIGZyZXEsIGZyZXFMbywgZnJlcUhpLCBob2xkLCBwZWFrLCB2YWx1ZSB9ICkgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlbmVyZ3kgb2YgYSBmcmVxdWVuY3ksIG9yIGF2ZXJhZ2UgZW5lcmd5IG9mIGEgcmFuZ2Ugb2YgZnJlcXVlbmNpZXNcblx0ICpcblx0ICogQHBhcmFtIFt7bnVtYmVyfHN0cmluZ31dIHNpbmdsZSBvciBpbml0aWFsIGZyZXF1ZW5jeSAoSHopLCBvciBwcmVzZXQgbmFtZTsgaWYgdW5kZWZpbmVkLCByZXR1cm5zIHRoZSBvdmVyYWxsIGVuZXJneVxuXHQgKiBAcGFyYW0gW3tudW1iZXJ9XSBlbmRpbmcgZnJlcXVlbmN5IChIeilcblx0ICogQHJldHVybnMge251bWJlcnxudWxsfSBlbmVyZ3kgdmFsdWUgKDAgdG8gMSkgb3IgbnVsbCwgaWYgdGhlIHNwZWNpZmllZCBwcmVzZXQgaXMgdW5rbm93blxuXHQgKi9cblx0Z2V0RW5lcmd5KCBzdGFydEZyZXEsIGVuZEZyZXEgKSB7XG5cdFx0aWYgKCBzdGFydEZyZXEgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRyZXR1cm4gdGhpcy5fZW5lcmd5LnZhbDtcblxuXHRcdC8vIGlmIHN0YXJ0RnJlcSBpcyBhIHN0cmluZywgY2hlY2sgZm9yIHByZXNldHNcblx0XHRpZiAoIHN0YXJ0RnJlcSAhPSArc3RhcnRGcmVxICkge1xuXHRcdFx0aWYgKCBzdGFydEZyZXEgPT0gJ3BlYWsnIClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuZXJneS5wZWFrO1xuXG5cdFx0XHRjb25zdCBwcmVzZXRzID0ge1xuXHRcdFx0XHRiYXNzOiAgICBbIDIwLCAyNTAgXSxcblx0XHRcdFx0bG93TWlkOiAgWyAyNTAsIDUwMCBdLFxuXHRcdFx0XHRtaWQ6ICAgICBbIDUwMCwgMmUzIF0sXG5cdFx0XHRcdGhpZ2hNaWQ6IFsgMmUzLCA0ZTMgXSxcblx0XHRcdFx0dHJlYmxlOiAgWyA0ZTMsIDE2ZTMgXVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgcHJlc2V0c1sgc3RhcnRGcmVxIF0gKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0WyBzdGFydEZyZXEsIGVuZEZyZXEgXSA9IHByZXNldHNbIHN0YXJ0RnJlcSBdO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN0YXJ0QmluID0gdGhpcy5fZnJlcVRvQmluKCBzdGFydEZyZXEgKSxcblx0XHQgICAgICBlbmRCaW4gICA9IGVuZEZyZXEgPyB0aGlzLl9mcmVxVG9CaW4oIGVuZEZyZXEgKSA6IHN0YXJ0QmluLFxuXHRcdCAgICAgIGNobkNvdW50ID0gdGhpcy5fY2hMYXlvdXQgPT0gQ0hBTk5FTF9TSU5HTEUgPyAxIDogMjtcblxuXHRcdGxldCBlbmVyZ3kgPSAwO1xuXHRcdGZvciAoIGxldCBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGNobkNvdW50OyBjaGFubmVsKysgKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0QmluOyBpIDw9IGVuZEJpbjsgaSsrIClcblx0XHRcdFx0ZW5lcmd5ICs9IHRoaXMuX25vcm1hbGl6ZWRCKCB0aGlzLl9mZnREYXRhWyBjaGFubmVsIF1bIGkgXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbmVyZ3kgLyAoIGVuZEJpbiAtIHN0YXJ0QmluICsgMSApIC8gY2huQ291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBjdXJyZW50IGFuYWx5emVyIHNldHRpbmdzIGluIG9iamVjdCBmb3JtYXRcblx0ICpcblx0ICogQHBhcmFtIFt7c3RyaW5nfGFycmF5fV0gYSBwcm9wZXJ0eSBuYW1lIG9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRvIG5vdCBpbmNsdWRlIGluIHRoZSByZXR1cm5lZCBvYmplY3Rcblx0ICogQHJldHVybnMge29iamVjdH0gT3B0aW9ucyBvYmplY3Rcblx0ICovXG5cdGdldE9wdGlvbnMoIGlnbm9yZSApIHtcblx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggaWdub3JlICkgKVxuXHRcdFx0aWdub3JlID0gWyBpZ25vcmUgXTtcblx0XHRsZXQgb3B0aW9ucyA9IHt9O1xuXHRcdGZvciAoIGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoIERFRkFVTFRfU0VUVElOR1MgKSApIHtcblx0XHRcdGlmICggISBpZ25vcmUuaW5jbHVkZXMoIHByb3AgKSApIHtcblx0XHRcdFx0aWYgKCBwcm9wID09ICdncmFkaWVudCcgJiYgdGhpcy5ncmFkaWVudExlZnQgIT0gdGhpcy5ncmFkaWVudFJpZ2h0ICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuZ3JhZGllbnRMZWZ0ID0gdGhpcy5ncmFkaWVudExlZnQ7XG5cdFx0XHRcdFx0b3B0aW9ucy5ncmFkaWVudFJpZ2h0ID0gdGhpcy5ncmFkaWVudFJpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBwcm9wICE9ICdzdGFydCcgKVxuXHRcdFx0XHRcdG9wdGlvbnNbIHByb3AgXSA9IHRoaXNbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgY3VzdG9tIGdyYWRpZW50XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRyZWdpc3RlckdyYWRpZW50KCBuYW1lLCBvcHRpb25zICkge1xuXHRcdGlmICggdHlwZW9mIG5hbWUgIT0gJ3N0cmluZycgfHwgbmFtZS50cmltKCkubGVuZ3RoID09IDAgKVxuXHRcdFx0dGhyb3cgbmV3IEF1ZGlvTW90aW9uRXJyb3IoIEVSUl9HUkFESUVOVF9JTlZBTElEX05BTUUgKTtcblxuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcgKVxuXHRcdFx0dGhyb3cgbmV3IEF1ZGlvTW90aW9uRXJyb3IoIEVSUl9HUkFESUVOVF9OT1RfQU5fT0JKRUNUICk7XG5cblx0XHRjb25zdCB7IGNvbG9yU3RvcHMgfSA9IG9wdGlvbnM7XG5cblx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggY29sb3JTdG9wcyApIHx8ICEgY29sb3JTdG9wcy5sZW5ndGggKVxuXHRcdFx0dGhyb3cgbmV3IEF1ZGlvTW90aW9uRXJyb3IoIEVSUl9HUkFESUVOVF9NSVNTSU5HX0NPTE9SICk7XG5cblx0XHRjb25zdCBjb3VudCAgICAgPSBjb2xvclN0b3BzLmxlbmd0aCxcblx0XHRcdCAgaXNJbnZhbGlkID0gdmFsID0+ICt2YWwgIT0gdmFsIHx8IHZhbCA8IDAgfHwgdmFsID4gMTtcblxuXHRcdC8vIG5vcm1hbGl6ZSBhbGwgY29sb3JTdG9wcyBhcyBvYmplY3RzIHdpdGggYHBvc2AsIGBjb2xvcmAgYW5kIGBsZXZlbGAgcHJvcGVydGllc1xuXHRcdGNvbG9yU3RvcHMuZm9yRWFjaCggKCBjb2xvclN0b3AsIGluZGV4ICkgPT4ge1xuXHRcdFx0Y29uc3QgcG9zID0gaW5kZXggLyBNYXRoLm1heCggMSwgY291bnQgLSAxICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb2xvclN0b3AgIT0gJ29iamVjdCcgKSAvLyBvbmx5IGNvbG9yIHN0cmluZyB3YXMgZGVmaW5lZFxuXHRcdFx0XHRjb2xvclN0b3BzWyBpbmRleCBdID0ge1x0cG9zLCBjb2xvcjogY29sb3JTdG9wIH07XG5cdFx0XHRlbHNlIGlmICggaXNJbnZhbGlkKCBjb2xvclN0b3AucG9zICkgKVxuXHRcdFx0XHRjb2xvclN0b3AucG9zID0gcG9zO1xuXG5cdFx0XHRpZiAoIGlzSW52YWxpZCggY29sb3JTdG9wLmxldmVsICkgKVxuXHRcdFx0XHRjb2xvclN0b3BzWyBpbmRleCBdLmxldmVsID0gMSAtIGluZGV4IC8gY291bnQ7XG5cdFx0fSk7XG5cblx0XHQvLyBtYWtlIHN1cmUgY29sb3JTdG9wcyBpcyBpbiBkZXNjZW5kaW5nIGBsZXZlbGAgb3JkZXIgYW5kIHRoYXQgdGhlIGZpcnN0IG9uZSBoYXMgYGxldmVsID09IDFgXG5cdFx0Ly8gdGhpcyBpcyBjcnVjaWFsIGZvciBwcm9wZXIgb3BlcmF0aW9uIG9mICdiYXItbGV2ZWwnIGNvbG9yTW9kZSFcblx0XHRjb2xvclN0b3BzLnNvcnQoICggYSwgYiApID0+IGEubGV2ZWwgPCBiLmxldmVsID8gMSA6IGEubGV2ZWwgPiBiLmxldmVsID8gLTEgOiAwICk7XG5cdFx0Y29sb3JTdG9wc1swXS5sZXZlbCA9IDE7XG5cblx0XHR0aGlzLl9ncmFkaWVudHNbIG5hbWUgXSA9IHtcblx0XHRcdGJnQ29sb3I6ICAgIG9wdGlvbnMuYmdDb2xvciB8fCBHUkFESUVOVF9ERUZBVUxUX0JHQ09MT1IsXG5cdFx0XHRkaXI6ICAgICAgICBvcHRpb25zLmRpcixcblx0XHRcdGNvbG9yU3RvcHM6IGNvbG9yU3RvcHNcblx0XHR9O1xuXG5cdFx0Ly8gaWYgdGhlIHJlZ2lzdGVyZWQgZ3JhZGllbnQgaXMgb25lIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZ3JhZGllbnRzLCByZWdlbmVyYXRlIHRoZW1cblx0XHRpZiAoIHRoaXMuX3NlbGVjdGVkR3JhZHMuaW5jbHVkZXMoIG5hbWUgKSApXG5cdFx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBkaW1lbnNpb25zIG9mIGFuYWx5emVyJ3MgY2FudmFzXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3IHdpZHRoIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaCBoZWlnaHQgaW4gcGl4ZWxzXG5cdCAqL1xuXHRzZXRDYW52YXNTaXplKCB3LCBoICkge1xuXHRcdHRoaXMuX3dpZHRoID0gdztcblx0XHR0aGlzLl9oZWlnaHQgPSBoO1xuXHRcdHRoaXMuX3NldENhbnZhcyggUkVBU09OX1VTRVIgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgZGVzaXJlZCBmcmVxdWVuY3kgcmFuZ2Vcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiBsb3dlc3QgZnJlcXVlbmN5IHJlcHJlc2VudGVkIGluIHRoZSB4LWF4aXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCBoaWdoZXN0IGZyZXF1ZW5jeSByZXByZXNlbnRlZCBpbiB0aGUgeC1heGlzXG5cdCAqL1xuXHRzZXRGcmVxUmFuZ2UoIG1pbiwgbWF4ICkge1xuXHRcdGlmICggbWluIDwgMSB8fCBtYXggPCAxIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfRlJFUVVFTkNZX1RPT19MT1cgKTtcblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX21pbkZyZXEgPSBNYXRoLm1pbiggbWluLCBtYXggKTtcblx0XHRcdHRoaXMubWF4RnJlcSAgPSBNYXRoLm1heCggbWluLCBtYXggKTsgLy8gdXNlIHRoZSBzZXR0ZXIgZm9yIG1heEZyZXFcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGN1c3RvbSBwYXJhbWV0ZXJzIGZvciBMRUQgZWZmZWN0XG5cdCAqIElmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cyBvciBpZiBhbnkgcHJvcGVydHkgaXMgaW52YWxpZCwgY2xlYXJzIGFueSBwcmV2aW91cyBjdXN0b20gcGFyYW1ldGVyc1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc11cblx0ICovXG5cdHNldExlZFBhcmFtcyggcGFyYW1zICkge1xuXHRcdGxldCBtYXhMZWRzLCBzcGFjZVYsIHNwYWNlSDtcblxuXHRcdC8vIGNvZXJjZSBwYXJhbWV0ZXJzIHRvIE51bWJlcjsgYE5hTmAgcmVzdWx0cyBhcmUgcmVqZWN0ZWQgaW4gdGhlIGNvbmRpdGlvbiBiZWxvd1xuXHRcdGlmICggcGFyYW1zICkge1xuXHRcdFx0bWF4TGVkcyA9IHBhcmFtcy5tYXhMZWRzIHwgMCwgLy8gZW5zdXJlIGludGVnZXJcblx0XHRcdHNwYWNlViAgPSArcGFyYW1zLnNwYWNlVixcblx0XHRcdHNwYWNlSCAgPSArcGFyYW1zLnNwYWNlSDtcblx0XHR9XG5cblx0XHR0aGlzLl9sZWRQYXJhbXMgPSBtYXhMZWRzID4gMCAmJiBzcGFjZVYgPiAwICYmIHNwYWNlSCA+PSAwID8gWyBtYXhMZWRzLCBzcGFjZVYsIHNwYWNlSCBdIDogdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnRoYW5kIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHNldmVyYWwgb3B0aW9ucyBhdCBvbmNlXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRzZXRPcHRpb25zKCBvcHRpb25zICkge1xuXHRcdHRoaXMuX3NldFByb3BzKCBvcHRpb25zICk7XG5cdH1cblxuXHQvKipcblx0ICogQWRqdXN0IHRoZSBhbmFseXplcidzIHNlbnNpdGl2aXR5XG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gbWluaW11bSBkZWNpYmVscyB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4IG1heGltdW0gZGVjaWJlbHMgdmFsdWVcblx0ICovXG5cdHNldFNlbnNpdGl2aXR5KCBtaW4sIG1heCApIHtcblx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdICkge1xuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5taW5EZWNpYmVscyA9IE1hdGgubWluKCBtaW4sIG1heCApO1xuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5tYXhEZWNpYmVscyA9IE1hdGgubWF4KCBtaW4sIG1heCApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydCB0aGUgYW5hbHl6ZXJcblx0ICovXG5cdHN0YXJ0KCkge1xuXHRcdHRoaXMudG9nZ2xlQW5hbHl6ZXIoIHRydWUgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdG9wIHRoZSBhbmFseXplclxuXHQgKi9cblx0c3RvcCgpIHtcblx0XHR0aGlzLnRvZ2dsZUFuYWx5emVyKCBmYWxzZSApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0IC8gc3RvcCBjYW52YXMgYW5pbWF0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSBpZiB1bmRlZmluZWQsIGludmVydHMgdGhlIGN1cnJlbnQgc3RhdGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdGluZyBzdGF0ZSBhZnRlciB0aGUgY2hhbmdlXG5cdCAqL1xuXHR0b2dnbGVBbmFseXplciggZm9yY2UgKSB7XG5cdFx0Y29uc3QgaGFzU3RhcnRlZCA9IHRoaXMuaXNPbjtcblxuXHRcdGlmICggZm9yY2UgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRmb3JjZSA9ICEgaGFzU3RhcnRlZDtcblxuXHRcdC8vIFN0b3AgdGhlIGFuYWx5emVyIGlmIGl0IHdhcyBhbHJlYWR5IHJ1bm5pbmcgYW5kIG11c3QgYmUgZGlzYWJsZWRcblx0XHRpZiAoIGhhc1N0YXJ0ZWQgJiYgISBmb3JjZSApIHtcblx0XHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLl9ydW5JZCApO1xuXHRcdFx0dGhpcy5fcnVuSWQgPSAwO1xuXHRcdH1cblx0XHQvLyBTdGFydCB0aGUgYW5hbHl6ZXIgaWYgaXQgd2FzIHN0b3BwZWQgYW5kIG11c3QgYmUgZW5hYmxlZFxuXHRcdGVsc2UgaWYgKCAhIGhhc1N0YXJ0ZWQgJiYgZm9yY2UgJiYgISB0aGlzLl9kZXN0cm95ZWQgKSB7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSAwO1xuXHRcdFx0dGhpcy5fdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0dGhpcy5fcnVuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHRpbWVzdGFtcCA9PiB0aGlzLl9kcmF3KCB0aW1lc3RhbXAgKSApOyAvLyBhcnJvdyBmdW5jdGlvbiBwcmVzZXJ2ZXMgdGhlIHNjb3BlIG9mICp0aGlzKlxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmlzT247XG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlcyBjYW52YXMgZnVsbC1zY3JlZW4gbW9kZVxuXHQgKi9cblx0dG9nZ2xlRnVsbHNjcmVlbigpIHtcblx0XHRpZiAoIHRoaXMuaXNGdWxsc2NyZWVuICkge1xuXHRcdFx0aWYgKCBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiApXG5cdFx0XHRcdGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG5cdFx0XHRlbHNlIGlmICggZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4gKVxuXHRcdFx0XHRkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IGZzRWwgPSB0aGlzLl9mc0VsO1xuXHRcdFx0aWYgKCAhIGZzRWwgKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAoIGZzRWwucmVxdWVzdEZ1bGxzY3JlZW4gKVxuXHRcdFx0XHRmc0VsLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG5cdFx0XHRlbHNlIGlmICggZnNFbC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiApXG5cdFx0XHRcdGZzRWwud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICpcblx0ICogUFJJVkFURSBNRVRIT0RTXG5cdCAqXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGZyZXF1ZW5jeSAoaW4gSHopIGZvciBhIGdpdmVuIEZGVCBiaW5cblx0ICovXG5cdF9iaW5Ub0ZyZXEoIGJpbiApIHtcblx0XHRyZXR1cm4gYmluICogdGhpcy5hdWRpb0N0eC5zYW1wbGVSYXRlIC8gdGhpcy5mZnRTaXplIHx8IDE7IC8vIHJldHVybnMgMSBmb3IgYmluIDBcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlIGFsbCBpbnRlcm5hbCBkYXRhIHJlcXVpcmVkIGZvciB0aGUgYW5hbHl6ZXIsIGJhc2VkIG9uIGl0cyBjdXJyZW50IHNldHRpbmdzXG5cdCAqL1xuXHRfY2FsY0JhcnMoKSB7XG5cdFx0Y29uc3QgYmFycyA9IHRoaXMuX2JhcnMgPSBbXTsgLy8gaW5pdGlhbGl6ZSBvYmplY3QgcHJvcGVydHlcblxuXHRcdGlmICggISB0aGlzLl9yZWFkeSApIHtcblx0XHRcdHRoaXMuX2ZsZyA9IHsgaXNBbHBoYTogZmFsc2UsIGlzQmFuZHM6IGZhbHNlLCBpc0xlZHM6IGZhbHNlLCBpc0x1bWk6IGZhbHNlLCBpc09jdGF2ZXM6IGZhbHNlLCBpc091dGxpbmU6IGZhbHNlLCBpc1JvdW5kOiBmYWxzZSwgbm9MZWRHYXA6IGZhbHNlIH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBfYW5zaUJhbmRzLCBfYmFyU3BhY2UsIGNhbnZhcywgX2NoTGF5b3V0LCBfbWF4RnJlcSwgX21pbkZyZXEsIF9taXJyb3IsIF9tb2RlLCBfcmFkaWFsLCBfcmFkaWFsSW52ZXJ0LCBfcmVmbGV4UmF0aW8gfSA9IHRoaXMsXG5cdFx0XHQgIGNlbnRlclggICAgICAgICAgPSBjYW52YXMud2lkdGggPj4gMSxcblx0XHRcdCAgY2VudGVyWSAgICAgICAgICA9IGNhbnZhcy5oZWlnaHQgPj4gMSxcblx0XHRcdCAgaXNEdWFsVmVydGljYWwgICA9IF9jaExheW91dCA9PSBDSEFOTkVMX1ZFUlRJQ0FMICYmICEgX3JhZGlhbCxcblx0XHRcdCAgaXNEdWFsSG9yaXpvbnRhbCA9IF9jaExheW91dCA9PSBDSEFOTkVMX0hPUklaT05UQUwsXG5cblx0XHRcdCAgLy8gQ09NUFVURSBGTEFHU1xuXG5cdFx0XHQgIGlzQmFuZHMgICA9IF9tb2RlICUgMTAgIT0gMCwgLy8gdHJ1ZSBmb3IgbW9kZXMgMSB0byA5XG5cdFx0XHQgIGlzT2N0YXZlcyA9IGlzQmFuZHMgJiYgdGhpcy5fZnJlcXVlbmN5U2NhbGUgPT0gU0NBTEVfTE9HLFxuXHRcdFx0ICBpc0xlZHMgICAgPSB0aGlzLl9zaG93TGVkcyAmJiBpc0JhbmRzICYmICEgX3JhZGlhbCxcblx0XHRcdCAgaXNMdW1pICAgID0gdGhpcy5fbHVtaUJhcnMgJiYgaXNCYW5kcyAmJiAhIF9yYWRpYWwsXG5cdFx0XHQgIGlzQWxwaGEgICA9IHRoaXMuX2FscGhhQmFycyAmJiAhIGlzTHVtaSAmJiBfbW9kZSAhPSBNT0RFX0dSQVBILFxuXHRcdFx0ICBpc091dGxpbmUgPSB0aGlzLl9vdXRsaW5lQmFycyAmJiBpc0JhbmRzICYmICEgaXNMdW1pICYmICEgaXNMZWRzLFxuXHRcdFx0ICBpc1JvdW5kICAgPSB0aGlzLl9yb3VuZEJhcnMgJiYgaXNCYW5kcyAmJiAhIGlzTHVtaSAmJiAhIGlzTGVkcyxcblx0XHRcdCAgbm9MZWRHYXAgID0gX2NoTGF5b3V0ICE9IENIQU5ORUxfVkVSVElDQUwgfHwgX3JlZmxleFJhdGlvID4gMCAmJiAhIGlzTHVtaSxcblxuXHRcdFx0ICAvLyBDT01QVVRFIEFVWElMSUFSWSBWQUxVRVNcblxuXHRcdFx0ICAvLyBjaGFubmVsSGVpZ2h0IGlzIHRoZSB0b3RhbCBjYW52YXMgaGVpZ2h0IGRlZGljYXRlZCB0byBlYWNoIGNoYW5uZWwsIGluY2x1ZGluZyB0aGUgcmVmbGV4IGFyZWEsIGlmIGFueSlcblx0XHRcdCAgY2hhbm5lbEhlaWdodCAgPSBjYW52YXMuaGVpZ2h0IC0gKCBpc0R1YWxWZXJ0aWNhbCAmJiAhIGlzTGVkcyA/IC41IDogMCApID4+IGlzRHVhbFZlcnRpY2FsLFxuXHRcdFx0ICAvLyBhbmFseXplckhlaWdodCBpcyB0aGUgZWZmZWN0aXZlIGhlaWdodCB1c2VkIHRvIHJlbmRlciB0aGUgYW5hbHl6ZXIsIGV4Y2x1ZGluZyB0aGUgcmVmbGV4IGFyZWFcblx0XHRcdCAgYW5hbHl6ZXJIZWlnaHQgPSBjaGFubmVsSGVpZ2h0ICogKCBpc0x1bWkgfHwgX3JhZGlhbCA/IDEgOiAxIC0gX3JlZmxleFJhdGlvICkgfCAwLFxuXG5cdFx0XHQgIGFuYWx5emVyV2lkdGggID0gY2FudmFzLndpZHRoIC0gY2VudGVyWCAqICggaXNEdWFsSG9yaXpvbnRhbCB8fCBfbWlycm9yICE9IDAgKSxcblxuXHRcdFx0ICAvLyBjaGFubmVsR2FwIGlzICoqMCoqIGlmIGlzTGVkRGlzcGxheSA9PSB0cnVlIChMRURzIGFscmVhZHkgaGF2ZSBzcGFjaW5nKTsgKioxKiogaWYgY2FudmFzIGhlaWdodCBpcyBvZGQgKHdpbmRvd2VkKTsgKioyKiogaWYgaXQncyBldmVuXG5cdFx0XHQgIC8vIFRPRE86IGltcHJvdmUgdGhpcywgbWFrZSBpdCBjb25maWd1cmFibGU/XG5cdFx0XHQgIGNoYW5uZWxHYXAgICAgID0gaXNEdWFsVmVydGljYWwgPyBjYW52YXMuaGVpZ2h0IC0gY2hhbm5lbEhlaWdodCAqIDIgOiAwLFxuXG5cdFx0XHQgIGluaXRpYWxYICAgICAgID0gY2VudGVyWCAqICggX21pcnJvciA9PSAtMSAmJiAhIGlzRHVhbEhvcml6b250YWwgJiYgISBfcmFkaWFsICk7XG5cblx0XHRsZXQgaW5uZXJSYWRpdXMgPSBNYXRoLm1pbiggY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICkgKiAuMzc1ICogKCBfY2hMYXlvdXQgPT0gQ0hBTk5FTF9WRVJUSUNBTCA/IDEgOiB0aGlzLl9yYWRpdXMgKSB8IDAsXG5cdFx0XHRvdXRlclJhZGl1cyA9IE1hdGgubWluKCBjZW50ZXJYLCBjZW50ZXJZICk7XG5cblx0XHRpZiAoIF9yYWRpYWxJbnZlcnQgJiYgX2NoTGF5b3V0ICE9IENIQU5ORUxfVkVSVElDQUwgKVxuXHRcdFx0WyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgXSA9IFsgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzIF07XG5cblx0XHQvKipcblx0XHQgKlx0Q1JFQVRFIEFOQUxZWkVSIEJBTkRTXG5cdFx0ICpcblx0XHQgKlx0VVNFUzpcblx0XHQgKlx0XHRhbmFseXplcldpZHRoXG5cdFx0ICpcdFx0aW5pdGlhbFhcblx0XHQgKlx0XHRpc0JhbmRzXG5cdFx0ICpcdFx0aXNPY3RhdmVzXG5cdFx0ICpcblx0XHQgKlx0R0VORVJBVEVTOlxuXHRcdCAqXHRcdGJhcnMgKHBvcHVsYXRlcyB0aGlzLl9iYXJzKVxuXHRcdCAqXHRcdGJhcmRXaWR0aFxuXHRcdCAqXHRcdHNjYWxlTWluXG5cdFx0ICpcdFx0dW5pdFdpZHRoXG5cdFx0ICovXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gdG8gYWRkIGEgYmFyIHRvIHRoZSBiYXJzIGFycmF5XG5cdFx0Ly8gYmFyIG9iamVjdCBmb3JtYXQ6XG5cdFx0Ly8ge1xuXHRcdC8vXHQgcG9zWCxcblx0XHQvLyAgIGZyZXEsXG5cdFx0Ly8gICBmcmVxTG8sXG5cdFx0Ly8gICBmcmVxSGksXG5cdFx0Ly8gICBiaW5Mbyxcblx0XHQvLyAgIGJpbkhpLFxuXHRcdC8vICAgcmF0aW9Mbyxcblx0XHQvLyAgIHJhdGlvSGksXG5cdFx0Ly8gICBwZWFrLCAgICAvLyBwZWFrIHZhbHVlXG5cdFx0Ly8gICBob2xkLCAgICAvLyBwZWFrIGhvbGQgZnJhbWVzIChuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgcGVhayBmYWxsaW5nIC8gZmFkaW5nKVxuXHRcdC8vICAgYWxwaGEsICAgLy8gcGVhayBhbHBoYSAodXNlZCBieSBmYWRlUGVha3MpXG5cdFx0Ly8gICB2YWx1ZSAgICAvLyBjdXJyZW50IGJhciB2YWx1ZVxuXHRcdC8vIH1cblx0XHRjb25zdCBiYXJzUHVzaCA9IGFyZ3MgPT4gYmFycy5wdXNoKCB7IC4uLmFyZ3MsIHBlYWs6IFswLDBdLCBob2xkOiBbMF0sIGFscGhhOiBbMF0sIHZhbHVlOiBbMF0gfSApO1xuXG5cdFx0Lypcblx0XHRcdEEgc2ltcGxlIGludGVycG9sYXRpb24gaXMgdXNlZCB0byBvYnRhaW4gYW4gYXBwcm94aW1hdGUgYW1wbGl0dWRlIHZhbHVlIGZvciBhbnkgZ2l2ZW4gZnJlcXVlbmN5LFxuXHRcdFx0ZnJvbSB0aGUgYXZhaWxhYmxlIEZGVCBkYXRhLiBXZSBmaW5kIHRoZSBGRlQgYmluIHdoaWNoIGNsb3NlciBtYXRjaGVzIHRoZSBkZXNpcmVkIGZyZXF1ZW5jeVx0YW5kXG5cdFx0XHRpbnRlcnBvbGF0ZSBpdHMgdmFsdWUgd2l0aCB0aGF0IG9mIHRoZSBuZXh0IGFkamFjZW50IGJpbiwgbGlrZSBzbzpcblxuXHRcdFx0XHR2ID0gdjAgKyAoIHYxIC0gdjAgKSAqICggbG9nMiggZiAvIGYwICkgLyBsb2cyKCBmMSAvIGYwICkgKVxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFxcX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXy9cblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpb1xuXHRcdFx0XHR3aGVyZTpcblxuXHRcdFx0XHRmICAtIGRlc2lyZWQgZnJlcXVlbmN5XG5cdFx0XHRcdHYgIC0gYW1wbGl0dWRlICh2b2x1bWUpIG9mIGRlc2lyZWQgZnJlcXVlbmN5XG5cdFx0XHRcdGYwIC0gZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IHRoZSBsb3dlciBGRlQgYmluXG5cdFx0XHRcdGYxIC0gZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IHRoZSB1cHBlciBGRlQgYmluXG5cdFx0XHRcdHYwIC0gYW1wbGl0dWRlIG9mIGYwXG5cdFx0XHRcdHYxIC0gYW1wbGl0dWRlIG9mIGYxXG5cblx0XHRcdHJhdGlvIGlzIGNhbGN1bGF0ZWQgaW4gYWR2YW5jZSBoZXJlLCB0byByZWR1Y2UgY29tcHV0YXRpb25hbCBjb21wbGV4aXR5IGR1cmluZyByZWFsLXRpbWUgcmVuZGVyaW5nLlxuXHRcdCovXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIEZGVCBiaW4gYW5kIGludGVycG9sYXRpb24gcmF0aW8gZm9yIGEgZ2l2ZW4gZnJlcXVlbmN5XG5cdFx0Y29uc3QgY2FsY1JhdGlvID0gZnJlcSA9PiB7XG5cdFx0XHRjb25zdCBiaW4gICA9IHRoaXMuX2ZyZXFUb0JpbiggZnJlcSwgJ2Zsb29yJyApLCAvLyBmaW5kIGNsb3Nlc3QgRkZUIGJpblxuXHRcdFx0XHQgIGxvd2VyID0gdGhpcy5fYmluVG9GcmVxKCBiaW4gKSxcblx0XHRcdFx0ICB1cHBlciA9IHRoaXMuX2JpblRvRnJlcSggYmluICsgMSApLFxuXHRcdFx0XHQgIHJhdGlvID0gTWF0aC5sb2cyKCBmcmVxIC8gbG93ZXIgKSAvIE1hdGgubG9nMiggdXBwZXIgLyBsb3dlciApO1xuXG5cdFx0XHRyZXR1cm4gWyBiaW4sIHJhdGlvIF07XG5cdFx0fVxuXG5cdFx0bGV0IGJhcldpZHRoLCBzY2FsZU1pbiwgdW5pdFdpZHRoO1xuXG5cdFx0aWYgKCBpc09jdGF2ZXMgKSB7XG5cdFx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gdG8gcm91bmQgYSB2YWx1ZSB0byBhIGdpdmVuIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcblx0XHRcdC8vIGBhdExlYXN0YCBzZXQgdG8gdHJ1ZSBwcmV2ZW50cyByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIGludGVnZXIgc2lnbmlmaWNhbnQgZGlnaXRzXG5cdFx0XHRjb25zdCByb3VuZFNEID0gKCB2YWx1ZSwgZGlnaXRzLCBhdExlYXN0ICkgPT4gK3ZhbHVlLnRvUHJlY2lzaW9uKCBhdExlYXN0ID8gTWF0aC5tYXgoIGRpZ2l0cywgMSArIE1hdGgubG9nMTAoIHZhbHVlICkgfCAwICkgOiBkaWdpdHMgKTtcblxuXHRcdFx0Ly8gaGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIG5lYXJlc3QgcHJlZmVycmVkIG51bWJlciAoUmVuYXJkIHNlcmllcykgZm9yIGEgZ2l2ZW4gdmFsdWVcblx0XHRcdGNvbnN0IG5lYXJlc3RQcmVmZXJyZWQgPSB2YWx1ZSA9PiB7XG5cdFx0XHRcdC8vIFIyMCBzZXJpZXMgaXMgdXNlZCBoZXJlLCBhcyBpdCBwcm92aWRlcyBjbG9zZXIgYXBwcm94aW1hdGlvbnMgZm9yIDEvMiBvY3RhdmUgYmFuZHMgKG5vbi1zdGFuZGFyZClcblx0XHRcdFx0Y29uc3QgcHJlZmVycmVkID0gWyAxLCAxLjEyLCAxLjI1LCAxLjQsIDEuNiwgMS44LCAyLCAyLjI0LCAyLjUsIDIuOCwgMy4xNSwgMy41NSwgNCwgNC41LCA1LCA1LjYsIDYuMywgNy4xLCA4LCA5LCAxMCBdLFxuXHRcdFx0XHRcdCAgcG93ZXIgPSBNYXRoLmxvZzEwKCB2YWx1ZSApIHwgMCxcblx0XHRcdFx0XHQgIG5vcm1hbGl6ZWQgPSB2YWx1ZSAvIDEwICoqIHBvd2VyO1xuXG5cdFx0XHRcdGxldCBpID0gMTtcblx0XHRcdFx0d2hpbGUgKCBpIDwgcHJlZmVycmVkLmxlbmd0aCAmJiBub3JtYWxpemVkID4gcHJlZmVycmVkWyBpIF0gKVxuXHRcdFx0XHRcdGkrKztcblxuXHRcdFx0XHRpZiAoIG5vcm1hbGl6ZWQgLSBwcmVmZXJyZWRbIGkgLSAxIF0gPCBwcmVmZXJyZWRbIGkgXSAtIG5vcm1hbGl6ZWQgKVxuXHRcdFx0XHRcdGktLTtcblxuXHRcdFx0XHRyZXR1cm4gKCBwcmVmZXJyZWRbIGkgXSAqIDEwICoqICggcG93ZXIgKyA1ICkgfCAwICkgLyAxZTU7IC8vIGtlZXAgNSBzaWduaWZpY2FudCBkaWdpdHNcblx0XHRcdH1cblxuXHRcdFx0Ly8gQU5TSSBzdGFuZGFyZCBvY3RhdmUgYmFuZHMgdXNlIHRoZSBiYXNlLTEwIGZyZXF1ZW5jeSByYXRpbywgYXMgcHJlZmVycmVkIGJ5IFtBTlNJIFMxLjExLTIwMDQsIHAuMl1cblx0XHRcdC8vIFRoZSBlcXVhbC10ZW1wZXJlZCBzY2FsZSB1c2VzIHRoZSBiYXNlLTIgcmF0aW9cblx0XHRcdGNvbnN0IGJhbmRzID0gWzAsMjQsMTIsOCw2LDQsMywyLDFdWyBfbW9kZSBdLFxuXHRcdFx0XHQgIGJhbmRXaWR0aCA9IF9hbnNpQmFuZHMgPyAxMCAqKiAoIDMgLyAoIGJhbmRzICogMTAgKSApIDogMiAqKiAoIDEgLyBiYW5kcyApLCAvLyAxMF4oMy8xME4pIG9yIDJeKDEvTilcblx0XHRcdFx0ICBoYWxmQmFuZCAgPSBiYW5kV2lkdGggKiogLjU7XG5cblx0XHRcdGxldCBhbmFseXplckJhcnMgPSBbXSxcblx0XHRcdFx0Y3VyckZyZXEgPSBfYW5zaUJhbmRzID8gNy45NDMyODIzNSAvICggYmFuZHMgJSAyID8gMSA6IGhhbGZCYW5kICkgOiBDXzE7XG5cdFx0XHRcdC8vIEZvciBBTlNJIGJhbmRzIHdpdGggZXZlbiBkZW5vbWluYXRvcnMgKGFsbCBleGNlcHQgMS8xIGFuZCAxLzMpLCB0aGUgcmVmZXJlbmNlIGZyZXF1ZW5jeSAoMSBrSHopXG5cdFx0XHRcdC8vIG11c3QgZmFsbCBvbiB0aGUgZWRnZXMgb2YgYSBwYWlyIG9mIGFkamFjZW50IGJhbmRzLCBpbnN0ZWFkIG9mIG1pZGJhbmQgW0FOU0kgUzEuMTEtMjAwNCwgcC4yXVxuXHRcdFx0XHQvLyBJbiB0aGUgZXF1YWwtdGVtcGVyZWQgc2NhbGUsIGFsbCBtaWRiYW5kIGZyZXF1ZW5jaWVzIHJlcHJlc2VudCBhIG11c2ljYWwgbm90ZSBvciBxdWFydGVyLXRvbmUuXG5cblx0XHRcdGRvIHtcblx0XHRcdFx0bGV0IGZyZXEgPSBjdXJyRnJlcTsgLy8gbWlkYmFuZCBmcmVxdWVuY3lcblxuXHRcdFx0XHRjb25zdCBmcmVxTG8gPSByb3VuZFNEKCBmcmVxIC8gaGFsZkJhbmQsIDQsIHRydWUgKSwgLy8gbG93ZXIgZWRnZSBmcmVxdWVuY3lcblx0XHRcdFx0XHQgIGZyZXFIaSA9IHJvdW5kU0QoIGZyZXEgKiBoYWxmQmFuZCwgNCwgdHJ1ZSApLCAvLyB1cHBlciBlZGdlIGZyZXF1ZW5jeVxuXHRcdFx0XHRcdCAgWyBiaW5MbywgcmF0aW9MbyBdID0gY2FsY1JhdGlvKCBmcmVxTG8gKSxcblx0XHRcdFx0XHQgIFsgYmluSGksIHJhdGlvSGkgXSA9IGNhbGNSYXRpbyggZnJlcUhpICk7XG5cblx0XHRcdFx0Ly8gZm9yIDEvMSwgMS8yIGFuZCAxLzMgQU5TSSBiYW5kcywgdXNlIHRoZSBwcmVmZXJyZWQgbnVtYmVycyB0byBmaW5kIHRoZSBub21pbmFsIG1pZGJhbmQgZnJlcXVlbmN5XG5cdFx0XHRcdC8vIGZvciAxLzQgdG8gMS8yNCwgcm91bmQgdG8gMiBvciAzIHNpZ25pZmljYW50IGRpZ2l0cywgYWNjb3JkaW5nIHRvIHRoZSBNU0QgW0FOU0kgUzEuMTEtMjAwNCwgcC4xMl1cblx0XHRcdFx0aWYgKCBfYW5zaUJhbmRzIClcblx0XHRcdFx0XHRmcmVxID0gYmFuZHMgPCA0ID8gbmVhcmVzdFByZWZlcnJlZCggZnJlcSApIDogcm91bmRTRCggZnJlcSwgZnJlcS50b1N0cmluZygpWzBdIDwgNSA/IDMgOiAyICk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRmcmVxID0gcm91bmRTRCggZnJlcSwgNCwgdHJ1ZSApO1xuXG5cdFx0XHRcdGlmICggZnJlcSA+PSBfbWluRnJlcSApXG5cdFx0XHRcdFx0YmFyc1B1c2goIHsgcG9zWDogMCwgZnJlcSwgZnJlcUxvLCBmcmVxSGksIGJpbkxvLCBiaW5IaSwgcmF0aW9MbywgcmF0aW9IaSB9ICk7XG5cblx0XHRcdFx0Y3VyckZyZXEgKj0gYmFuZFdpZHRoO1xuXHRcdFx0fSB3aGlsZSAoIGN1cnJGcmVxIDw9IF9tYXhGcmVxICk7XG5cblx0XHRcdGJhcldpZHRoID0gYW5hbHl6ZXJXaWR0aCAvIGJhcnMubGVuZ3RoO1xuXG5cdFx0XHRiYXJzLmZvckVhY2goICggYmFyLCBpbmRleCApID0+IGJhci5wb3NYID0gaW5pdGlhbFggKyBpbmRleCAqIGJhcldpZHRoICk7XG5cblx0XHRcdGNvbnN0IGZpcnN0QmFyID0gYmFyc1swXSxcblx0XHRcdFx0ICBsYXN0QmFyICA9IGJhcnNbIGJhcnMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRzY2FsZU1pbiA9IHRoaXMuX2ZyZXFTY2FsaW5nKCBmaXJzdEJhci5mcmVxTG8gKTtcblx0XHRcdHVuaXRXaWR0aCA9IGFuYWx5emVyV2lkdGggLyAoIHRoaXMuX2ZyZXFTY2FsaW5nKCBsYXN0QmFyLmZyZXFIaSApIC0gc2NhbGVNaW4gKTtcblxuXHRcdFx0Ly8gY2xhbXAgZWRnZSBmcmVxdWVuY2llcyB0byBtaW5GcmVxIC8gbWF4RnJlcSwgaWYgbmVjZXNzYXJ5XG5cdFx0XHQvLyB0aGlzIGlzIGRvbmUgYWZ0ZXIgY29tcHV0aW5nIHNjYWxlTWluIGFuZCB1bml0V2lkdGgsIGZvciB0aGUgcHJvcGVyIHBvc2l0aW9uaW5nIG9mIGxhYmVscyBvbiB0aGUgWC1heGlzXG5cdFx0XHRpZiAoIGZpcnN0QmFyLmZyZXFMbyA8IF9taW5GcmVxICkge1xuXHRcdFx0XHRmaXJzdEJhci5mcmVxTG8gPSBfbWluRnJlcTtcblx0XHRcdFx0WyBmaXJzdEJhci5iaW5MbywgZmlyc3RCYXIucmF0aW9MbyBdID0gY2FsY1JhdGlvKCBfbWluRnJlcSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGxhc3RCYXIuZnJlcUhpID4gX21heEZyZXEgKSB7XG5cdFx0XHRcdGxhc3RCYXIuZnJlcUhpID0gX21heEZyZXE7XG5cdFx0XHRcdFsgbGFzdEJhci5iaW5IaSwgbGFzdEJhci5yYXRpb0hpIF0gPSBjYWxjUmF0aW8oIF9tYXhGcmVxICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBpc0JhbmRzICkgeyAvLyBhIGJhbmRzIG1vZGUgaXMgc2VsZWN0ZWQsIGJ1dCBmcmVxdWVuY3kgc2NhbGUgaXMgbm90IGxvZ2FyaXRobWljXG5cblx0XHRcdGNvbnN0IGJhbmRzID0gWzAsMjQsMTIsOCw2LDQsMywyLDFdWyBfbW9kZSBdICogMTA7XG5cblx0XHRcdGNvbnN0IGludkZyZXFTY2FsaW5nID0geCA9PiB7XG5cdFx0XHRcdHN3aXRjaCAoIHRoaXMuX2ZyZXF1ZW5jeVNjYWxlICkge1xuXHRcdFx0XHRcdGNhc2UgU0NBTEVfQkFSSyA6XG5cdFx0XHRcdFx0XHRyZXR1cm4gMTk2MCAvICggMjYuODEgLyAoIHggKyAuNTMgKSAtIDEgKTtcblx0XHRcdFx0XHRjYXNlIFNDQUxFX01FTCA6XG5cdFx0XHRcdFx0XHRyZXR1cm4gNzAwICogKCAyICoqIHggLSAxICk7XG5cdFx0XHRcdFx0Y2FzZSBTQ0FMRV9MSU5FQVIgOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YmFyV2lkdGggPSBhbmFseXplcldpZHRoIC8gYmFuZHM7XG5cblx0XHRcdHNjYWxlTWluID0gdGhpcy5fZnJlcVNjYWxpbmcoIF9taW5GcmVxICk7XG5cdFx0XHR1bml0V2lkdGggPSBhbmFseXplcldpZHRoIC8gKCB0aGlzLl9mcmVxU2NhbGluZyggX21heEZyZXEgKSAtIHNjYWxlTWluICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgcG9zWCA9IDA7IGkgPCBiYW5kczsgaSsrLCBwb3NYICs9IGJhcldpZHRoICkge1xuXHRcdFx0XHRjb25zdCBmcmVxTG8gPSBpbnZGcmVxU2NhbGluZyggc2NhbGVNaW4gKyBwb3NYIC8gdW5pdFdpZHRoICksXG5cdFx0XHRcdFx0ICBmcmVxICAgPSBpbnZGcmVxU2NhbGluZyggc2NhbGVNaW4gKyAoIHBvc1ggKyBiYXJXaWR0aCAvIDIgKSAvIHVuaXRXaWR0aCApLFxuXHRcdFx0XHRcdCAgZnJlcUhpID0gaW52RnJlcVNjYWxpbmcoIHNjYWxlTWluICsgKCBwb3NYICsgYmFyV2lkdGggKSAvIHVuaXRXaWR0aCApLFxuXHRcdFx0XHRcdCAgWyBiaW5MbywgcmF0aW9MbyBdID0gY2FsY1JhdGlvKCBmcmVxTG8gKSxcblx0XHRcdFx0XHQgIFsgYmluSGksIHJhdGlvSGkgXSA9IGNhbGNSYXRpbyggZnJlcUhpICk7XG5cblx0XHRcdFx0YmFyc1B1c2goIHsgcG9zWDogaW5pdGlhbFggKyBwb3NYLCBmcmVxLCBmcmVxTG8sIGZyZXFIaSwgYmluTG8sIGJpbkhpLCByYXRpb0xvLCByYXRpb0hpIH0gKTtcblx0XHRcdH1cblxuXHRcdH1cblx0XHRlbHNlIHtcdC8vIERpc2NyZXRlIGZyZXF1ZW5jaWVzIG1vZGVzXG5cdFx0XHRiYXJXaWR0aCA9IDE7XG5cblx0XHRcdHNjYWxlTWluID0gdGhpcy5fZnJlcVNjYWxpbmcoIF9taW5GcmVxICk7XG5cdFx0XHR1bml0V2lkdGggPSBhbmFseXplcldpZHRoIC8gKCB0aGlzLl9mcmVxU2NhbGluZyggX21heEZyZXEgKSAtIHNjYWxlTWluICk7XG5cblx0XHRcdGNvbnN0IG1pbkluZGV4ID0gdGhpcy5fZnJlcVRvQmluKCBfbWluRnJlcSwgJ2Zsb29yJyApLFxuXHRcdFx0XHQgIG1heEluZGV4ID0gdGhpcy5fZnJlcVRvQmluKCBfbWF4RnJlcSApO1xuXG5cdCBcdFx0bGV0IGxhc3RQb3MgPSAtOTk5O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IG1pbkluZGV4OyBpIDw9IG1heEluZGV4OyBpKysgKSB7XG5cdFx0XHRcdGNvbnN0IGZyZXEgPSB0aGlzLl9iaW5Ub0ZyZXEoIGkgKSwgLy8gZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IHRoaXMgaW5kZXhcblx0XHRcdFx0XHQgIHBvc1ggPSBpbml0aWFsWCArIE1hdGgucm91bmQoIHVuaXRXaWR0aCAqICggdGhpcy5fZnJlcVNjYWxpbmcoIGZyZXEgKSAtIHNjYWxlTWluICkgKTsgLy8gYXZvaWQgZnJhY3Rpb25hcnkgcGl4ZWwgdmFsdWVzXG5cblx0XHRcdFx0Ly8gaWYgaXQncyBvbiBhIGRpZmZlcmVudCBYLWNvb3JkaW5hdGUsIGNyZWF0ZSBhIG5ldyBiYXIgZm9yIHRoaXMgZnJlcXVlbmN5XG5cdFx0XHRcdGlmICggcG9zWCA+IGxhc3RQb3MgKSB7XG5cdFx0XHRcdFx0YmFyc1B1c2goIHsgcG9zWCwgZnJlcSwgZnJlcUxvOiBmcmVxLCBmcmVxSGk6IGZyZXEsIGJpbkxvOiBpLCBiaW5IaTogaSwgcmF0aW9MbzogMCwgcmF0aW9IaTogMCB9ICk7XG5cdFx0XHRcdFx0bGFzdFBvcyA9IHBvc1g7XG5cdFx0XHRcdH0gLy8gb3RoZXJ3aXNlLCBhZGQgdGhpcyBmcmVxdWVuY3kgdG8gdGhlIGxhc3QgYmFyJ3MgcmFuZ2Vcblx0XHRcdFx0ZWxzZSBpZiAoIGJhcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGNvbnN0IGxhc3RCYXIgPSBiYXJzWyBiYXJzLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0XHRsYXN0QmFyLmJpbkhpID0gaTtcblx0XHRcdFx0XHRsYXN0QmFyLmZyZXFIaSA9IGZyZXE7XG5cdFx0XHRcdFx0bGFzdEJhci5mcmVxID0gKCBsYXN0QmFyLmZyZXFMbyAqIGZyZXEgKSAqKiAuNTsgLy8gY29tcHV0ZSBjZW50ZXIgZnJlcXVlbmN5IChnZW9tZXRyaWMgbWVhbilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqICBDT01QVVRFIEFUVFJJQlVURVMgRk9SIFRIRSBMRUQgQkFSU1xuXHRcdCAqXG5cdFx0ICpcdFVTRVM6XG5cdFx0ICpcdFx0YW5hbHl6ZXJIZWlnaHRcblx0XHQgKlx0XHRiYXJXaWR0aFxuXHRcdCAqXHRcdG5vTGVkR2FwXG5cdFx0ICpcblx0XHQgKlx0R0VORVJBVEVTOlxuXHRcdCAqIFx0XHRzcGFjZUhcblx0XHQgKiBcdFx0c3BhY2VWXG5cdFx0ICpcdFx0dGhpcy5fbGVkc1xuXHRcdCAqL1xuXG5cdFx0bGV0IHNwYWNlSCA9IDAsXG5cdFx0XHRzcGFjZVYgPSAwO1xuXG5cdFx0aWYgKCBpc0xlZHMgKSB7XG5cdFx0XHQvLyBhZGp1c3RtZW50IGZvciBoaWdoIHBpeGVsLXJhdGlvIHZhbHVlcyBvbiBsb3ctcmVzb2x1dGlvbiBzY3JlZW5zIChBbmRyb2lkIFRWKVxuXHRcdFx0Y29uc3QgZFBSID0gdGhpcy5fcGl4ZWxSYXRpbyAvICggd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxICYmIHdpbmRvdy5zY3JlZW4uaGVpZ2h0IDw9IDU0MCA/IDIgOiAxICk7XG5cblx0XHRcdGNvbnN0IHBhcmFtcyA9IFsgW10sXG5cdFx0XHRcdFsgMTI4LCAgMywgLjQ1ICBdLCAvLyBtb2RlIDFcblx0XHRcdFx0WyAxMjgsICA0LCAuMjI1IF0sIC8vIG1vZGUgMlxuXHRcdFx0XHRbICA5NiwgIDYsIC4yMjUgXSwgLy8gbW9kZSAzXG5cdFx0XHRcdFsgIDgwLCAgNiwgLjIyNSBdLCAvLyBtb2RlIDRcblx0XHRcdFx0WyAgODAsICA2LCAuMTI1IF0sIC8vIG1vZGUgNVxuXHRcdFx0XHRbICA2NCwgIDYsIC4xMjUgXSwgLy8gbW9kZSA2XG5cdFx0XHRcdFsgIDQ4LCAgOCwgLjEyNSBdLCAvLyBtb2RlIDdcblx0XHRcdFx0WyAgMjQsIDE2LCAuMTI1IF0sIC8vIG1vZGUgOFxuXHRcdFx0XTtcblxuXHRcdFx0Ly8gdXNlIGN1c3RvbSBMRUQgcGFyYW1ldGVycyBpZiBzZXQsIG9yIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgZm9yIHRoZSBjdXJyZW50IG1vZGVcblx0XHRcdGNvbnN0IGN1c3RvbVBhcmFtcyA9IHRoaXMuX2xlZFBhcmFtcyxcblx0XHRcdFx0ICBbIG1heExlZHMsIHNwYWNlVlJhdGlvLCBzcGFjZUhSYXRpbyBdID0gY3VzdG9tUGFyYW1zIHx8IHBhcmFtc1sgX21vZGUgXTtcblxuXHRcdFx0bGV0IGxlZENvdW50LCBtYXhIZWlnaHQgPSBhbmFseXplckhlaWdodDtcblxuXHRcdFx0aWYgKCBjdXN0b21QYXJhbXMgKSB7XG5cdFx0XHRcdGNvbnN0IG1pbkhlaWdodCA9IDIgKiBkUFI7XG5cdFx0XHRcdGxldCBibG9ja0hlaWdodDtcblx0XHRcdFx0bGVkQ291bnQgPSBtYXhMZWRzICsgMTtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGxlZENvdW50LS07XG5cdFx0XHRcdFx0YmxvY2tIZWlnaHQgPSBtYXhIZWlnaHQgLyBsZWRDb3VudCAvICggMSArIHNwYWNlVlJhdGlvICk7XG5cdFx0XHRcdFx0c3BhY2VWID0gYmxvY2tIZWlnaHQgKiBzcGFjZVZSYXRpbztcblx0XHRcdFx0fSB3aGlsZSAoICggYmxvY2tIZWlnaHQgPCBtaW5IZWlnaHQgfHwgc3BhY2VWIDwgbWluSGVpZ2h0ICkgJiYgbGVkQ291bnQgPiAxICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHZlcnRpY2FsIHNwYWNpbmcgLSBhaW0gZm9yIHRoZSByZWZlcmVuY2UgcmF0aW8sIGJ1dCBtYWtlIHN1cmUgaXQncyBhdCBsZWFzdCAycHhcblx0XHRcdFx0Y29uc3QgcmVmUmF0aW8gPSA1NDAgLyBzcGFjZVZSYXRpbztcblx0XHRcdFx0c3BhY2VWID0gTWF0aC5taW4oIHNwYWNlVlJhdGlvICogZFBSLCBNYXRoLm1heCggMiwgbWF4SGVpZ2h0IC8gcmVmUmF0aW8gKyAuMSB8IDAgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgdGhlIGV4dHJhIHNwYWNpbmcgYmVsb3cgdGhlIGxhc3QgbGluZSBvZiBMRURzXG5cdFx0XHRpZiAoIG5vTGVkR2FwIClcblx0XHRcdFx0bWF4SGVpZ2h0ICs9IHNwYWNlVjtcblxuXHRcdFx0Ly8gcmVjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBsZWRzLCBjb25zaWRlcmluZyB0aGUgZWZmZWN0aXZlIHNwYWNlVlxuXHRcdFx0aWYgKCAhIGN1c3RvbVBhcmFtcyApXG5cdFx0XHRcdGxlZENvdW50ID0gTWF0aC5taW4oIG1heExlZHMsIG1heEhlaWdodCAvICggc3BhY2VWICogMiApIHwgMCApO1xuXG5cdFx0XHRzcGFjZUggPSBzcGFjZUhSYXRpbyA+PSAxID8gc3BhY2VIUmF0aW8gOiBiYXJXaWR0aCAqIHNwYWNlSFJhdGlvO1xuXG5cdFx0XHR0aGlzLl9sZWRzID0gW1xuXHRcdFx0XHRsZWRDb3VudCxcblx0XHRcdFx0c3BhY2VILFxuXHRcdFx0XHRzcGFjZVYsXG5cdFx0XHRcdG1heEhlaWdodCAvIGxlZENvdW50IC0gc3BhY2VWIC8vIGxlZEhlaWdodFxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHQvLyBDT01QVVRFIEFERElUSU9OQUwgQkFSIFBPU0lUSU9OSU5HLCBBQ0NPUkRJTkcgVE8gVEhFIENVUlJFTlQgU0VUVElOR1Ncblx0XHQvLyB1c2VzOiBfYmFyU3BhY2UsIGJhcldpZHRoLCBzcGFjZUhcblxuXHRcdGNvbnN0IGJhclNwYWNlUHggPSBNYXRoLm1pbiggYmFyV2lkdGggLSAxLCBfYmFyU3BhY2UgKiAoIF9iYXJTcGFjZSA+IDAgJiYgX2JhclNwYWNlIDwgMSA/IGJhcldpZHRoIDogMSApICk7XG5cblx0XHRpZiAoIGlzQmFuZHMgKVxuXHRcdFx0YmFyV2lkdGggLT0gTWF0aC5tYXgoIGlzTGVkcyA/IHNwYWNlSCA6IDAsIGJhclNwYWNlUHggKTtcblxuXHRcdGJhcnMuZm9yRWFjaCggKCBiYXIsIGluZGV4ICkgPT4ge1xuXHRcdFx0bGV0IHBvc1ggID0gYmFyLnBvc1gsXG5cdFx0XHRcdHdpZHRoID0gYmFyV2lkdGg7XG5cblx0XHRcdC8vIGluIGJhbmRzIG1vZGVzIHdlIG5lZWQgdG8gdXBkYXRlIGJhci5wb3NYIHRvIGFjY291bnQgZm9yIGJhci9sZWQgc3BhY2luZ1xuXG5cdFx0XHRpZiAoIGlzQmFuZHMgKSB7XG5cdFx0XHRcdGlmICggX2JhclNwYWNlID09IDAgJiYgISBpc0xlZHMgKSB7XG5cdFx0XHRcdFx0Ly8gd2hlbiBiYXJTcGFjZSA9PSAwIHVzZSBpbnRlZ2VyIHZhbHVlcyBmb3IgcGVyZmVjdCBnYXBsZXNzIHBvc2l0aW9uaW5nXG5cdFx0XHRcdFx0cG9zWCB8PSAwO1xuXHRcdFx0XHRcdHdpZHRoIHw9IDA7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCA+IDAgJiYgcG9zWCA+IGJhcnNbIGluZGV4IC0gMSBdLnBvc1ggKyBiYXJzWyBpbmRleCAtIDEgXS53aWR0aCApIHtcblx0XHRcdFx0XHRcdHBvc1gtLTtcblx0XHRcdFx0XHRcdHdpZHRoKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwb3NYICs9IE1hdGgubWF4KCAoIGlzTGVkcyA/IHNwYWNlSCA6IDAgKSwgYmFyU3BhY2VQeCApIC8gMjtcblxuXHRcdFx0XHRiYXIucG9zWCA9IHBvc1g7IC8vIHVwZGF0ZVxuXHRcdFx0fVxuXG5cdFx0XHRiYXIuYmFyQ2VudGVyID0gcG9zWCArICggYmFyV2lkdGggPT0gMSA/IDAgOiB3aWR0aCAvIDIgKTtcblx0XHRcdGJhci53aWR0aCA9IHdpZHRoO1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ09NUFVURSBDSEFOTkVMIENPT1JESU5BVEVTICh1c2VzIHNwYWNlVilcblxuXHRcdGNvbnN0IGNoYW5uZWxDb29yZHMgPSBbXTtcblx0XHRmb3IgKCBjb25zdCBjaGFubmVsIG9mIFswLDFdICkge1xuXHRcdFx0Y29uc3QgY2hhbm5lbFRvcCAgICAgPSBfY2hMYXlvdXQgPT0gQ0hBTk5FTF9WRVJUSUNBTCA/ICggY2hhbm5lbEhlaWdodCArIGNoYW5uZWxHYXAgKSAqIGNoYW5uZWwgOiAwLFxuXHRcdFx0XHQgIGNoYW5uZWxCb3R0b20gID0gY2hhbm5lbFRvcCArIGNoYW5uZWxIZWlnaHQsXG5cdFx0XHRcdCAgYW5hbHl6ZXJCb3R0b20gPSBjaGFubmVsVG9wICsgYW5hbHl6ZXJIZWlnaHQgLSAoICEgaXNMZWRzIHx8IG5vTGVkR2FwID8gMCA6IHNwYWNlViApO1xuXG5cdFx0XHRjaGFubmVsQ29vcmRzLnB1c2goIHsgY2hhbm5lbFRvcCwgY2hhbm5lbEJvdHRvbSwgYW5hbHl6ZXJCb3R0b20gfSApO1xuXHRcdH1cblxuXHRcdC8vIFNBVkUgSU5URVJOQUwgUFJPUEVSVElFU1xuXG5cdFx0dGhpcy5fYXV4ID0geyBhbmFseXplckhlaWdodCwgYW5hbHl6ZXJXaWR0aCwgY2VudGVyWCwgY2VudGVyWSwgY2hhbm5lbENvb3JkcywgY2hhbm5lbEhlaWdodCwgY2hhbm5lbEdhcCwgaW5pdGlhbFgsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgc2NhbGVNaW4sIHVuaXRXaWR0aCB9O1xuXHRcdHRoaXMuX2ZsZyA9IHsgaXNBbHBoYSwgaXNCYW5kcywgaXNMZWRzLCBpc0x1bWksIGlzT2N0YXZlcywgaXNPdXRsaW5lLCBpc1JvdW5kLCBub0xlZEdhcCB9O1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdGhlIFgtYXhpcyBhbmQgcmFkaWFsIHNjYWxlc1xuXHRcdHRoaXMuX2NyZWF0ZVNjYWxlcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBYLWF4aXMgYW5kIHJhZGlhbCBzY2FsZXMgaW4gYXV4aWxpYXJ5IGNhbnZhc2VzXG5cdCAqL1xuXHRfY3JlYXRlU2NhbGVzKCkge1xuXHRcdGlmICggISB0aGlzLl9yZWFkeSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHRjb25zdCB7IGFuYWx5emVyV2lkdGgsIGluaXRpYWxYLCBpbm5lclJhZGl1cywgc2NhbGVNaW4sIHVuaXRXaWR0aCB9ID0gdGhpcy5fYXV4LFxuXHRcdFx0ICB7IGNhbnZhcywgX2ZyZXF1ZW5jeVNjYWxlLCBfbWlycm9yLCBfbm90ZUxhYmVscywgX3JhZGlhbCwgX3NjYWxlWCwgX3NjYWxlUiB9ID0gdGhpcyxcblx0XHRcdCAgY2FudmFzWCAgICAgICAgICA9IF9zY2FsZVguY2FudmFzLFxuXHRcdFx0ICBjYW52YXNSICAgICAgICAgID0gX3NjYWxlUi5jYW52YXMsXG5cdFx0XHQgIGZyZXFMYWJlbHMgICAgICAgPSBbXSxcblx0XHRcdCAgaXNEdWFsSG9yaXpvbnRhbCA9IHRoaXMuX2NoTGF5b3V0ID09IENIQU5ORUxfSE9SSVpPTlRBTCxcblx0XHRcdCAgaXNEdWFsVmVydGljYWwgICA9IHRoaXMuX2NoTGF5b3V0ID09IENIQU5ORUxfVkVSVElDQUwsXG5cdFx0XHQgIG1pbkRpbWVuc2lvbiAgICAgPSBNYXRoLm1pbiggY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICksXG5cdFx0XHQgIHNjYWxlICAgICAgICAgICAgPSBbICdDJywsICdEJywsICdFJywgJ0YnLCwgJ0cnLCwgJ0EnLCwgJ0InIF0sIC8vIGZvciBub3RlIGxhYmVscyAobm8gc2hhcnAgbm90ZXMpXG5cdFx0XHQgIHNjYWxlSGVpZ2h0ICAgICAgPSBtaW5EaW1lbnNpb24gLyAzNCB8IDAsIC8vIGNpcmN1bGFyIHNjYWxlIGhlaWdodCAocmFkaWFsIG1vZGUpXG4gIFx0XHRcdCAgZm9udFNpemVYICAgICAgICA9IGNhbnZhc1guaGVpZ2h0ID4+IDEsXG5cdFx0XHQgIGZvbnRTaXplUiAgICAgICAgPSBzY2FsZUhlaWdodCA+PiAxLFxuXHRcdFx0ICBsYWJlbFdpZHRoWCAgICAgID0gZm9udFNpemVYICogKCBfbm90ZUxhYmVscyA/IC43IDogMS41ICksXG5cdFx0XHQgIGxhYmVsV2lkdGhSICAgICAgPSBmb250U2l6ZVIgKiAoIF9ub3RlTGFiZWxzID8gMSA6IDIgKSxcblx0XHQgIFx0ICByb290MTIgICAgICAgICAgID0gMiAqKiAoIDEgLyAxMiApO1xuXG5cdFx0aWYgKCAhIF9ub3RlTGFiZWxzICYmICggdGhpcy5fYW5zaUJhbmRzIHx8IF9mcmVxdWVuY3lTY2FsZSAhPSBTQ0FMRV9MT0cgKSApIHtcblx0XHRcdGZyZXFMYWJlbHMucHVzaCggMTYsIDMxLjUsIDYzLCAxMjUsIDI1MCwgNTAwLCAxZTMsIDJlMywgNGUzICk7XG5cdFx0XHRpZiAoIF9mcmVxdWVuY3lTY2FsZSA9PSBTQ0FMRV9MSU5FQVIgKVxuXHRcdFx0XHRmcmVxTGFiZWxzLnB1c2goIDZlMywgOGUzLCAxMGUzLCAxMmUzLCAxNGUzLCAxNmUzLCAxOGUzLCAyMGUzLCAyMmUzICk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGZyZXFMYWJlbHMucHVzaCggOGUzLCAxNmUzICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bGV0IGZyZXEgPSBDXzE7XG5cdFx0XHRmb3IgKCBsZXQgb2N0YXZlID0gLTE7IG9jdGF2ZSA8IDExOyBvY3RhdmUrKyApIHtcblx0XHRcdFx0Zm9yICggbGV0IG5vdGUgPSAwOyBub3RlIDwgMTI7IG5vdGUrKyApIHtcblx0XHRcdFx0XHRpZiAoIGZyZXEgPj0gdGhpcy5fbWluRnJlcSAmJiBmcmVxIDw9IHRoaXMuX21heEZyZXEgKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwaXRjaCA9IHNjYWxlWyBub3RlIF0sXG5cdFx0XHRcdFx0XHRcdCAgaXNDICAgPSBwaXRjaCA9PSAnQyc7XG5cdFx0XHRcdFx0XHRpZiAoICggcGl0Y2ggJiYgX25vdGVMYWJlbHMgJiYgISBfbWlycm9yICYmICEgaXNEdWFsSG9yaXpvbnRhbCApIHx8IGlzQyApXG5cdFx0XHRcdFx0XHRcdGZyZXFMYWJlbHMucHVzaCggX25vdGVMYWJlbHMgPyBbIGZyZXEsIHBpdGNoICsgKCBpc0MgPyBvY3RhdmUgOiAnJyApIF0gOiBmcmVxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZyZXEgKj0gcm9vdDEyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaW4gcmFkaWFsIGR1YWwtdmVydGljYWwgbGF5b3V0LCB0aGUgc2NhbGUgaXMgcG9zaXRpb25lZCBleGFjdGx5IGJldHdlZW4gYm90aCBjaGFubmVscywgYnkgbWFraW5nIHRoZSBjYW52YXMgYSBiaXQgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIGRpYW1ldGVyXG5cdFx0Y2FudmFzUi53aWR0aCA9IGNhbnZhc1IuaGVpZ2h0ID0gTWF0aC5tYXgoIG1pbkRpbWVuc2lvbiAqIC4xNSwgKCBpbm5lclJhZGl1cyA8PCAxICkgKyAoIGlzRHVhbFZlcnRpY2FsICogc2NhbGVIZWlnaHQgKSApO1xuXG5cdFx0Y29uc3QgY2VudGVyUiA9IGNhbnZhc1Iud2lkdGggPj4gMSxcblx0XHRcdCAgcmFkaWFsWSA9IGNlbnRlclIgLSBzY2FsZUhlaWdodCAqIC43O1x0Ly8gdmVydGljYWwgcG9zaXRpb24gb2YgdGV4dCBsYWJlbHMgaW4gdGhlIGNpcmN1bGFyIHNjYWxlXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25cblx0XHRjb25zdCByYWRpYWxMYWJlbCA9ICggeCwgbGFiZWwgKSA9PiB7XG5cdFx0XHRjb25zdCBhbmdsZSAgPSBUQVUgKiAoIHggLyBjYW52YXMud2lkdGggKSxcblx0XHRcdFx0ICBhZGpBbmcgPSBhbmdsZSAtIEhBTEZfUEksIC8vIHJvdGF0ZSBhbmdsZXMgc28gMCBpcyBhdCB0aGUgdG9wXG5cdFx0XHRcdCAgcG9zWCAgID0gcmFkaWFsWSAqIE1hdGguY29zKCBhZGpBbmcgKSxcblx0XHRcdFx0ICBwb3NZICAgPSByYWRpYWxZICogTWF0aC5zaW4oIGFkakFuZyApO1xuXG5cdFx0XHRfc2NhbGVSLnNhdmUoKTtcblx0XHRcdF9zY2FsZVIudHJhbnNsYXRlKCBjZW50ZXJSICsgcG9zWCwgY2VudGVyUiArIHBvc1kgKTtcblx0XHRcdF9zY2FsZVIucm90YXRlKCBhbmdsZSApO1xuXHRcdFx0X3NjYWxlUi5maWxsVGV4dCggbGFiZWwsIDAsIDAgKTtcblx0XHRcdF9zY2FsZVIucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdC8vIGNsZWFyIHNjYWxlIGNhbnZhc1xuXHRcdGNhbnZhc1gud2lkdGggfD0gMDtcblxuXHRcdF9zY2FsZVguZmlsbFN0eWxlID0gX3NjYWxlUi5zdHJva2VTdHlsZSA9IFNDQUxFWF9CQUNLR1JPVU5EX0NPTE9SO1xuXHRcdF9zY2FsZVguZmlsbFJlY3QoIDAsIDAsIGNhbnZhc1gud2lkdGgsIGNhbnZhc1guaGVpZ2h0ICk7XG5cblx0XHRfc2NhbGVSLmFyYyggY2VudGVyUiwgY2VudGVyUiwgY2VudGVyUiAtIHNjYWxlSGVpZ2h0IC8gMiwgMCwgVEFVICk7XG5cdFx0X3NjYWxlUi5saW5lV2lkdGggPSBzY2FsZUhlaWdodDtcblx0XHRfc2NhbGVSLnN0cm9rZSgpO1xuXG5cdFx0X3NjYWxlWC5maWxsU3R5bGUgPSBfc2NhbGVSLmZpbGxTdHlsZSA9IFNDQUxFWF9MQUJFTF9DT0xPUjtcblx0XHRfc2NhbGVYLmZvbnQgPSBgJHsgZm9udFNpemVYIH1weCAke0ZPTlRfRkFNSUxZfWA7XG5cdFx0X3NjYWxlUi5mb250ID0gYCR7IGZvbnRTaXplUiB9cHggJHtGT05UX0ZBTUlMWX1gO1xuXHRcdF9zY2FsZVgudGV4dEFsaWduID0gX3NjYWxlUi50ZXh0QWxpZ24gPSAnY2VudGVyJztcblxuXHRcdGxldCBwcmV2WCA9IC1sYWJlbFdpZHRoWCAvIDQsXG5cdFx0XHRwcmV2UiA9IC1sYWJlbFdpZHRoUjtcblxuXHRcdGZvciAoIGNvbnN0IGl0ZW0gb2YgZnJlcUxhYmVscyApIHtcblx0XHRcdGNvbnN0IFsgZnJlcSwgbGFiZWwgXSA9IEFycmF5LmlzQXJyYXkoIGl0ZW0gKSA/IGl0ZW0gOiBbIGl0ZW0sIGl0ZW0gPCAxZTMgPyBpdGVtIHwgMCA6IGAkeyAoIGl0ZW0gLyAxMDAgfCAwICkgLyAxMCB9a2AgXSxcblx0XHRcdFx0ICB4ICAgID0gdW5pdFdpZHRoICogKCB0aGlzLl9mcmVxU2NhbGluZyggZnJlcSApIC0gc2NhbGVNaW4gKSxcblx0XHRcdFx0ICB5ICAgID0gY2FudmFzWC5oZWlnaHQgKiAuNzUsXG5cdFx0XHRcdCAgaXNDICA9IGxhYmVsWzBdID09ICdDJyxcblx0ICBcdFx0XHQgIG1heFcgPSBmb250U2l6ZVggKiAoIF9ub3RlTGFiZWxzICYmICEgX21pcnJvciAmJiAhIGlzRHVhbEhvcml6b250YWwgPyAoIGlzQyA/IDEuMiA6IC42ICkgOiAzICk7XG5cblx0ICBcdFx0Ly8gc2V0IGxhYmVsIGNvbG9yIC0gbm8gaGlnaGxpZ2h0IHdoZW4gbWlycm9yIGVmZmVjdCBpcyBhY3RpdmUgKG9ubHkgQ3MgZGlzcGxheWVkKVxuXHRcdFx0X3NjYWxlWC5maWxsU3R5bGUgPSBfc2NhbGVSLmZpbGxTdHlsZSA9IGlzQyAmJiAhIF9taXJyb3IgJiYgISBpc0R1YWxIb3Jpem9udGFsID8gU0NBTEVYX0hJR0hMSUdIVF9DT0xPUiA6IFNDQUxFWF9MQUJFTF9DT0xPUjtcblxuXHRcdFx0Ly8gcHJpb3JpdGl6ZXMgd2hpY2ggbm90ZSBsYWJlbHMgYXJlIGRpc3BsYXllZCwgZHVlIHRvIHRoZSByZXN0cmljdGVkIHNwYWNlIG9uIHNvbWUgcmFuZ2VzL3NjYWxlc1xuXHRcdFx0aWYgKCBfbm90ZUxhYmVscyApIHtcblx0XHRcdFx0Y29uc3QgaXNMb2cgPSBfZnJlcXVlbmN5U2NhbGUgPT0gU0NBTEVfTE9HLFxuXHRcdFx0XHRcdCAgaXNMaW5lYXIgPSBfZnJlcXVlbmN5U2NhbGUgPT0gU0NBTEVfTElORUFSO1xuXG5cdFx0XHRcdGxldCBhbGxvd2VkTGFiZWxzID0gWydDJ107XG5cblx0XHRcdFx0aWYgKCBpc0xvZyB8fCBmcmVxID4gMmUzIHx8ICggISBpc0xpbmVhciAmJiBmcmVxID4gMjUwICkgfHxcblx0XHRcdFx0XHQgKCAoICEgX3JhZGlhbCB8fCBpc0R1YWxWZXJ0aWNhbCApICYmICggISBpc0xpbmVhciAmJiBmcmVxID4gMTI1IHx8IGZyZXEgPiAxZTMgKSApIClcblx0XHRcdFx0XHRhbGxvd2VkTGFiZWxzLnB1c2goJ0cnKTtcblx0XHRcdFx0aWYgKCBpc0xvZyB8fCBmcmVxID4gNGUzIHx8ICggISBpc0xpbmVhciAmJiBmcmVxID4gNTAwICkgfHxcblx0XHRcdFx0XHQgKCAoICEgX3JhZGlhbCB8fCBpc0R1YWxWZXJ0aWNhbCApICYmICggISBpc0xpbmVhciAmJiBmcmVxID4gMjUwIHx8IGZyZXEgPiAyZTMgKSApIClcblx0XHRcdFx0XHRhbGxvd2VkTGFiZWxzLnB1c2goJ0UnKTtcblx0XHRcdFx0aWYgKCBpc0xpbmVhciAmJiBmcmVxID4gNGUzIHx8XG5cdFx0XHRcdFx0ICggKCAhIF9yYWRpYWwgfHwgaXNEdWFsVmVydGljYWwgKSAmJiAoIGlzTG9nIHx8IGZyZXEgPiAyZTMgfHwgKCAhIGlzTGluZWFyICYmIGZyZXEgPiA1MDAgKSApICkgKVxuXHRcdFx0XHRcdGFsbG93ZWRMYWJlbHMucHVzaCgnRCcsJ0YnLCdBJywnQicpO1xuXHRcdFx0XHRpZiAoICEgYWxsb3dlZExhYmVscy5pbmNsdWRlcyggbGFiZWxbMF0gKSApXG5cdFx0XHRcdFx0Y29udGludWU7IC8vIHNraXAgdGhpcyBsYWJlbFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBsaW5lYXIgc2NhbGVcblx0XHRcdGlmICggeCA+PSBwcmV2WCArIGxhYmVsV2lkdGhYIC8gMiAmJiB4IDw9IGFuYWx5emVyV2lkdGggKSB7XG5cdFx0XHRcdF9zY2FsZVguZmlsbFRleHQoIGxhYmVsLCBpc0R1YWxIb3Jpem9udGFsICYmIF9taXJyb3IgPT0gLTEgPyBhbmFseXplcldpZHRoIC0geCA6IGluaXRpYWxYICsgeCwgeSwgbWF4VyApO1xuXHRcdFx0XHRpZiAoIGlzRHVhbEhvcml6b250YWwgfHwgKCBfbWlycm9yICYmICggeCA+IGxhYmVsV2lkdGhYIHx8IF9taXJyb3IgPT0gMSApICkgKVxuXHRcdFx0XHRcdF9zY2FsZVguZmlsbFRleHQoIGxhYmVsLCBpc0R1YWxIb3Jpem9udGFsICYmIF9taXJyb3IgIT0gMSA/IGFuYWx5emVyV2lkdGggKyB4IDogKCBpbml0aWFsWCB8fCBjYW52YXMud2lkdGggKSAtIHgsIHksIG1heFcgKTtcblx0XHRcdFx0cHJldlggPSB4ICsgTWF0aC5taW4oIG1heFcsIF9zY2FsZVgubWVhc3VyZVRleHQoIGxhYmVsICkud2lkdGggKSAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJhZGlhbCBzY2FsZVxuXHRcdFx0aWYgKCB4ID49IHByZXZSICsgbGFiZWxXaWR0aFIgJiYgeCA8IGFuYWx5emVyV2lkdGggLSBsYWJlbFdpZHRoUiApIHsgLy8gYXZvaWQgb3ZlcmxhcHBpbmcgdGhlIGxhc3QgbGFiZWwgb3ZlciB0aGUgZmlyc3Qgb25lXG5cdFx0XHRcdHJhZGlhbExhYmVsKCBpc0R1YWxIb3Jpem9udGFsICYmIF9taXJyb3IgPT0gMSA/IGFuYWx5emVyV2lkdGggLSB4IDogeCwgbGFiZWwgKTtcblx0XHRcdFx0aWYgKCBpc0R1YWxIb3Jpem9udGFsIHx8ICggX21pcnJvciAmJiAoIHggPiBsYWJlbFdpZHRoUiB8fCBfbWlycm9yID09IDEgKSApICkgLy8gYXZvaWQgb3ZlcmxhcHBpbmcgb2YgZmlyc3QgbGFiZWxzIG9uIG1pcnJvciBtb2RlXG5cdFx0XHRcdFx0cmFkaWFsTGFiZWwoIGlzRHVhbEhvcml6b250YWwgJiYgX21pcnJvciAhPSAtMSA/IGFuYWx5emVyV2lkdGggKyB4IDogLXgsIGxhYmVsICk7XG5cdFx0XHRcdHByZXZSID0geDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVkcmF3IHRoZSBjYW52YXNcblx0ICogdGhpcyBpcyBjYWxsZWQgNjAgdGltZXMgcGVyIHNlY29uZCBieSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKVxuXHQgKi9cblx0X2RyYXcoIHRpbWVzdGFtcCApIHtcblx0XHQvLyBzY2hlZHVsZSBuZXh0IGNhbnZhcyB1cGRhdGVcblx0XHR0aGlzLl9ydW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggdGltZXN0YW1wID0+IHRoaXMuX2RyYXcoIHRpbWVzdGFtcCApICk7XG5cblx0XHQvLyBmcmFtZSByYXRlIGNvbnRyb2xcblx0XHRjb25zdCBlbGFwc2VkICAgICAgICA9IHRpbWVzdGFtcCAtIHRoaXMuX3RpbWUsIC8vIHRpbWUgc2luY2UgbGFzdCBGUFMgY29tcHV0YXRpb25cblx0XHRcdCAgZnJhbWVUaW1lICAgICAgPSB0aW1lc3RhbXAgLSB0aGlzLl9sYXN0LCAvLyB0aW1lIHNpbmNlIGxhc3QgcmVuZGVyZWQgZnJhbWVcblx0XHRcdCAgdGFyZ2V0SW50ZXJ2YWwgPSB0aGlzLl9tYXhGUFMgPyA5NzUgLyB0aGlzLl9tYXhGUFMgOiAwOyAvLyBzbWFsbCB0b2xlcmFuY2UgZm9yIGJlc3QgcmVzdWx0c1xuXG5cdFx0aWYgKCBmcmFtZVRpbWUgPCB0YXJnZXRJbnRlcnZhbCApXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9sYXN0ID0gdGltZXN0YW1wIC0gKCB0YXJnZXRJbnRlcnZhbCA/IGZyYW1lVGltZSAlIHRhcmdldEludGVydmFsIDogMCApOyAvLyB0aGFua3MgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NzcyMjIwLzIzNzAzODVcblx0XHR0aGlzLl9mcmFtZXMrKztcblxuXHRcdGlmICggZWxhcHNlZCA+PSAxMDAwICkgeyAvLyB1cGRhdGUgRlBTIGV2ZXJ5IHNlY29uZFxuXHRcdFx0dGhpcy5fZnBzID0gdGhpcy5fZnJhbWVzIC8gZWxhcHNlZCAqIDEwMDA7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSAwO1xuXHRcdFx0dGhpcy5fdGltZSA9IHRpbWVzdGFtcDtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplIGxvY2FsIGNvbnN0YW50c1xuXG5cdFx0Y29uc3QgeyBpc0FscGhhLFxuXHRcdFx0ICAgIGlzQmFuZHMsXG5cdFx0XHQgICAgaXNMZWRzLFxuXHRcdFx0ICAgIGlzTHVtaSxcblx0XHRcdCAgICBpc09jdGF2ZXMsXG5cdFx0XHQgICAgaXNPdXRsaW5lLFxuXHRcdFx0ICAgIGlzUm91bmQsXG5cdFx0XHQgICAgbm9MZWRHYXAgfSAgICAgPSB0aGlzLl9mbGcsXG5cblx0XHRcdCAgeyBhbmFseXplckhlaWdodCxcblx0XHRcdCAgICBjZW50ZXJYLFxuXHRcdFx0ICAgIGNlbnRlclksXG5cdFx0XHQgICAgY2hhbm5lbENvb3Jkcyxcblx0XHRcdCAgICBjaGFubmVsSGVpZ2h0LFxuXHRcdFx0ICAgIGNoYW5uZWxHYXAsXG5cdFx0XHQgICAgaW5pdGlhbFgsXG5cdFx0XHQgICAgaW5uZXJSYWRpdXMsXG5cdFx0XHQgICAgb3V0ZXJSYWRpdXMgfSAgPSB0aGlzLl9hdXgsXG5cblx0XHRcdCAgeyBfYmFycyxcblx0XHRcdCAgICBjYW52YXMsXG5cdFx0XHQgICAgX2NhbnZhc0dyYWRpZW50cyxcblx0XHRcdCAgICBfY2hMYXlvdXQsXG5cdFx0XHQgICAgX2NvbG9yTW9kZSxcblx0XHRcdCAgICBfY3R4LFxuXHRcdFx0ICAgIF9lbmVyZ3ksXG5cdFx0XHQgICAgX2ZhZGVQZWFrcyxcblx0XHRcdCAgICBmaWxsQWxwaGEsXG5cdFx0XHQgICAgX2Zwcyxcblx0XHRcdCAgICBfbGluZWFyQW1wbGl0dWRlLFxuXHRcdFx0ICAgIF9saW5lV2lkdGgsXG5cdFx0XHQgICAgbWF4RGVjaWJlbHMsXG5cdFx0XHQgICAgbWluRGVjaWJlbHMsXG5cdFx0XHQgICAgX21pcnJvcixcblx0XHRcdCAgICBfbW9kZSxcblx0XHRcdCAgICBvdmVybGF5LFxuXHRcdFx0ICAgIF9yYWRpYWwsXG5cdFx0XHQgICAgc2hvd0JnQ29sb3IsXG5cdFx0XHQgICAgc2hvd1BlYWtzLFxuXHRcdFx0ICAgIHVzZUNhbnZhcyxcblx0XHRcdCAgICBfd2VpZ2h0aW5nRmlsdGVyIH0gPSB0aGlzLFxuXG5cdFx0XHQgIGNhbnZhc1ggICAgICAgICAgPSB0aGlzLl9zY2FsZVguY2FudmFzLFxuXHRcdFx0ICBjYW52YXNSICAgICAgICAgID0gdGhpcy5fc2NhbGVSLmNhbnZhcyxcblx0XHRcdCAgZmFkZUZyYW1lcyAgICAgICA9IF9mcHMgKiB0aGlzLl9wZWFrRmFkZVRpbWUgLyAxZTMsXG5cdFx0XHQgIGZwc1NxdWFyZWQgICAgICAgPSBfZnBzICoqIDIsXG5cdFx0XHQgIGdyYXZpdHkgICAgICAgICAgPSB0aGlzLl9ncmF2aXR5ICogMWUzLFxuXHRcdFx0ICBob2xkRnJhbWVzICAgICAgID0gX2ZwcyAqIHRoaXMuX3BlYWtIb2xkVGltZSAvIDFlMyxcblx0XHRcdCAgaXNEdWFsQ29tYmluZWQgICA9IF9jaExheW91dCA9PSBDSEFOTkVMX0NPTUJJTkVELFxuXHRcdFx0ICBpc0R1YWxIb3Jpem9udGFsID0gX2NoTGF5b3V0ID09IENIQU5ORUxfSE9SSVpPTlRBTCxcblx0XHRcdCAgaXNEdWFsVmVydGljYWwgICA9IF9jaExheW91dCA9PSBDSEFOTkVMX1ZFUlRJQ0FMLFxuXHRcdFx0ICBpc1NpbmdsZSAgICAgICAgID0gX2NoTGF5b3V0ID09IENIQU5ORUxfU0lOR0xFLFxuXHRcdFx0ICBpc1RydWVMZWRzICAgICAgID0gaXNMZWRzICYmIHRoaXMuX3RydWVMZWRzICYmIF9jb2xvck1vZGUgPT0gQ09MT1JfR1JBRElFTlQsXG5cdFx0XHQgIGFuYWx5emVyV2lkdGggICAgPSBfcmFkaWFsID8gY2FudmFzLndpZHRoIDogdGhpcy5fYXV4LmFuYWx5emVyV2lkdGgsXG5cdFx0XHQgIGZpbmFsWCAgICAgICAgICAgPSBpbml0aWFsWCArIGFuYWx5emVyV2lkdGgsXG5cdFx0XHQgIHNob3dQZWFrTGluZSAgICAgPSBzaG93UGVha3MgJiYgdGhpcy5fcGVha0xpbmUgJiYgX21vZGUgPT0gTU9ERV9HUkFQSCxcblx0XHRcdCAgbWF4QmFySGVpZ2h0ICAgICA9IF9yYWRpYWwgPyBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzIDogYW5hbHl6ZXJIZWlnaHQsXG5cdFx0XHQgIG5vbWluYWxNYXhIZWlnaHQgPSBtYXhCYXJIZWlnaHQgLyB0aGlzLl9waXhlbFJhdGlvLCAvLyBmb3IgY29uc2lzdGVudCBncmF2aXR5IG9uIGxvLXJlcyBvciBoaS1kcGlcblx0XHRcdCAgZGJSYW5nZSBcdFx0ICAgPSBtYXhEZWNpYmVscyAtIG1pbkRlY2liZWxzLFxuXHRcdFx0ICBbIGxlZENvdW50LCBsZWRTcGFjZUgsIGxlZFNwYWNlViwgbGVkSGVpZ2h0IF0gPSB0aGlzLl9sZWRzIHx8IFtdO1xuXG5cdFx0aWYgKCBfZW5lcmd5LnZhbCA+IDAgJiYgX2ZwcyA+IDAgKVxuXHRcdFx0dGhpcy5fc3BpbkFuZ2xlICs9IHRoaXMuX3NwaW5TcGVlZCAqIFRBVSAvIDYwIC8gX2ZwczsgLy8gc3BpblNwZWVkICogYW5nbGUgaW5jcmVtZW50IHBlciBmcmFtZSBmb3IgMSBSUE1cblxuXHRcdC8qIEhFTFBFUiBGVU5DVElPTlMgKi9cblxuXHRcdC8vIGNyZWF0ZSBSZWZsZXggZWZmZWN0XG5cdFx0Y29uc3QgZG9SZWZsZXggPSBjaGFubmVsID0+IHtcblx0XHRcdGlmICggdGhpcy5fcmVmbGV4UmF0aW8gPiAwICYmICEgaXNMdW1pICYmICEgX3JhZGlhbCApIHtcblx0XHRcdFx0bGV0IHBvc1ksIGhlaWdodDtcblx0XHRcdFx0aWYgKCB0aGlzLnJlZmxleEZpdCB8fCBpc0R1YWxWZXJ0aWNhbCApIHsgLy8gYWx3YXlzIGZpdCByZWZsZXggaW4gdmVydGljYWwgc3RlcmVvIG1vZGVcblx0XHRcdFx0XHRwb3NZICAgPSBpc0R1YWxWZXJ0aWNhbCAmJiBjaGFubmVsID09IDAgPyBjaGFubmVsSGVpZ2h0ICsgY2hhbm5lbEdhcCA6IDA7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gY2hhbm5lbEhlaWdodCAtIGFuYWx5emVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHBvc1kgICA9IGNhbnZhcy5oZWlnaHQgLSBhbmFseXplckhlaWdodCAqIDI7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gYW5hbHl6ZXJIZWlnaHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfY3R4LnNhdmUoKTtcblxuXHRcdFx0XHQvLyBzZXQgYWxwaGEgYW5kIGJyaWdodG5lc3MgZm9yIHRoZSByZWZsZWN0aW9uXG5cdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSB0aGlzLnJlZmxleEFscGhhO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVmbGV4QnJpZ2h0ICE9IDEgKVxuXHRcdFx0XHRcdF9jdHguZmlsdGVyID0gYGJyaWdodG5lc3MoJHt0aGlzLnJlZmxleEJyaWdodH0pYDtcblxuXHRcdFx0XHQvLyBjcmVhdGUgdGhlIHJlZmxlY3Rpb25cblx0XHRcdFx0X2N0eC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIC0xLCAwLCBjYW52YXMuaGVpZ2h0ICk7XG5cdFx0XHRcdF9jdHguZHJhd0ltYWdlKCBjYW52YXMsIDAsIGNoYW5uZWxDb29yZHNbIGNoYW5uZWwgXS5jaGFubmVsVG9wLCBjYW52YXMud2lkdGgsIGFuYWx5emVySGVpZ2h0LCAwLCBwb3NZLCBjYW52YXMud2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRcdF9jdHgucmVzdG9yZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGRyYXcgc2NhbGUgb24gWC1heGlzXG5cdFx0Y29uc3QgZHJhd1NjYWxlWCA9ICgpID0+IHtcblx0XHRcdGlmICggdGhpcy5zaG93U2NhbGVYICkge1xuXHRcdFx0XHRpZiAoIF9yYWRpYWwgKSB7XG5cdFx0XHRcdFx0X2N0eC5zYXZlKCk7XG5cdFx0XHRcdFx0X2N0eC50cmFuc2xhdGUoIGNlbnRlclgsIGNlbnRlclkgKTtcblx0XHRcdFx0XHRpZiAoIHRoaXMuX3NwaW5TcGVlZCApXG5cdFx0XHRcdFx0XHRfY3R4LnJvdGF0ZSggdGhpcy5fc3BpbkFuZ2xlICsgSEFMRl9QSSApO1xuXHRcdFx0XHRcdF9jdHguZHJhd0ltYWdlKCBjYW52YXNSLCAtY2FudmFzUi53aWR0aCA+PiAxLCAtY2FudmFzUi53aWR0aCA+PiAxICk7XG5cdFx0XHRcdFx0X2N0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdF9jdHguZHJhd0ltYWdlKCBjYW52YXNYLCAwLCBjYW52YXMuaGVpZ2h0IC0gY2FudmFzWC5oZWlnaHQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZXR1cm5zIHRoZSBnYWluIChpbiBkQikgZm9yIGEgZ2l2ZW4gZnJlcXVlbmN5LCBjb25zaWRlcmluZyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHdlaWdodGluZyBmaWx0ZXJcblx0XHRjb25zdCB3ZWlnaHRpbmdkQiA9IGZyZXEgPT4ge1xuXHRcdFx0Y29uc3QgZjIgPSBmcmVxICoqIDIsXG5cdFx0XHRcdCAgU1EyMF82ICA9IDQyNC4zNixcblx0XHRcdFx0ICBTUTEwN183ID0gMTE1OTkuMjksXG5cdFx0XHRcdCAgU1ExNThfNSA9IDI1MTIyLjI1LFxuXHRcdFx0XHQgIFNRNzM3XzkgPSA1NDQ0OTYuNDEsXG5cdFx0XHRcdCAgU1ExMjE5NCA9IDE0ODY5MzYzNixcblx0XHRcdFx0ICBsaW5lYXJUb2RCID0gdmFsdWUgPT4gMjAgKiBNYXRoLmxvZzEwKCB2YWx1ZSApO1xuXG5cdFx0XHRzd2l0Y2ggKCBfd2VpZ2h0aW5nRmlsdGVyICkge1xuXHRcdFx0XHRjYXNlIEZJTFRFUl9BIDogLy8gQS13ZWlnaHRpbmcgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQS13ZWlnaHRpbmdcblx0XHRcdFx0XHRjb25zdCByQSA9ICggU1ExMjE5NCAqIGYyICoqIDIgKSAvICggKCBmMiArIFNRMjBfNiApICogTWF0aC5zcXJ0KCAoIGYyICsgU1ExMDdfNyApICogKCBmMiArIFNRNzM3XzkgKSApICogKCBmMiArIFNRMTIxOTQgKSApO1xuXHRcdFx0XHRcdHJldHVybiAyICsgbGluZWFyVG9kQiggckEgKTtcblxuXHRcdFx0XHRjYXNlIEZJTFRFUl9CIDpcblx0XHRcdFx0XHRjb25zdCByQiA9ICggU1ExMjE5NCAqIGYyICogZnJlcSApIC8gKCAoIGYyICsgU1EyMF82ICkgKiBNYXRoLnNxcnQoIGYyICsgU1ExNThfNSApICogKCBmMiArIFNRMTIxOTQgKSApO1xuXHRcdFx0XHRcdHJldHVybiAuMTcgKyBsaW5lYXJUb2RCKCByQiApO1xuXG5cdFx0XHRcdGNhc2UgRklMVEVSX0MgOlxuXHRcdFx0XHRcdGNvbnN0IHJDID0gKCBTUTEyMTk0ICogZjIgKSAvICggKCBmMiArIFNRMjBfNiApICogKCBmMiArIFNRMTIxOTQgKSApO1xuXHRcdFx0XHRcdHJldHVybiAuMDYgKyBsaW5lYXJUb2RCKCByQyApO1xuXG5cdFx0XHRcdGNhc2UgRklMVEVSX0QgOlxuXHRcdFx0XHRcdGNvbnN0IGggPSAoICggMTAzNzkxOC40OCAtIGYyICkgKiogMiArIDEwODA3NjguMTYgKiBmMiApIC8gKCAoIDk4MzczMjggLSBmMiApICoqIDIgKyAxMTcyMzc3NiAqIGYyICksXG5cdFx0XHRcdFx0XHQgIHJEID0gKCBmcmVxIC8gNi44OTY2ODg4NDk2NDc2ZS01ICkgKiBNYXRoLnNxcnQoIGggLyAoICggZjIgKyA3OTkxOS4yOSApICogKCBmMiArIDEzNDU2MDAgKSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmVhclRvZEIoIHJEICk7XG5cblx0XHRcdFx0Y2FzZSBGSUxURVJfNDY4IDogLy8gSVRVLVIgNDY4IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lUVS1SXzQ2OF9ub2lzZV93ZWlnaHRpbmdcblx0XHRcdFx0XHRjb25zdCBoMSA9IC00LjczNzMzODk4MTM3ODM4NGUtMjQgKiBmcmVxICoqIDYgKyAyLjA0MzgyODMzMzYwNjEyNWUtMTUgKiBmcmVxICoqIDQgLSAxLjM2Mzg5NDc5NTQ2MzYzOGUtNyAqIGYyICsgMSxcblx0XHRcdFx0XHRcdCAgaDIgPSAxLjMwNjYxMjI1NzQxMjgyNGUtMTkgKiBmcmVxICoqIDUgLSAyLjExODE1MDg4NzUxODY1NmUtMTEgKiBmcmVxICoqIDMgKyA1LjU1OTQ4ODAyMzQ5ODY0MmUtNCAqIGZyZXEsXG5cdFx0XHRcdFx0XHQgIHJJID0gMS4yNDYzMzI2Mzc1MzIxNDNlLTQgKiBmcmVxIC8gTWF0aC5oeXBvdCggaDEsIGgyICk7XG5cdFx0XHRcdFx0cmV0dXJuIDE4LjIgKyBsaW5lYXJUb2RCKCBySSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDsgLy8gdW5rbm93biBmaWx0ZXJcblx0XHR9XG5cblx0XHQvLyBkcmF3cyAoc3Ryb2tlKSBhIGJhciBmcm9tIHgseTEgdG8geCx5MlxuXHRcdGNvbnN0IHN0cm9rZUJhciA9ICggeCwgeTEsIHkyICkgPT4ge1xuXHRcdFx0X2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdF9jdHgubW92ZVRvKCB4LCB5MSApO1xuXHRcdFx0X2N0eC5saW5lVG8oIHgsIHkyICk7XG5cdFx0XHRfY3R4LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdC8vIGNvbmRpdGlvbmFsbHkgc3Ryb2tlcyBjdXJyZW50IHBhdGggb24gY2FudmFzXG5cdFx0Y29uc3Qgc3Ryb2tlSWYgPSBmbGFnID0+IHtcblx0XHRcdGlmICggZmxhZyAmJiBfbGluZVdpZHRoICkge1xuXHRcdFx0XHRjb25zdCBhbHBoYSA9IF9jdHguZ2xvYmFsQWxwaGE7XG5cdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHRcdFx0XHRfY3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRfY3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydHMgYSB2YWx1ZSBpbiBbMDsxXSByYW5nZSB0byBhIGhlaWdodCBpbiBwaXhlbHMgdGhhdCBmaXRzIGludG8gdGhlIGN1cnJlbnQgTEVEIGVsZW1lbnRzXG5cdFx0Y29uc3QgbGVkUG9zWSA9IHZhbHVlID0+IE1hdGgubWF4KCAwLCAoIHZhbHVlICogbGVkQ291bnQgfCAwICkgKiAoIGxlZEhlaWdodCArIGxlZFNwYWNlViApIC0gbGVkU3BhY2VWICk7XG5cblx0XHQvLyB1cGRhdGUgZW5lcmd5IGluZm9ybWF0aW9uXG5cdFx0Y29uc3QgdXBkYXRlRW5lcmd5ID0gbmV3VmFsID0+IHtcblx0XHRcdF9lbmVyZ3kudmFsID0gbmV3VmFsO1xuXHRcdFx0aWYgKCBfZW5lcmd5LnBlYWsgPiAwICkge1xuXHRcdFx0XHRfZW5lcmd5LmhvbGQtLTtcblx0XHRcdFx0aWYgKCBfZW5lcmd5LmhvbGQgPCAwIClcblx0XHRcdFx0XHRfZW5lcmd5LnBlYWsgKz0gX2VuZXJneS5ob2xkICogZ3Jhdml0eSAvIGZwc1NxdWFyZWQgLyBjYW52YXMuaGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpbztcblx0XHRcdFx0XHQvLyBUTy1ETzogcmVwbGFjZSBgY2FudmFzLmhlaWdodCAqIHRoaXMuX3BpeGVsUmF0aW9gIHdpdGggYG1heE5vbWluYWxIZWlnaHRgIHdoZW4gaW1wbGVtZW50aW5nIGR1YWwtY2hhbm5lbCBlbmVyZ3lcblx0XHRcdH1cblx0XHRcdGlmICggbmV3VmFsID49IF9lbmVyZ3kucGVhayApIHtcblx0XHRcdFx0X2VuZXJneS5wZWFrID0gbmV3VmFsO1xuXHRcdFx0XHRfZW5lcmd5LmhvbGQgPSBob2xkRnJhbWVzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qIE1BSU4gRlVOQ1RJT04gKi9cblxuXHRcdGlmICggb3ZlcmxheSApXG5cdFx0XHRfY3R4LmNsZWFyUmVjdCggMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG5cblx0XHRsZXQgY3VycmVudEVuZXJneSA9IDA7XG5cblx0XHRjb25zdCBuQmFycyAgICAgPSBfYmFycy5sZW5ndGgsXG5cdFx0XHQgIG5DaGFubmVscyA9IGlzU2luZ2xlID8gMSA6IDI7XG5cblx0XHRmb3IgKCBsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBuQ2hhbm5lbHM7IGNoYW5uZWwrKyApIHtcblxuXHRcdFx0Y29uc3QgeyBjaGFubmVsVG9wLCBjaGFubmVsQm90dG9tLCBhbmFseXplckJvdHRvbSB9ID0gY2hhbm5lbENvb3Jkc1sgY2hhbm5lbCBdLFxuXHRcdFx0XHQgIGNoYW5uZWxHcmFkaWVudCAgPSB0aGlzLl9ncmFkaWVudHNbIHRoaXMuX3NlbGVjdGVkR3JhZHNbIGNoYW5uZWwgXSBdLFxuXHRcdFx0XHQgIGNvbG9yU3RvcHMgICAgICAgPSBjaGFubmVsR3JhZGllbnQuY29sb3JTdG9wcyxcblx0XHRcdFx0ICBjb2xvckNvdW50ICAgICAgID0gY29sb3JTdG9wcy5sZW5ndGgsXG5cdFx0XHRcdCAgYmdDb2xvciAgICAgICAgICA9ICggISBzaG93QmdDb2xvciB8fCBpc0xlZHMgJiYgISBvdmVybGF5ICkgPyAnIzAwMCcgOiBjaGFubmVsR3JhZGllbnQuYmdDb2xvcixcblx0XHRcdFx0ICByYWRpYWxEaXJlY3Rpb24gID0gaXNEdWFsVmVydGljYWwgJiYgX3JhZGlhbCAmJiBjaGFubmVsID8gLTEgOiAxLCAvLyAxID0gb3V0d2FyZHMsIC0xID0gaW53YXJkc1xuXHRcdFx0XHQgIGludmVydGVkQ2hhbm5lbCAgPSAoICEgY2hhbm5lbCAmJiBfbWlycm9yID09IC0xICkgfHwgKCBjaGFubmVsICYmIF9taXJyb3IgPT0gMSApLFxuXHRcdFx0XHQgIHJhZGlhbE9mZnNldFggICAgPSAhIGlzRHVhbEhvcml6b250YWwgfHwgKCBjaGFubmVsICYmIF9taXJyb3IgIT0gMSApID8gMCA6IGFuYWx5emVyV2lkdGggPj4gKCBjaGFubmVsIHx8ICEgaW52ZXJ0ZWRDaGFubmVsICksXG5cdFx0XHRcdCAgYW5ndWxhckRpcmVjdGlvbiA9IGlzRHVhbEhvcml6b250YWwgJiYgaW52ZXJ0ZWRDaGFubmVsID8gLTEgOiAxOyAgLy8gMSA9IGNsb2Nrd2lzZSwgLTEgPSBjb3VudGVyY2xvY2t3aXNlXG4vKlxuXHRcdFx0RXhwYW5kZWQgbG9naWMgZm9yIHJhZGlhbE9mZnNldFggYW5kIGFuZ3VsYXJEaXJlY3Rpb246XG5cblx0XHRcdGxldCByYWRpYWxPZmZzZXRYID0gMCxcblx0XHRcdFx0YW5ndWxhckRpcmVjdGlvbiA9IDE7XG5cblx0XHRcdGlmICggaXNEdWFsSG9yaXpvbnRhbCApIHtcblx0XHRcdFx0aWYgKCBjaGFubmVsID09IDAgKSB7IC8vIExFRlQgY2hhbm5lbFxuXHRcdFx0XHRcdGlmICggX21pcnJvciA9PSAtMSApIHtcblx0XHRcdFx0XHRcdHJhZGlhbE9mZnNldFggPSBhbmFseXplcldpZHRoO1xuXHRcdFx0XHRcdFx0YW5ndWxhckRpcmVjdGlvbiA9IC0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyYWRpYWxPZmZzZXRYID0gYW5hbHl6ZXJXaWR0aCA+PiAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyAgICAgICAgICAgICAgICAvLyBSSUdIVCBjaGFubmVsXG5cdFx0XHRcdFx0aWYgKCBfbWlycm9yID09IDEgKSB7XG5cdFx0XHRcdFx0XHRyYWRpYWxPZmZzZXRYID0gYW5hbHl6ZXJXaWR0aCA+PiAxO1xuXHRcdFx0XHRcdFx0YW5ndWxhckRpcmVjdGlvbiA9IC0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuKi9cblx0XHRcdC8vIGRyYXcgc2NhbGUgb24gWS1heGlzICh1c2VzOiBjaGFubmVsLCBjaGFubmVsVG9wKVxuXHRcdFx0Y29uc3QgZHJhd1NjYWxlWSA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2NhbGVXaWR0aCA9IGNhbnZhc1guaGVpZ2h0LFxuXHRcdFx0XHRcdCAgZm9udFNpemUgICA9IHNjYWxlV2lkdGggPj4gMSxcblx0XHRcdFx0XHQgIG1heCAgICAgICAgPSBfbGluZWFyQW1wbGl0dWRlID8gMTAwIDogbWF4RGVjaWJlbHMsXG5cdFx0XHRcdFx0ICBtaW4gICAgICAgID0gX2xpbmVhckFtcGxpdHVkZSA/IDAgOiBtaW5EZWNpYmVscyxcblx0XHRcdFx0XHQgIGluY3IgICAgICAgPSBfbGluZWFyQW1wbGl0dWRlID8gMjAgOiA1LFxuXHRcdFx0XHRcdCAgaW50ZXJ2YWwgICA9IGFuYWx5emVySGVpZ2h0IC8gKCBtYXggLSBtaW4gKSxcblx0XHRcdFx0XHQgIGF0U3RhcnQgICAgPSBfbWlycm9yICE9IC0xICYmICggISBpc0R1YWxIb3Jpem9udGFsIHx8IGNoYW5uZWwgPT0gMCB8fCBfbWlycm9yID09IDEgKSxcblx0XHRcdFx0XHQgIGF0RW5kICAgICAgPSBfbWlycm9yICE9IDEgJiYgKCAhIGlzRHVhbEhvcml6b250YWwgfHwgY2hhbm5lbCAhPSBfbWlycm9yICk7XG5cblx0XHRcdFx0X2N0eC5zYXZlKCk7XG5cdFx0XHRcdF9jdHguZmlsbFN0eWxlID0gU0NBTEVZX0xBQkVMX0NPTE9SO1xuXHRcdFx0XHRfY3R4LmZvbnQgPSBgJHtmb250U2l6ZX1weCAke0ZPTlRfRkFNSUxZfWA7XG5cdFx0XHRcdF9jdHgudGV4dEFsaWduID0gJ3JpZ2h0Jztcblx0XHRcdFx0X2N0eC5saW5lV2lkdGggPSAxO1xuXG5cdFx0XHRcdGZvciAoIGxldCB2YWwgPSBtYXg7IHZhbCA+IG1pbjsgdmFsIC09IGluY3IgKSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9zWSA9IGNoYW5uZWxUb3AgKyAoIG1heCAtIHZhbCApICogaW50ZXJ2YWwsXG5cdFx0XHRcdFx0XHQgIGV2ZW4gPSAoIHZhbCAlIDIgPT0gMCApIHwgMDtcblxuXHRcdFx0XHRcdGlmICggZXZlbiApIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxhYmVsWSA9IHBvc1kgKyBmb250U2l6ZSAqICggcG9zWSA9PSBjaGFubmVsVG9wID8gLjggOiAuMzUgKTtcblx0XHRcdFx0XHRcdGlmICggYXRTdGFydCApXG5cdFx0XHRcdFx0XHRcdF9jdHguZmlsbFRleHQoIHZhbCwgc2NhbGVXaWR0aCAqIC44NSwgbGFiZWxZICk7XG5cdFx0XHRcdFx0XHRpZiAoIGF0RW5kIClcblx0XHRcdFx0XHRcdFx0X2N0eC5maWxsVGV4dCggdmFsLCAoIGlzRHVhbEhvcml6b250YWwgPyBhbmFseXplcldpZHRoIDogY2FudmFzLndpZHRoICkgLSBzY2FsZVdpZHRoICogLjEsIGxhYmVsWSApO1xuXHRcdFx0XHRcdFx0X2N0eC5zdHJva2VTdHlsZSA9IFNDQUxFWV9MQUJFTF9DT0xPUjtcblx0XHRcdFx0XHRcdF9jdHguc2V0TGluZURhc2goWzIsNF0pO1xuXHRcdFx0XHRcdFx0X2N0eC5saW5lRGFzaE9mZnNldCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0X2N0eC5zdHJva2VTdHlsZSA9IFNDQUxFWV9NSURMSU5FX0NPTE9SO1xuXHRcdFx0XHRcdFx0X2N0eC5zZXRMaW5lRGFzaChbMiw4XSk7XG5cdFx0XHRcdFx0XHRfY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdF9jdHgubW92ZVRvKCBpbml0aWFsWCArIHNjYWxlV2lkdGggKiBldmVuICogYXRTdGFydCwgfn5wb3NZICsgLjUgKTsgLy8gZm9yIHNoYXJwIDFweCBsaW5lIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTM4Nzk0MDIvMjM3MDM4NSlcblx0XHRcdFx0XHRfY3R4LmxpbmVUbyggZmluYWxYIC0gc2NhbGVXaWR0aCAqIGV2ZW4gKiBhdEVuZCwgfn5wb3NZICsgLjUgKTtcblx0XHRcdFx0XHRfY3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9jdHgucmVzdG9yZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRlQgYmluIGRhdGEgaW50ZXJwb2xhdGlvbiAodXNlcyBmZnREYXRhKVxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhdGUgPSAoIGJpbiwgcmF0aW8gKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZmZ0RGF0YVsgYmluIF0gKyAoIGJpbiA8IGZmdERhdGEubGVuZ3RoIC0gMSA/ICggZmZ0RGF0YVsgYmluICsgMSBdIC0gZmZ0RGF0YVsgYmluIF0gKSAqIHJhdGlvIDogMCApO1xuXHRcdFx0XHRyZXR1cm4gaXNOYU4oIHZhbHVlICkgPyAtSW5maW5pdHkgOiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY29udmVydHMgYSBnaXZlbiBYLWNvb3JkaW5hdGUgdG8gaXRzIGNvcnJlc3BvbmRpbmcgYW5nbGUgaW4gcmFkaWFsIG1vZGUgKHVzZXMgYW5ndWxhckRpcmVjdGlvbilcblx0XHRcdGNvbnN0IGdldEFuZ2xlID0gKCB4LCBkaXIgPSBhbmd1bGFyRGlyZWN0aW9uICkgPT4gZGlyICogVEFVICogKCAoIHggKyByYWRpYWxPZmZzZXRYICkgLyBjYW52YXMud2lkdGggKSArIHRoaXMuX3NwaW5BbmdsZTtcblxuXHRcdFx0Ly8gY29udmVydHMgcGxhbmFyIFgsWSBjb29yZGluYXRlcyB0byByYWRpYWwgY29vcmRpbmF0ZXMgKHVzZXM6IGdldEFuZ2xlKCksIHJhZGlhbERpcmVjdGlvbilcblx0XHRcdGNvbnN0IHJhZGlhbFhZID0gKCB4LCB5LCBkaXIgKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGhlaWdodCA9IGlubmVyUmFkaXVzICsgeSAqIHJhZGlhbERpcmVjdGlvbixcblx0XHRcdFx0XHQgIGFuZ2xlICA9IGdldEFuZ2xlKCB4LCBkaXIgKTtcblx0XHRcdFx0cmV0dXJuIFsgY2VudGVyWCArIGhlaWdodCAqIE1hdGguY29zKCBhbmdsZSApLCBjZW50ZXJZICsgaGVpZ2h0ICogTWF0aC5zaW4oIGFuZ2xlICkgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZHJhd3MgYSBwb2x5Z29uIG9mIHdpZHRoIGB3YCBhbmQgaGVpZ2h0IGBoYCBhdCAoeCx5KSBpbiByYWRpYWwgbW9kZSAodXNlczogYW5ndWxhckRpcmVjdGlvbiwgcmFkaWFsRGlyZWN0aW9uKVxuXHRcdFx0Y29uc3QgcmFkaWFsUG9seSA9ICggeCwgeSwgdywgaCwgc3Ryb2tlICkgPT4ge1xuXHRcdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRmb3IgKCBjb25zdCBkaXIgb2YgKCBfbWlycm9yICYmICEgaXNEdWFsSG9yaXpvbnRhbCA/IFsxLC0xXSA6IFsgYW5ndWxhckRpcmVjdGlvbiBdICkgKSB7XG5cdFx0XHRcdFx0Y29uc3QgWyBzdGFydEFuZ2xlLCBlbmRBbmdsZSBdID0gaXNSb3VuZCA/IFsgZ2V0QW5nbGUoIHgsIGRpciApLCBnZXRBbmdsZSggeCArIHcsIGRpciApIF0gOiBbXTtcblx0XHRcdFx0XHRfY3R4Lm1vdmVUbyggLi4ucmFkaWFsWFkoIHgsIHksIGRpciApICk7XG5cdFx0XHRcdFx0X2N0eC5saW5lVG8oIC4uLnJhZGlhbFhZKCB4LCB5ICsgaCwgZGlyICkgKTtcblx0XHRcdFx0XHRpZiAoIGlzUm91bmQgKVxuXHRcdFx0XHRcdFx0X2N0eC5hcmMoIGNlbnRlclgsIGNlbnRlclksIGlubmVyUmFkaXVzICsgKCB5ICsgaCApICogcmFkaWFsRGlyZWN0aW9uLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlyICE9IDEgKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIHggKyB3LCB5ICsgaCwgZGlyICkgKTtcblx0XHRcdFx0XHRfY3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIHggKyB3LCB5LCBkaXIgKSApO1xuXHRcdFx0XHRcdGlmICggaXNSb3VuZCAmJiAhIHN0cm9rZSApIC8vIGNsb3NlIHRoZSBib3R0b20gbGluZSBvbmx5IHdoZW4gbm90IGluIG91dGxpbmUgbW9kZVxuXHRcdFx0XHRcdFx0X2N0eC5hcmMoIGNlbnRlclgsIGNlbnRlclksIGlubmVyUmFkaXVzICsgeSAqIHJhZGlhbERpcmVjdGlvbiwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGRpciA9PSAxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3Ryb2tlSWYoIHN0cm9rZSApO1xuXHRcdFx0XHRfY3R4LmZpbGwoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IGZpbGxTdHlsZSBhbmQgc3Ryb2tlU3R5bGUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgY29sb3JNb2RlICh1c2VzOiBjaGFubmVsLCBjb2xvclN0b3BzLCBjb2xvckNvdW50KVxuXHRcdFx0Y29uc3Qgc2V0QmFyQ29sb3IgPSAoIHZhbHVlID0gMCwgYmFySW5kZXggPSAwICkgPT4ge1xuXHRcdFx0XHRsZXQgY29sb3I7XG5cdFx0XHRcdC8vIGZvciBncmFwaCBtb2RlLCBhbHdheXMgdXNlIHRoZSBjaGFubmVsIGdyYWRpZW50IChpZ25vcmUgY29sb3JNb2RlKVxuXHRcdFx0XHRpZiAoICggX2NvbG9yTW9kZSA9PSBDT0xPUl9HUkFESUVOVCAmJiAhIGlzVHJ1ZUxlZHMgKSB8fCBfbW9kZSA9PSBNT0RFX0dSQVBIIClcblx0XHRcdFx0XHRjb2xvciA9IF9jYW52YXNHcmFkaWVudHNbIGNoYW5uZWwgXTtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRJbmRleCA9IF9jb2xvck1vZGUgPT0gQ09MT1JfQkFSX0lOREVYID8gYmFySW5kZXggJSBjb2xvckNvdW50IDogY29sb3JTdG9wcy5maW5kTGFzdEluZGV4KCBpdGVtID0+IGlzTGVkcyA/IGxlZFBvc1koIHZhbHVlICkgPD0gbGVkUG9zWSggaXRlbS5sZXZlbCApIDogdmFsdWUgPD0gaXRlbS5sZXZlbCApO1xuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JTdG9wc1sgc2VsZWN0ZWRJbmRleCBdLmNvbG9yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9jdHguZmlsbFN0eWxlID0gX2N0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDSEFOTkVMIFNUQVJUXG5cblx0XHRcdGlmICggdXNlQ2FudmFzICkge1xuXHRcdFx0XHQvLyBzZXQgdHJhbnNmb3JtIChob3Jpem9udGFsIGZsaXAgYW5kIHRyYW5zbGF0aW9uKSBmb3IgZHVhbC1ob3Jpem9udGFsIGxheW91dFxuXHRcdFx0XHRpZiAoIGlzRHVhbEhvcml6b250YWwgJiYgISBfcmFkaWFsICkge1xuXHRcdFx0XHQgIFx0Y29uc3QgdHJhbnNsYXRlWCA9IGFuYWx5emVyV2lkdGggKiAoIGNoYW5uZWwgKyBpbnZlcnRlZENoYW5uZWwgKSxcblx0XHRcdFx0ICBcdFx0ICBmbGlwWCAgICAgID0gaW52ZXJ0ZWRDaGFubmVsID8gLTEgOiAxO1xuXG5cdFx0XHRcdFx0X2N0eC5zZXRUcmFuc2Zvcm0oIGZsaXBYLCAwLCAwLCAxLCB0cmFuc2xhdGVYLCAwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmaWxsIHRoZSBhbmFseXplciBiYWNrZ3JvdW5kIGlmIG5lZWRlZCAobm90IG92ZXJsYXkgb3Igb3ZlcmxheSArIHNob3dCZ0NvbG9yKVxuXHRcdFx0XHRpZiAoICEgb3ZlcmxheSB8fCBzaG93QmdDb2xvciApIHtcblx0XHRcdFx0XHRpZiAoIG92ZXJsYXkgKVxuXHRcdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IHRoaXMuYmdBbHBoYTtcblxuXHRcdFx0XHRcdF9jdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcblxuXHRcdFx0XHRcdC8vIGV4Y2x1ZGUgdGhlIHJlZmxlY3Rpb24gYXJlYSB3aGVuIG92ZXJsYXkgaXMgdHJ1ZSBhbmQgcmVmbGV4QWxwaGEgPT0gMSAoYXZvaWRzIGFscGhhIG92ZXIgYWxwaGEgZGlmZmVyZW5jZSwgaW4gY2FzZSBiZ0FscGhhIDwgMSlcblx0XHRcdFx0XHRpZiAoIGNoYW5uZWwgPT0gMCB8fCAoICEgX3JhZGlhbCAmJiAhIGlzRHVhbENvbWJpbmVkICkgKVxuXHRcdFx0XHRcdFx0X2N0eC5maWxsUmVjdCggaW5pdGlhbFgsIGNoYW5uZWxUb3AgLSBjaGFubmVsR2FwLCBhbmFseXplcldpZHRoLCAoIG92ZXJsYXkgJiYgdGhpcy5yZWZsZXhBbHBoYSA9PSAxID8gYW5hbHl6ZXJIZWlnaHQgOiBjaGFubmVsSGVpZ2h0ICkgKyBjaGFubmVsR2FwICk7XG5cblx0XHRcdFx0XHRfY3R4Lmdsb2JhbEFscGhhID0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGRyYXcgZEIgc2NhbGUgKFktYXhpcykgLSBhdm9pZCBkcmF3aW5nIGl0IHR3aWNlIG9uICdkdWFsLWNvbWJpbmVkJyBjaGFubmVsIGxheW91dFxuXHRcdFx0XHRpZiAoIHRoaXMuc2hvd1NjYWxlWSAmJiAhIGlzTHVtaSAmJiAhIF9yYWRpYWwgJiYgKCBjaGFubmVsID09IDAgfHwgISBpc0R1YWxDb21iaW5lZCApIClcblx0XHRcdFx0XHRkcmF3U2NhbGVZKCk7XG5cblx0XHRcdFx0Ly8gc2V0IGxpbmUgd2lkdGggYW5kIGRhc2ggZm9yIExFRHMgZWZmZWN0XG5cdFx0XHRcdGlmICggaXNMZWRzICkge1xuXHRcdFx0XHRcdF9jdHguc2V0TGluZURhc2goIFsgbGVkSGVpZ2h0LCBsZWRTcGFjZVYgXSApO1xuXHRcdFx0XHRcdF9jdHgubGluZVdpZHRoID0gX2JhcnNbMF0ud2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSAvLyBmb3Igb3V0bGluZSBlZmZlY3QgZW5zdXJlIGxpbmV3aWR0aCBpcyBub3QgZ3JlYXRlciB0aGFuIGhhbGYgdGhlIGJhciB3aWR0aFxuXHRcdFx0XHRcdF9jdHgubGluZVdpZHRoID0gaXNPdXRsaW5lID8gTWF0aC5taW4oIF9saW5lV2lkdGgsIF9iYXJzWzBdLndpZHRoIC8gMiApIDogX2xpbmVXaWR0aDtcblxuXHRcdFx0XHQvLyBzZXQgY2xpcHBpbmcgcmVnaW9uXG5cdFx0XHRcdF9jdHguc2F2ZSgpO1xuXHRcdFx0XHRpZiAoICEgX3JhZGlhbCApIHtcblx0XHRcdFx0XHRjb25zdCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG5cdFx0XHRcdFx0cmVnaW9uLnJlY3QoIDAsIGNoYW5uZWxUb3AsIGNhbnZhcy53aWR0aCwgYW5hbHl6ZXJIZWlnaHQgKTtcblx0XHRcdFx0XHRfY3R4LmNsaXAoIHJlZ2lvbiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gLy8gaWYgKCB1c2VDYW52YXMgKVxuXG5cdFx0XHQvLyBnZXQgYSBuZXcgYXJyYXkgb2YgZGF0YSBmcm9tIHRoZSBGRlRcblx0XHRcdGxldCBmZnREYXRhID0gdGhpcy5fZmZ0RGF0YVsgY2hhbm5lbCBdO1xuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGNoYW5uZWwgXS5nZXRGbG9hdEZyZXF1ZW5jeURhdGEoIGZmdERhdGEgKTtcblxuXHRcdFx0Ly8gYXBwbHkgd2VpZ2h0aW5nXG5cdFx0XHRpZiAoIF93ZWlnaHRpbmdGaWx0ZXIgKVxuXHRcdFx0XHRmZnREYXRhID0gZmZ0RGF0YS5tYXAoICggdmFsLCBpZHggKSA9PiB2YWwgKyB3ZWlnaHRpbmdkQiggdGhpcy5fYmluVG9GcmVxKCBpZHggKSApICk7XG5cblx0XHRcdC8vIHN0YXJ0IGRyYXdpbmcgcGF0aCAoZm9yIGdyYXBoIG1vZGUpXG5cdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHQvLyBzdG9yZSBsaW5lIGdyYXBoIHBvaW50cyB0byBjcmVhdGUgbWlycm9yIGVmZmVjdCBpbiByYWRpYWwgbW9kZVxuXHRcdFx0bGV0IHBvaW50cyA9IFtdO1xuXG5cdFx0XHQvLyBkcmF3IGJhcnMgLyBsaW5lc1xuXG5cdFx0XHRmb3IgKCBsZXQgYmFySW5kZXggPSAwOyBiYXJJbmRleCA8IG5CYXJzOyBiYXJJbmRleCsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGJhciA9IF9iYXJzWyBiYXJJbmRleCBdLFxuXHRcdFx0XHRcdCAgeyBwb3NYLCBiYXJDZW50ZXIsIHdpZHRoLCBmcmVxLCBiaW5MbywgYmluSGksIHJhdGlvTG8sIHJhdGlvSGkgfSA9IGJhcjtcblxuXHRcdFx0XHRsZXQgYmFyVmFsdWUgPSBNYXRoLm1heCggaW50ZXJwb2xhdGUoIGJpbkxvLCByYXRpb0xvICksIGludGVycG9sYXRlKCBiaW5IaSwgcmF0aW9IaSApICk7XG5cblx0XHRcdFx0Ly8gY2hlY2sgYWRkaXRpb25hbCBiaW5zIChpZiBhbnkpIGZvciB0aGlzIGJhciBhbmQga2VlcCB0aGUgaGlnaGVzdCB2YWx1ZVxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IGJpbkxvICsgMTsgaiA8IGJpbkhpOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBmZnREYXRhWyBqIF0gPiBiYXJWYWx1ZSApXG5cdFx0XHRcdFx0XHRiYXJWYWx1ZSA9IGZmdERhdGFbIGogXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vcm1hbGl6ZSBiYXIgYW1wbGl0dWRlIGluIFswOzFdIHJhbmdlXG5cdFx0XHRcdGJhclZhbHVlID0gdGhpcy5fbm9ybWFsaXplZEIoIGJhclZhbHVlICk7XG5cblx0XHRcdFx0YmFyLnZhbHVlWyBjaGFubmVsIF0gPSBiYXJWYWx1ZTtcblx0XHRcdFx0Y3VycmVudEVuZXJneSArPSBiYXJWYWx1ZTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgYmFyIHBlYWtcblx0XHRcdFx0aWYgKCBiYXIucGVha1sgY2hhbm5lbCBdID4gMCAmJiBiYXIuYWxwaGFbIGNoYW5uZWwgXSA+IDAgKSB7XG5cdFx0XHRcdFx0YmFyLmhvbGRbIGNoYW5uZWwgXS0tO1xuXHRcdFx0XHRcdC8vIGlmIGhvbGQgaXMgbmVnYXRpdmUsIHN0YXJ0IHBlYWsgZHJvcCBvciBmYWRlIG91dFxuXHRcdFx0XHRcdGlmICggYmFyLmhvbGRbIGNoYW5uZWwgXSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIF9mYWRlUGVha3MgJiYgISBzaG93UGVha0xpbmUgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGluaXRpYWxBbHBoYSA9ICEgaXNBbHBoYSB8fCAoIGlzT3V0bGluZSAmJiBfbGluZVdpZHRoID4gMCApID8gMSA6IGlzQWxwaGEgPyBiYXIucGVha1sgY2hhbm5lbCBdIDogZmlsbEFscGhhO1xuXHRcdFx0XHRcdFx0XHRiYXIuYWxwaGFbIGNoYW5uZWwgXSA9IGluaXRpYWxBbHBoYSAqICggMSArIGJhci5ob2xkWyBjaGFubmVsIF0gLyBmYWRlRnJhbWVzICk7IC8vIGhvbGQgaXMgbmVnYXRpdmUsIHNvIHRoaXMgaXMgPD0gMVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRiYXIucGVha1sgY2hhbm5lbCBdICs9IGJhci5ob2xkWyBjaGFubmVsIF0gKiBncmF2aXR5IC8gZnBzU3F1YXJlZCAvIG5vbWluYWxNYXhIZWlnaHQ7XG5cdFx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIHBlYWsgdmFsdWUgaXMgcmVzZXQgd2hlbiB1c2luZyBmYWRlUGVha3Ncblx0XHRcdFx0XHRcdGlmICggYmFyLmFscGhhWyBjaGFubmVsIF0gPD0gMCApXG5cdFx0XHRcdFx0XHRcdGJhci5wZWFrWyBjaGFubmVsIF0gPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIGl0J3MgYSBuZXcgcGVhayBmb3IgdGhpcyBiYXJcblx0XHRcdFx0aWYgKCBiYXJWYWx1ZSA+PSBiYXIucGVha1sgY2hhbm5lbCBdICkge1xuXHRcdFx0XHRcdGJhci5wZWFrWyBjaGFubmVsIF0gPSBiYXJWYWx1ZTtcblx0XHRcdFx0XHRiYXIuaG9sZFsgY2hhbm5lbCBdID0gaG9sZEZyYW1lcztcblx0XHRcdFx0XHQvLyBjaGVjayB3aGV0aGVyIGlzQWxwaGEgb3IgaXNPdXRsaW5lIGFyZSBhY3RpdmUgdG8gc3RhcnQgdGhlIHBlYWsgYWxwaGEgd2l0aCB0aGUgcHJvcGVyIHZhbHVlXG5cdFx0XHRcdFx0YmFyLmFscGhhWyBjaGFubmVsIF0gPSAhIGlzQWxwaGEgfHwgKCBpc091dGxpbmUgJiYgX2xpbmVXaWR0aCA+IDAgKSA/IDEgOiBpc0FscGhhID8gYmFyVmFsdWUgOiBmaWxsQWxwaGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBub3QgdXNpbmcgdGhlIGNhbnZhcywgbW92ZSBlYXJsaWVyIHRvIHRoZSBuZXh0IGJhclxuXHRcdFx0XHRpZiAoICEgdXNlQ2FudmFzIClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHQvLyBzZXQgb3BhY2l0eSBmb3IgYmFyIGVmZmVjdHNcblx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9ICggaXNMdW1pIHx8IGlzQWxwaGEgKSA/IGJhclZhbHVlIDogKCBpc091dGxpbmUgKSA/IGZpbGxBbHBoYSA6IDE7XG5cblx0XHRcdFx0Ly8gc2V0IGZpbGxTdHlsZSBhbmQgc3Ryb2tlU3R5bGUgZm9yIHRoZSBjdXJyZW50IGJhclxuXHRcdFx0XHRzZXRCYXJDb2xvciggYmFyVmFsdWUsIGJhckluZGV4ICk7XG5cblx0XHRcdFx0Ly8gY29tcHV0ZSBhY3R1YWwgYmFyIGhlaWdodCBvbiBzY3JlZW5cblx0XHRcdFx0Y29uc3QgYmFySGVpZ2h0ID0gaXNMdW1pID8gbWF4QmFySGVpZ2h0IDogaXNMZWRzID8gbGVkUG9zWSggYmFyVmFsdWUgKSA6IGJhclZhbHVlICogbWF4QmFySGVpZ2h0IHwgMDtcblxuXHRcdFx0XHQvLyBEcmF3IGN1cnJlbnQgYmFyIG9yIGxpbmUgc2VnbWVudFxuXG5cdFx0XHRcdGlmICggX21vZGUgPT0gTU9ERV9HUkFQSCApIHtcblx0XHRcdFx0XHQvLyBjb21wdXRlIHRoZSBhdmVyYWdlIGJldHdlZW4gdGhlIGluaXRpYWwgYmFyIChiYXJJbmRleD09MCkgYW5kIHRoZSBuZXh0IG9uZVxuXHRcdFx0XHRcdC8vIHVzZWQgdG8gc21vb3RoIHRoZSBjdXJ2ZSB3aGVuIHRoZSBpbml0aWFsIHBvc1ggaXMgb2ZmIHRoZSBzY3JlZW4sIGluIG1pcnJvciBhbmQgcmFkaWFsIG1vZGVzXG5cdFx0XHRcdFx0Y29uc3QgbmV4dEJhckF2ZyA9IGJhckluZGV4ID8gMCA6ICggdGhpcy5fbm9ybWFsaXplZEIoIGZmdERhdGFbIF9iYXJzWzFdLmJpbkxvIF0gKSAqIG1heEJhckhlaWdodCArIGJhckhlaWdodCApIC8gMjtcblxuXHRcdFx0XHRcdGlmICggX3JhZGlhbCApIHtcblx0XHRcdFx0XHRcdGlmICggYmFySW5kZXggPT0gMCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0R1YWxIb3Jpem9udGFsIClcblx0XHRcdFx0XHRcdFx0XHRfY3R4Lm1vdmVUbyggLi4ucmFkaWFsWFkoIDAsIDAgKSApO1xuXHRcdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIDAsICggcG9zWCA8IDAgPyBuZXh0QmFyQXZnIDogYmFySGVpZ2h0ICkgKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gZHJhdyBsaW5lIHRvIHRoZSBjdXJyZW50IHBvaW50LCBhdm9pZGluZyBvdmVybGFwcGluZyB3cmFwLWFyb3VuZCBmcmVxdWVuY2llc1xuXHRcdFx0XHRcdFx0aWYgKCBwb3NYID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHBvaW50ID0gWyBwb3NYLCBiYXJIZWlnaHQgXTtcblx0XHRcdFx0XHRcdFx0X2N0eC5saW5lVG8oIC4uLnJhZGlhbFhZKCAuLi5wb2ludCApICk7XG5cdFx0XHRcdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgLy8gTGluZWFyXG5cdFx0XHRcdFx0XHRpZiAoIGJhckluZGV4ID09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHN0YXJ0IHRoZSBsaW5lIG9mZi1zY3JlZW4gdXNpbmcgdGhlIHByZXZpb3VzIEZGVCBiaW4gdmFsdWUgYXMgdGhlIGluaXRpYWwgYW1wbGl0dWRlXG5cdFx0XHRcdFx0XHRcdGlmICggX21pcnJvciA9PSAtMSAmJiAhIGlzRHVhbEhvcml6b250YWwgKVxuXHRcdFx0XHRcdFx0XHRcdF9jdHgubW92ZVRvKCBpbml0aWFsWCwgYW5hbHl6ZXJCb3R0b20gLSAoIHBvc1ggPCBpbml0aWFsWCA/IG5leHRCYXJBdmcgOiBiYXJIZWlnaHQgKSApO1xuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBwcmV2RkZURGF0YSA9IGJpbkxvID8gdGhpcy5fbm9ybWFsaXplZEIoIGZmdERhdGFbIGJpbkxvIC0gMSBdICkgKiBtYXhCYXJIZWlnaHQgOiBiYXJIZWlnaHQ7IC8vIHVzZSBwcmV2aW91cyBGRlQgYmluIHZhbHVlLCB3aGVuIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRcdF9jdHgubW92ZVRvKCBpbml0aWFsWCAtIF9saW5lV2lkdGgsIGFuYWx5emVyQm90dG9tIC0gcHJldkZGVERhdGEgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gZHJhdyBsaW5lIHRvIHRoZSBjdXJyZW50IHBvaW50XG5cdFx0XHRcdFx0XHQvLyBhdm9pZCBYIHZhbHVlcyBsb3dlciB0aGFuIHRoZSBvcmlnaW4gd2hlbiBtaXJyb3JpbmcgbGVmdCwgb3RoZXJ3aXNlIGRyYXcgdGhlbSBmb3IgYmVzdCBncmFwaCBhY2N1cmFjeVxuXHRcdFx0XHRcdFx0aWYgKCBpc0R1YWxIb3Jpem9udGFsIHx8IF9taXJyb3IgIT0gLTEgfHwgcG9zWCA+PSBpbml0aWFsWCApXG5cdFx0XHRcdFx0XHRcdF9jdHgubGluZVRvKCBwb3NYLCBhbmFseXplckJvdHRvbSAtIGJhckhlaWdodCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIGlzTGVkcyApIHtcblx0XHRcdFx0XHRcdC8vIGRyYXcgXCJ1bmxpdFwiIGxlZHMgLSBhdm9pZCBkcmF3aW5nIGl0IHR3aWNlIG9uICdkdWFsLWNvbWJpbmVkJyBjaGFubmVsIGxheW91dFxuXHRcdFx0XHRcdFx0aWYgKCBzaG93QmdDb2xvciAmJiAhIG92ZXJsYXkgJiYgKCBjaGFubmVsID09IDAgfHwgISBpc0R1YWxDb21iaW5lZCApICkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhbHBoYSA9IF9jdHguZ2xvYmFsQWxwaGE7XG5cdFx0XHRcdFx0XHRcdF9jdHguc3Ryb2tlU3R5bGUgPSBMRURTX1VOTElUX0NPTE9SO1xuXHRcdFx0XHRcdFx0XHRfY3R4Lmdsb2JhbEFscGhhID0gMTtcblx0XHRcdFx0XHRcdFx0c3Ryb2tlQmFyKCBiYXJDZW50ZXIsIGNoYW5uZWxUb3AsIGFuYWx5emVyQm90dG9tICk7XG5cdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgcHJvcGVydGllc1xuXHRcdFx0XHRcdFx0XHRfY3R4LnN0cm9rZVN0eWxlID0gX2N0eC5maWxsU3R5bGU7XG5cdFx0XHRcdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaXNUcnVlTGVkcyApIHtcblx0XHRcdFx0XHRcdFx0Ly8gbGVkUG9zWSgpIGlzIHVzZWQgYmVsb3cgdG8gZml0IG9uZSBlbnRpcmUgbGVkIGhlaWdodCBpbnRvIHRoZSBzZWxlY3RlZCByYW5nZVxuXHRcdFx0XHRcdFx0XHRjb25zdCBjb2xvckluZGV4ID0gaXNMdW1pID8gMCA6IGNvbG9yU3RvcHMuZmluZExhc3RJbmRleCggaXRlbSA9PiBsZWRQb3NZKCBiYXJWYWx1ZSApIDw9IGxlZFBvc1koIGl0ZW0ubGV2ZWwgKSApO1xuXHRcdFx0XHRcdFx0XHRsZXQgbGFzdCA9IGFuYWx5emVyQm90dG9tO1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IGNvbG9yQ291bnQgLSAxOyBpID49IGNvbG9ySW5kZXg7IGktLSApIHtcblx0XHRcdFx0XHRcdFx0XHRfY3R4LnN0cm9rZVN0eWxlID0gY29sb3JTdG9wc1sgaSBdLmNvbG9yO1xuXHRcdFx0XHRcdFx0XHRcdGxldCB5ID0gYW5hbHl6ZXJCb3R0b20gLSAoIGkgPT0gY29sb3JJbmRleCA/IGJhckhlaWdodCA6IGxlZFBvc1koIGNvbG9yU3RvcHNbIGkgXS5sZXZlbCApICk7XG5cdFx0XHRcdFx0XHRcdFx0c3Ryb2tlQmFyKCBiYXJDZW50ZXIsIGxhc3QsIHkgKTtcblx0XHRcdFx0XHRcdFx0XHRsYXN0ID0geSAtIGxlZFNwYWNlVjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRzdHJva2VCYXIoIGJhckNlbnRlciwgYW5hbHl6ZXJCb3R0b20sIGFuYWx5emVyQm90dG9tIC0gYmFySGVpZ2h0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBwb3NYID49IGluaXRpYWxYICkge1xuXHRcdFx0XHRcdFx0aWYgKCBfcmFkaWFsIClcblx0XHRcdFx0XHRcdFx0cmFkaWFsUG9seSggcG9zWCwgMCwgd2lkdGgsIGJhckhlaWdodCwgaXNPdXRsaW5lICk7XG5cdFx0XHRcdFx0XHRlbHNlIGlmICggaXNSb3VuZCApIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaGFsZldpZHRoID0gd2lkdGggLyAyLFxuXHRcdFx0XHRcdFx0XHRcdCAgeSA9IGFuYWx5emVyQm90dG9tICsgaGFsZldpZHRoOyAvLyByb3VuZCBjYXBzIGhhdmUgYW4gYWRkaXRpb25hbCBoZWlnaHQgb2YgaGFsZiBiYXIgd2lkdGhcblxuXHRcdFx0XHRcdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRfY3R4Lm1vdmVUbyggcG9zWCwgeSApO1xuXHRcdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggcG9zWCwgeSAtIGJhckhlaWdodCApO1xuXHRcdFx0XHRcdFx0XHRfY3R4LmFyYyggYmFyQ2VudGVyLCB5IC0gYmFySGVpZ2h0LCBoYWxmV2lkdGgsIFBJLCBUQVUgKTtcblx0XHRcdFx0XHRcdFx0X2N0eC5saW5lVG8oIHBvc1ggKyB3aWR0aCwgeSApO1xuXHRcdFx0XHRcdFx0XHRzdHJva2VJZiggaXNPdXRsaW5lICk7XG5cdFx0XHRcdFx0XHRcdF9jdHguZmlsbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGlzT3V0bGluZSA/IF9jdHgubGluZVdpZHRoIDogMDtcblx0XHRcdFx0XHRcdFx0X2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdFx0X2N0eC5yZWN0KCBwb3NYLCBhbmFseXplckJvdHRvbSArIG9mZnNldCwgd2lkdGgsIC1iYXJIZWlnaHQgLSBvZmZzZXQgKTtcblx0XHRcdFx0XHRcdFx0c3Ryb2tlSWYoIGlzT3V0bGluZSApO1xuXHRcdFx0XHRcdFx0XHRfY3R4LmZpbGwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEcmF3IHBlYWtcblx0XHRcdFx0Y29uc3QgcGVha1ZhbHVlID0gYmFyLnBlYWtbIGNoYW5uZWwgXSxcblx0XHRcdFx0XHQgIHBlYWtBbHBoYSA9IGJhci5hbHBoYVsgY2hhbm5lbCBdO1xuXG5cdFx0XHRcdGlmICggcGVha1ZhbHVlID4gMCAmJiBwZWFrQWxwaGEgPiAwICYmIHNob3dQZWFrcyAmJiAhIHNob3dQZWFrTGluZSAmJiAhIGlzTHVtaSAmJiBwb3NYID49IGluaXRpYWxYICYmIHBvc1ggPCBmaW5hbFggKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IG9wYWNpdHkgZm9yIHBlYWtcblx0XHRcdFx0XHRpZiAoIF9mYWRlUGVha3MgKVxuXHRcdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IHBlYWtBbHBoYTtcblx0XHRcdFx0XHRlbHNlIGlmICggaXNPdXRsaW5lICYmIF9saW5lV2lkdGggPiAwICkgLy8gd2hlbiBsaW5lV2lkdGggPT0gMCBjdHguZ2xvYmFsQWxwaGEgcmVtYWlucyBzZXQgdG8gYGZpbGxBbHBoYWBcblx0XHRcdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHRcdFx0XHRcdGVsc2UgaWYgKCBpc0FscGhhIClcdFx0XHRcdFx0XHQvLyBpc0FscGhhIChhbHBoYSBiYXNlZCBvbiBwZWFrIHZhbHVlKSBzdXBlcnNlZGVzIGZpbGxBbHBoYSBpZiBsaW5lV2lkdGggPT0gMFxuXHRcdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IHBlYWtWYWx1ZTtcblxuXHRcdFx0XHRcdC8vIHNlbGVjdCB0aGUgcGVhayBjb2xvciBmb3IgJ2Jhci1sZXZlbCcgY29sb3JNb2RlIG9yICd0cnVlTGVkcydcblx0XHRcdFx0XHRpZiAoIF9jb2xvck1vZGUgPT0gQ09MT1JfQkFSX0xFVkVMIHx8IGlzVHJ1ZUxlZHMgKVxuXHRcdFx0XHRcdFx0c2V0QmFyQ29sb3IoIHBlYWtWYWx1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIHBlYWsgYWNjb3JkaW5nIHRvIGN1cnJlbnQgbW9kZSAvIGVmZmVjdFxuXHRcdFx0XHRcdGlmICggaXNMZWRzICkge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGVkUGVhayA9IGxlZFBvc1koIHBlYWtWYWx1ZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBsZWRQZWFrID49IGxlZFNwYWNlViApIC8vIGF2b2lkIHBlYWsgYmVsb3cgZmlyc3QgbGVkXG5cdFx0XHRcdFx0XHRcdF9jdHguZmlsbFJlY3QoIHBvc1gsIGFuYWx5emVyQm90dG9tIC0gbGVkUGVhaywgd2lkdGgsIGxlZEhlaWdodCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggISBfcmFkaWFsIClcblx0XHRcdFx0XHRcdF9jdHguZmlsbFJlY3QoIHBvc1gsIGFuYWx5emVyQm90dG9tIC0gcGVha1ZhbHVlICogbWF4QmFySGVpZ2h0LCB3aWR0aCwgMiApO1xuXHRcdFx0XHRcdGVsc2UgaWYgKCBfbW9kZSAhPSBNT0RFX0dSQVBIICkgeyAvLyByYWRpYWwgKHBlYWtzIGZvciBncmFwaCBtb2RlIGFyZSBkb25lIGJ5IHRoZSBwZWFrTGluZSBjb2RlKVxuXHRcdFx0XHRcdFx0Y29uc3QgeSA9IHBlYWtWYWx1ZSAqIG1heEJhckhlaWdodDtcblx0XHRcdFx0XHRcdHJhZGlhbFBvbHkoIHBvc1gsIHksIHdpZHRoLCAhIHRoaXMuX3JhZGlhbEludmVydCB8fCBpc0R1YWxWZXJ0aWNhbCB8fCB5ICsgaW5uZXJSYWRpdXMgPj0gMiA/IC0yIDogMiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IC8vIGZvciAoIGxldCBiYXJJbmRleCA9IDA7IGJhckluZGV4IDwgbkJhcnM7IGJhckluZGV4KysgKVxuXG5cdFx0XHQvLyBpZiBub3QgdXNpbmcgdGhlIGNhbnZhcywgbW92ZSBlYXJsaWVyIHRvIHRoZSBuZXh0IGNoYW5uZWxcblx0XHRcdGlmICggISB1c2VDYW52YXMgKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Ly8gcmVzdG9yZSBnbG9iYWwgYWxwaGFcblx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG5cdFx0XHQvLyBGaWxsL3N0cm9rZSBkcmF3aW5nIHBhdGggZm9yIGdyYXBoIG1vZGVcblx0XHRcdGlmICggX21vZGUgPT0gTU9ERV9HUkFQSCApIHtcblx0XHRcdFx0c2V0QmFyQ29sb3IoKTsgLy8gc2VsZWN0IGNoYW5uZWwgZ3JhZGllbnRcblxuXHRcdFx0XHRpZiAoIF9yYWRpYWwgJiYgISBpc0R1YWxIb3Jpem9udGFsICkge1xuXHRcdFx0XHRcdGlmICggX21pcnJvciApIHtcblx0XHRcdFx0XHRcdGxldCBwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBwID0gcG9pbnRzLnBvcCgpIClcblx0XHRcdFx0XHRcdFx0X2N0eC5saW5lVG8oIC4uLnJhZGlhbFhZKCAuLi5wLCAtMSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9jdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIF9saW5lV2lkdGggPiAwIClcblx0XHRcdFx0XHRfY3R4LnN0cm9rZSgpO1xuXG5cdFx0XHRcdGlmICggZmlsbEFscGhhID4gMCApIHtcblx0XHRcdFx0XHRpZiAoIF9yYWRpYWwgKSB7XG5cdFx0XHRcdFx0XHQvLyBleGNsdWRlIHRoZSBjZW50ZXIgY2lyY2xlIGZyb20gdGhlIGZpbGwgYXJlYVxuXHRcdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBpc0R1YWxIb3Jpem9udGFsID8gZ2V0QW5nbGUoIGFuYWx5emVyV2lkdGggPj4gMSApIDogMCxcblx0XHRcdFx0XHRcdFx0ICBlbmQgICA9IGlzRHVhbEhvcml6b250YWwgPyBnZXRBbmdsZSggYW5hbHl6ZXJXaWR0aCApIDogVEFVO1xuXHRcdFx0XHRcdFx0X2N0eC5tb3ZlVG8oIC4uLnJhZGlhbFhZKCBpc0R1YWxIb3Jpem9udGFsID8gYW5hbHl6ZXJXaWR0aCA+PiAxIDogMCwgMCApICk7XG5cdFx0XHRcdFx0XHRfY3R4LmFyYyggY2VudGVyWCwgY2VudGVyWSwgaW5uZXJSYWRpdXMsIHN0YXJ0LCBlbmQsIGlzRHVhbEhvcml6b250YWwgPyAhIGludmVydGVkQ2hhbm5lbCA6IHRydWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBjbG9zZSB0aGUgZmlsbCBhcmVhXG5cdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggZmluYWxYLCBhbmFseXplckJvdHRvbSApO1xuXHRcdFx0XHRcdFx0X2N0eC5saW5lVG8oIGluaXRpYWxYLCBhbmFseXplckJvdHRvbSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSBmaWxsQWxwaGE7XG5cdFx0XHRcdFx0X2N0eC5maWxsKCk7XG5cdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBkcmF3IHBlYWsgbGluZSAoYW5kIHN0YW5kYXJkIHBlYWtzIG9uIHJhZGlhbClcblx0XHRcdFx0aWYgKCBzaG93UGVha0xpbmUgfHwgKCBfcmFkaWFsICYmIHNob3dQZWFrcyApICkge1xuXHRcdFx0XHRcdHBvaW50cyA9IFtdOyAvLyBmb3IgbWlycm9yIGxpbmUgb24gcmFkaWFsXG5cdFx0XHRcdFx0X2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRfYmFycy5mb3JFYWNoKCAoIGIsIGkgKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgeCA9IGIucG9zWCxcblx0XHRcdFx0XHRcdFx0aCA9IGIucGVha1sgY2hhbm5lbCBdLFxuXHRcdFx0XHRcdFx0XHRtID0gaSA/ICdsaW5lVG8nIDogJ21vdmVUbyc7XG5cdFx0XHRcdFx0XHRpZiAoIF9yYWRpYWwgJiYgeCA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5leHRCYXIgPSBfYmFyc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdFx0aCA9IGZpbmRZKCB4LCBoLCBuZXh0QmFyLnBvc1gsIG5leHRCYXIucGVha1sgY2hhbm5lbCBdLCAwICk7XG5cdFx0XHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aCAqPSBtYXhCYXJIZWlnaHQ7XG5cdFx0XHRcdFx0XHRpZiAoIHNob3dQZWFrTGluZSApIHtcblx0XHRcdFx0XHRcdFx0X2N0eFsgbSBdKCAuLi4oIF9yYWRpYWwgPyByYWRpYWxYWSggeCwgaCApIDogWyB4LCBhbmFseXplckJvdHRvbSAtIGggXSApICk7XG5cdFx0XHRcdFx0XHRcdGlmICggX3JhZGlhbCAmJiBfbWlycm9yICYmICEgaXNEdWFsSG9yaXpvbnRhbCApXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRzLnB1c2goIFsgeCwgaCBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICggaCA+IDAgKVxuXHRcdFx0XHRcdFx0XHRyYWRpYWxQb2x5KCB4LCBoLCAxLCAtMiApOyAvLyBzdGFuZGFyZCBwZWFrcyAoYWxzbyBkb2VzIG1pcnJvcilcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoIHNob3dQZWFrTGluZSApIHtcblx0XHRcdFx0XHRcdGxldCBwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBwID0gcG9pbnRzLnBvcCgpIClcblx0XHRcdFx0XHRcdFx0X2N0eC5saW5lVG8oIC4uLnJhZGlhbFhZKCAuLi5wLCAtMSApICk7IC8vIG1pcnJvciBsaW5lIHBvaW50c1xuXHRcdFx0XHRcdFx0X2N0eC5saW5lV2lkdGggPSAxO1xuXHRcdFx0XHRcdFx0X2N0eC5zdHJva2UoKTsgLy8gc3Ryb2tlIHBlYWsgbGluZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfY3R4LnJlc3RvcmUoKTsgLy8gcmVzdG9yZSBjbGlwIHJlZ2lvblxuXG5cdFx0XHRpZiAoIGlzRHVhbEhvcml6b250YWwgJiYgISBfcmFkaWFsIClcblx0XHRcdFx0X2N0eC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcblxuXHRcdFx0Ly8gY3JlYXRlIFJlZmxleCBlZmZlY3QgLSBmb3IgZHVhbC1jb21iaW5lZCBhbmQgZHVhbC1ob3Jpem9udGFsIGRvIGl0IG9ubHkgb25jZSwgYWZ0ZXIgY2hhbm5lbCAxXG5cdFx0XHRpZiAoICggISBpc0R1YWxIb3Jpem9udGFsICYmICEgaXNEdWFsQ29tYmluZWQgKSB8fCBjaGFubmVsIClcblx0XHRcdFx0ZG9SZWZsZXgoIGNoYW5uZWwgKTtcblxuXHRcdH0gLy8gZm9yICggbGV0IGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgbkNoYW5uZWxzOyBjaGFubmVsKysgKSB7XG5cblx0XHR1cGRhdGVFbmVyZ3koIGN1cnJlbnRFbmVyZ3kgLyAoIG5CYXJzIDw8ICggbkNoYW5uZWxzIC0gMSApICkgKTtcblxuXHRcdGlmICggdXNlQ2FudmFzICkge1xuXHRcdFx0Ly8gTWlycm9yIGVmZmVjdFxuXHRcdFx0aWYgKCBfbWlycm9yICYmICEgX3JhZGlhbCAmJiAhIGlzRHVhbEhvcml6b250YWwgKSB7XG5cdFx0XHRcdF9jdHguc2V0VHJhbnNmb3JtKCAtMSwgMCwgMCwgMSwgY2FudmFzLndpZHRoIC0gaW5pdGlhbFgsIDAgKTtcblx0XHRcdFx0X2N0eC5kcmF3SW1hZ2UoIGNhbnZhcywgaW5pdGlhbFgsIDAsIGNlbnRlclgsIGNhbnZhcy5oZWlnaHQsIDAsIDAsIGNlbnRlclgsIGNhbnZhcy5oZWlnaHQgKTtcblx0XHRcdFx0X2N0eC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzdG9yZSBzb2xpZCBsaW5lc1xuXHRcdFx0X2N0eC5zZXRMaW5lRGFzaChbXSk7XG5cblx0XHRcdC8vIGRyYXcgZnJlcXVlbmN5IHNjYWxlIChYLWF4aXMpXG5cdFx0XHRkcmF3U2NhbGVYKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZGlzcGxheSBjdXJyZW50IGZyYW1lIHJhdGVcblx0XHRpZiAoIHRoaXMuc2hvd0ZQUyApIHtcblx0XHRcdGNvbnN0IHNpemUgPSBjYW52YXNYLmhlaWdodDtcblx0XHRcdF9jdHguZm9udCA9IGBib2xkICR7c2l6ZX1weCAke0ZPTlRfRkFNSUxZfWA7XG5cdFx0XHRfY3R4LmZpbGxTdHlsZSA9IEZQU19DT0xPUjtcblx0XHRcdF9jdHgudGV4dEFsaWduID0gJ3JpZ2h0Jztcblx0XHRcdF9jdHguZmlsbFRleHQoIE1hdGgucm91bmQoIF9mcHMgKSwgY2FudmFzLndpZHRoIC0gc2l6ZSwgc2l6ZSAqIDIgKTtcblx0XHR9XG5cblx0XHQvLyBjYWxsIGNhbGxiYWNrIGZ1bmN0aW9uLCBpZiBkZWZpbmVkXG5cdFx0aWYgKCB0aGlzLm9uQ2FudmFzRHJhdyApIHtcblx0XHRcdF9jdHguc2F2ZSgpO1xuXHRcdFx0X2N0eC5maWxsU3R5bGUgPSBfY3R4LnN0cm9rZVN0eWxlID0gX2NhbnZhc0dyYWRpZW50c1swXTtcblx0XHRcdHRoaXMub25DYW52YXNEcmF3KCB0aGlzLCB7IHRpbWVzdGFtcCwgY2FudmFzR3JhZGllbnRzOiBfY2FudmFzR3JhZGllbnRzIH0gKTtcblx0XHRcdF9jdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gc2NhbGVkIGZyZXF1ZW5jeSBhY2NvcmRpbmcgdG8gdGhlIHNlbGVjdGVkIHNjYWxlXG5cdCAqL1xuXHRfZnJlcVNjYWxpbmcoIGZyZXEgKSB7XG5cdFx0c3dpdGNoICggdGhpcy5fZnJlcXVlbmN5U2NhbGUgKSB7XG5cdFx0XHRjYXNlIFNDQUxFX0xPRyA6XG5cdFx0XHRcdHJldHVybiBNYXRoLmxvZzIoIGZyZXEgKTtcblx0XHRcdGNhc2UgU0NBTEVfQkFSSyA6XG5cdFx0XHRcdHJldHVybiAoIDI2LjgxICogZnJlcSApIC8gKCAxOTYwICsgZnJlcSApIC0gLjUzO1xuXHRcdFx0Y2FzZSBTQ0FMRV9NRUwgOlxuXHRcdFx0XHRyZXR1cm4gTWF0aC5sb2cyKCAxICsgZnJlcSAvIDcwMCApO1xuXHRcdFx0Y2FzZSBTQ0FMRV9MSU5FQVIgOlxuXHRcdFx0XHRyZXR1cm4gZnJlcTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBGRlQgZGF0YSBiaW4gKGFycmF5IGluZGV4KSB3aGljaCByZXByZXNlbnRzIGEgZ2l2ZW4gZnJlcXVlbmN5XG5cdCAqL1xuXHRfZnJlcVRvQmluKCBmcmVxLCBtZXRob2QgPSAncm91bmQnICkge1xuXHRcdGNvbnN0IG1heCA9IHRoaXMuX2FuYWx5emVyWzBdLmZyZXF1ZW5jeUJpbkNvdW50IC0gMSxcblx0XHRcdCAgYmluID0gTWF0aFsgbWV0aG9kIF0oIGZyZXEgKiB0aGlzLmZmdFNpemUgLyB0aGlzLmF1ZGlvQ3R4LnNhbXBsZVJhdGUgKTtcblxuXHRcdHJldHVybiBiaW4gPCBtYXggPyBiaW4gOiBtYXg7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgY3VycmVudGx5IHNlbGVjdGVkIGdyYWRpZW50XG5cdCAqL1xuXHRfbWFrZUdyYWQoKSB7XG5cdFx0aWYgKCAhIHRoaXMuX3JlYWR5IClcblx0XHRcdHJldHVybjtcblxuXHRcdGNvbnN0IHsgY2FudmFzLCBfY3R4LCBfcmFkaWFsLCBfcmVmbGV4UmF0aW8gfSA9IHRoaXMsXG5cdFx0XHQgIHsgYW5hbHl6ZXJXaWR0aCwgY2VudGVyWCwgY2VudGVyWSwgaW5pdGlhbFgsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcy5fYXV4LFxuXHRcdFx0ICB7IGlzTHVtaSB9ICAgICA9IHRoaXMuX2ZsZyxcblx0XHRcdCAgaXNEdWFsVmVydGljYWwgPSB0aGlzLl9jaExheW91dCA9PSBDSEFOTkVMX1ZFUlRJQ0FMLFxuXHRcdFx0ICBhbmFseXplclJhdGlvICA9IDEgLSBfcmVmbGV4UmF0aW8sXG5cdFx0XHQgIGdyYWRpZW50SGVpZ2h0ID0gaXNMdW1pID8gY2FudmFzLmhlaWdodCA6IGNhbnZhcy5oZWlnaHQgKiAoIDEgLSBfcmVmbGV4UmF0aW8gKiAoICEgaXNEdWFsVmVydGljYWwgKSApIHwgMDtcblx0XHRcdCAgXHRcdFx0XHQgICAvLyBmb3IgdmVydGljYWwgc3RlcmVvIHdlIGtlZXAgdGhlIGZ1bGwgY2FudmFzIGhlaWdodCBhbmQgaGFuZGxlIHRoZSByZWZsZXggYXJlYXMgd2hpbGUgZ2VuZXJhdGluZyB0aGUgY29sb3Igc3RvcHNcblxuXHRcdGZvciAoIGNvbnN0IGNoYW5uZWwgb2YgWzAsMV0gKSB7XG5cdFx0XHRjb25zdCBjdXJyR3JhZGllbnQgPSB0aGlzLl9ncmFkaWVudHNbIHRoaXMuX3NlbGVjdGVkR3JhZHNbIGNoYW5uZWwgXSBdLFxuXHRcdFx0XHQgIGNvbG9yU3RvcHMgICA9IGN1cnJHcmFkaWVudC5jb2xvclN0b3BzLFxuXHRcdFx0XHQgIGlzSG9yaXpvbnRhbCA9IGN1cnJHcmFkaWVudC5kaXIgPT0gJ2gnO1xuXG5cdFx0XHRsZXQgZ3JhZDtcblxuXHRcdFx0aWYgKCBfcmFkaWFsIClcblx0XHRcdFx0Z3JhZCA9IF9jdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoIGNlbnRlclgsIGNlbnRlclksIG91dGVyUmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZLCBpbm5lclJhZGl1cyAtICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApICogaXNEdWFsVmVydGljYWwgKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0Z3JhZCA9IF9jdHguY3JlYXRlTGluZWFyR3JhZGllbnQoIC4uLiggaXNIb3Jpem9udGFsID8gWyBpbml0aWFsWCwgMCwgaW5pdGlhbFggKyBhbmFseXplcldpZHRoLCAwIF0gOiBbIDAsIDAsIDAsIGdyYWRpZW50SGVpZ2h0IF0gKSApO1xuXG5cdFx0XHRpZiAoIGNvbG9yU3RvcHMgKSB7XG5cdFx0XHRcdGNvbnN0IGR1YWwgPSBpc0R1YWxWZXJ0aWNhbCAmJiAhIHRoaXMuX3NwbGl0R3JhZGllbnQgJiYgKCAhIGlzSG9yaXpvbnRhbCB8fCBfcmFkaWFsICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGNoYW5uZWxBcmVhID0gMDsgY2hhbm5lbEFyZWEgPCAxICsgZHVhbDsgY2hhbm5lbEFyZWErKyApIHtcblx0XHRcdFx0XHRjb25zdCBtYXhJbmRleCA9IGNvbG9yU3RvcHMubGVuZ3RoIC0gMTtcblxuXHRcdFx0XHRcdGNvbG9yU3RvcHMuZm9yRWFjaCggKCBjb2xvclN0b3AsIGluZGV4ICkgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IG9mZnNldCA9IGNvbG9yU3RvcC5wb3M7XG5cblx0XHRcdFx0XHRcdC8vIGluIGR1YWwgbW9kZSAobm90IHNwbGl0KSwgdXNlIGhhbGYgdGhlIG9yaWdpbmFsIG9mZnNldCBmb3IgZWFjaCBjaGFubmVsXG5cdFx0XHRcdFx0XHRpZiAoIGR1YWwgKVxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgLz0gMjtcblxuXHRcdFx0XHRcdFx0Ly8gY29uc3RyYWluIHRoZSBvZmZzZXQgd2l0aGluIHRoZSB1c2VmdWwgYW5hbHl6ZXIgYXJlYXMgKGF2b2lkIHJlZmxleCBhcmVhcylcblx0XHRcdFx0XHRcdGlmICggaXNEdWFsVmVydGljYWwgJiYgISBpc0x1bWkgJiYgISBfcmFkaWFsICYmICEgaXNIb3Jpem9udGFsICkge1xuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKj0gYW5hbHl6ZXJSYXRpbztcblx0XHRcdFx0XHRcdFx0Ly8gc2tpcCB0aGUgZmlyc3QgcmVmbGV4IGFyZWEgaW4gc3BsaXQgbW9kZVxuXHRcdFx0XHRcdFx0XHRpZiAoICEgZHVhbCAmJiBvZmZzZXQgPiAuNSAqIGFuYWx5emVyUmF0aW8gKVxuXHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAuNSAqIF9yZWZsZXhSYXRpbztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gb25seSBmb3IgZHVhbC12ZXJ0aWNhbCBub24tc3BsaXQgZ3JhZGllbnQgKGNyZWF0ZXMgZnVsbCBncmFkaWVudCBvbiBib3RoIGhhbHZlcyBvZiB0aGUgY2FudmFzKVxuXHRcdFx0XHRcdFx0aWYgKCBjaGFubmVsQXJlYSA9PSAxICkge1xuXHRcdFx0XHRcdFx0XHQvLyBhZGQgY29sb3JzIGluIHJldmVyc2Ugb3JkZXIgaWYgcmFkaWFsIG9yIGx1bWkgYXJlIGFjdGl2ZVxuXHRcdFx0XHRcdFx0XHRpZiAoIF9yYWRpYWwgfHwgaXNMdW1pICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHJldkluZGV4ID0gbWF4SW5kZXggLSBpbmRleDtcblx0XHRcdFx0XHRcdFx0XHRjb2xvclN0b3AgPSBjb2xvclN0b3BzWyByZXZJbmRleCBdO1xuXHRcdFx0XHRcdFx0XHRcdG9mZnNldCA9IDEgLSBjb2xvclN0b3AucG9zIC8gMjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgZmlyc3Qgb2Zmc2V0IGlzIG5vdCAwLCBjcmVhdGUgYW4gYWRkaXRpb25hbCBjb2xvciBzdG9wIHRvIHByZXZlbnQgYmxlZWRpbmcgZnJvbSB0aGUgZmlyc3QgY2hhbm5lbFxuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPT0gMCAmJiBvZmZzZXQgPiAwIClcblx0XHRcdFx0XHRcdFx0XHRcdGdyYWQuYWRkQ29sb3JTdG9wKCAuNSwgY29sb3JTdG9wLmNvbG9yICk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gYnVtcCB0aGUgb2Zmc2V0IHRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgZ3JhZGllbnRcblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gLjU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gYWRkIGdyYWRpZW50IGNvbG9yIHN0b3Bcblx0XHRcdFx0XHRcdGdyYWQuYWRkQ29sb3JTdG9wKCBvZmZzZXQsIGNvbG9yU3RvcC5jb2xvciApO1xuXG5cdFx0XHRcdFx0XHQvLyBjcmVhdGUgYWRkaXRpb25hbCBjb2xvciBzdG9wIGF0IHRoZSBlbmQgb2YgZmlyc3QgY2hhbm5lbCB0byBwcmV2ZW50IGJsZWVkaW5nXG5cdFx0XHRcdFx0XHRpZiAoIGlzRHVhbFZlcnRpY2FsICYmIGluZGV4ID09IG1heEluZGV4ICYmIG9mZnNldCA8IC41IClcblx0XHRcdFx0XHRcdFx0Z3JhZC5hZGRDb2xvclN0b3AoIC41LCBjb2xvclN0b3AuY29sb3IgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSAvLyBmb3IgKCBsZXQgY2hhbm5lbEFyZWEgPSAwOyBjaGFubmVsQXJlYSA8IDEgKyBkdWFsOyBjaGFubmVsQXJlYSsrIClcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2FudmFzR3JhZGllbnRzWyBjaGFubmVsIF0gPSBncmFkO1xuXHRcdH0gLy8gZm9yICggY29uc3QgY2hhbm5lbCBvZiBbMCwxXSApXG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplIGEgZEIgdmFsdWUgaW4gdGhlIFswOzFdIHJhbmdlXG5cdCAqL1xuXHRfbm9ybWFsaXplZEIoIHZhbHVlICkge1xuXHRcdGNvbnN0IGlzTGluZWFyICAgPSB0aGlzLl9saW5lYXJBbXBsaXR1ZGUsXG5cdFx0XHQgIGJvb3N0ICAgICAgPSBpc0xpbmVhciA/IDEgLyB0aGlzLl9saW5lYXJCb29zdCA6IDEsXG5cdFx0XHQgIGNsYW1wICAgICAgPSAoIHZhbCwgbWluLCBtYXggKSA9PiB2YWwgPD0gbWluID8gbWluIDogdmFsID49IG1heCA/IG1heCA6IHZhbCxcblx0XHRcdCAgZEJUb0xpbmVhciA9IHZhbCA9PiAxMCAqKiAoIHZhbCAvIDIwICk7XG5cblx0XHRsZXQgbWF4VmFsdWUgPSB0aGlzLm1heERlY2liZWxzLFxuXHRcdFx0bWluVmFsdWUgPSB0aGlzLm1pbkRlY2liZWxzO1xuXG5cdFx0aWYgKCBpc0xpbmVhciApIHtcblx0XHRcdG1heFZhbHVlID0gZEJUb0xpbmVhciggbWF4VmFsdWUgKTtcblx0XHRcdG1pblZhbHVlID0gZEJUb0xpbmVhciggbWluVmFsdWUgKTtcblx0XHRcdHZhbHVlID0gZEJUb0xpbmVhciggdmFsdWUgKSAqKiBib29zdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhbXAoICggdmFsdWUgLSBtaW5WYWx1ZSApIC8gKCBtYXhWYWx1ZSAtIG1pblZhbHVlICkgKiogYm9vc3QsIDAsIDEgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjaGFuZ2UgY2FudmFzIGRpbWVuc2lvbnMgb24gZGVtYW5kXG5cdCAqL1xuXHRfc2V0Q2FudmFzKCByZWFzb24gKSB7XG5cdFx0aWYgKCAhIHRoaXMuX3JlYWR5IClcblx0XHRcdHJldHVybjtcblxuXHRcdGNvbnN0IHsgY2FudmFzLCBfY3R4IH0gPSB0aGlzLFxuXHRcdFx0ICBjYW52YXNYICAgID0gdGhpcy5fc2NhbGVYLmNhbnZhcyxcblx0XHRcdCAgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC8gKCB0aGlzLl9sb1JlcyArIDEgKTtcblxuXHRcdGxldCBzY3JlZW5XaWR0aCAgPSB3aW5kb3cuc2NyZWVuLndpZHRoICAqIHBpeGVsUmF0aW8sXG5cdFx0XHRzY3JlZW5IZWlnaHQgPSB3aW5kb3cuc2NyZWVuLmhlaWdodCAqIHBpeGVsUmF0aW87XG5cblx0XHQvLyBGaXggZm9yIGlPUyBTYWZhcmkgLSBzd2FwIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpbiBsYW5kc2NhcGVcblx0XHRpZiAoIE1hdGguYWJzKCB3aW5kb3cub3JpZW50YXRpb24gKSA9PSA5MCAmJiBzY3JlZW5XaWR0aCA8IHNjcmVlbkhlaWdodCApXG5cdFx0XHRbIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQgXSA9IFsgc2NyZWVuSGVpZ2h0LCBzY3JlZW5XaWR0aCBdO1xuXG5cdFx0Y29uc3QgaXNGdWxsc2NyZWVuID0gdGhpcy5pc0Z1bGxzY3JlZW4sXG5cdFx0XHQgIGlzQ2FudmFzRnMgICA9IGlzRnVsbHNjcmVlbiAmJiB0aGlzLl9mc0VsID09IGNhbnZhcyxcblx0XHRcdCAgbmV3V2lkdGggICAgID0gaXNDYW52YXNGcyA/IHNjcmVlbldpZHRoICA6ICggdGhpcy5fd2lkdGggIHx8IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAgfHwgdGhpcy5fZGVmYXVsdFdpZHRoICApICogcGl4ZWxSYXRpbyB8IDAsXG5cdFx0XHQgIG5ld0hlaWdodCAgICA9IGlzQ2FudmFzRnMgPyBzY3JlZW5IZWlnaHQgOiAoIHRoaXMuX2hlaWdodCB8fCB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IHRoaXMuX2RlZmF1bHRIZWlnaHQgKSAqIHBpeGVsUmF0aW8gfCAwO1xuXG5cdFx0Ly8gc2V0L3VwZGF0ZSBvYmplY3QgcHJvcGVydGllc1xuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXHRcdHRoaXMuX2ZzV2lkdGggICAgPSBzY3JlZW5XaWR0aDtcblx0XHR0aGlzLl9mc0hlaWdodCAgID0gc2NyZWVuSGVpZ2h0O1xuXG5cdFx0Ly8gaWYgdGhpcyBpcyBub3QgdGhlIGNvbnN0cnVjdG9yIGNhbGwgYW5kIGNhbnZhcyBkaW1lbnNpb25zIGhhdmVuJ3QgY2hhbmdlZCwgcXVpdFxuXHRcdGlmICggcmVhc29uICE9IFJFQVNPTl9DUkVBVEUgJiYgY2FudmFzLndpZHRoID09IG5ld1dpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT0gbmV3SGVpZ2h0IClcblx0XHRcdHJldHVybjtcblxuXHRcdC8vIGFwcGx5IG5ldyBkaW1lbnNpb25zXG5cdFx0Y2FudmFzLndpZHRoICA9IG5ld1dpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cblx0XHQvLyBpZiBub3QgaW4gb3ZlcmxheSBtb2RlLCBwYWludCB0aGUgY2FudmFzIGJsYWNrXG5cdFx0aWYgKCAhIHRoaXMub3ZlcmxheSApIHtcblx0XHRcdF9jdHguZmlsbFN0eWxlID0gJyMwMDAnO1xuXHRcdFx0X2N0eC5maWxsUmVjdCggMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCApO1xuXHRcdH1cblxuXHRcdC8vIHNldCBsaW5lSm9pbiBwcm9wZXJ0eSBmb3IgYXJlYSBmaWxsIG1vZGUgKHRoaXMgaXMgcmVzZXQgd2hlbmV2ZXIgdGhlIGNhbnZhcyBzaXplIGNoYW5nZXMpXG5cdFx0X2N0eC5saW5lSm9pbiA9ICdiZXZlbCc7XG5cblx0XHQvLyB1cGRhdGUgZGltZW5zaW9ucyBvZiB0aGUgc2NhbGUgY2FudmFzXG5cdFx0Y2FudmFzWC53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdGNhbnZhc1guaGVpZ2h0ID0gTWF0aC5tYXgoIDIwICogcGl4ZWxSYXRpbywgTWF0aC5taW4oIG5ld1dpZHRoLCBuZXdIZWlnaHQgKSAvIDMyIHwgMCApO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIGJhciBwb3NpdGlvbnMgYW5kIGxlZCBvcHRpb25zXG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblxuXHRcdC8vIChyZSlnZW5lcmF0ZSBncmFkaWVudFxuXHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cblx0XHQvLyBkZXRlY3QgZnVsbHNjcmVlbiBjaGFuZ2VzIChmb3IgU2FmYXJpKVxuXHRcdGlmICggdGhpcy5fZnNTdGF0dXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9mc1N0YXR1cyAhPT0gaXNGdWxsc2NyZWVuIClcblx0XHRcdHJlYXNvbiA9IFJFQVNPTl9GU0NIQU5HRTtcblx0XHR0aGlzLl9mc1N0YXR1cyA9IGlzRnVsbHNjcmVlbjtcblxuXHRcdC8vIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCBpZiBkZWZpbmVkXG5cdFx0aWYgKCB0aGlzLm9uQ2FudmFzUmVzaXplIClcblx0XHRcdHRoaXMub25DYW52YXNSZXNpemUoIHJlYXNvbiwgdGhpcyApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbGVjdCBhIGdyYWRpZW50IGZvciBvbmUgb3IgYm90aCBjaGFubmVsc1xuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBncmFkaWVudCBuYW1lXG5cdCAqIEBwYXJhbSBbe251bWJlcn1dIGRlc2lyZWQgY2hhbm5lbCAoMCBvciAxKSAtIGlmIGVtcHR5IG9yIGludmFsaWQsIHNldHMgYm90aCBjaGFubmVsc1xuXHQgKi9cblx0X3NldEdyYWRpZW50KCBuYW1lLCBjaGFubmVsICkge1xuXHRcdGlmICggISB0aGlzLl9ncmFkaWVudHMuaGFzT3duUHJvcGVydHkoIG5hbWUgKSApXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggRVJSX1VOS05PV05fR1JBRElFTlQsIG5hbWUgKTtcblxuXHRcdGlmICggISBbMCwxXS5pbmNsdWRlcyggY2hhbm5lbCApICkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRHcmFkc1sxXSA9IG5hbWU7XG5cdFx0XHRjaGFubmVsID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLl9zZWxlY3RlZEdyYWRzWyBjaGFubmVsIF0gPSBuYW1lO1xuXHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IG9iamVjdCBwcm9wZXJ0aWVzXG5cdCAqL1xuXHRfc2V0UHJvcHMoIG9wdGlvbnMsIHVzZURlZmF1bHRzICkge1xuXHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9ucyBwcm9wZXJ0aWVzXG5cdFx0Y29uc3QgY2FsbGJhY2tzID0gWyAnb25DYW52YXNEcmF3JywgJ29uQ2FudmFzUmVzaXplJyBdO1xuXG5cdFx0Ly8gcHJvcGVydGllcyBub3QgaW4gdGhlIGRlZmF1bHRzIChgc3RlcmVvYCBpcyBkZXByZWNhdGVkKVxuXHRcdGNvbnN0IGV4dHJhUHJvcHMgPSBbICdncmFkaWVudExlZnQnLCAnZ3JhZGllbnRSaWdodCcsICdzdGVyZW8nIF07XG5cblx0XHQvLyBidWlsZCBhbiBhcnJheSBvZiB2YWxpZCBwcm9wZXJ0aWVzOyBgc3RhcnRgIGlzIG5vdCBhbiBhY3R1YWwgcHJvcGVydHkgYW5kIGlzIGhhbmRsZWQgYWZ0ZXIgc2V0dGluZyBldmVyeXRoaW5nIGVsc2Vcblx0XHRjb25zdCB2YWxpZFByb3BzID0gT2JqZWN0LmtleXMoIERFRkFVTFRfU0VUVElOR1MgKS5maWx0ZXIoIGUgPT4gZSAhPSAnc3RhcnQnICkuY29uY2F0KCBjYWxsYmFja3MsIGV4dHJhUHJvcHMgKTtcblxuXHRcdGlmICggdXNlRGVmYXVsdHMgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkIClcblx0XHRcdG9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfU0VUVElOR1MsIC4uLm9wdGlvbnMgfTsgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG5cblx0XHRmb3IgKCBjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKCBvcHRpb25zICkgKSB7XG5cdFx0XHRpZiAoIGNhbGxiYWNrcy5pbmNsdWRlcyggcHJvcCApICYmIHR5cGVvZiBvcHRpb25zWyBwcm9wIF0gIT09ICdmdW5jdGlvbicgKSAvLyBjaGVjayBpbnZhbGlkIGNhbGxiYWNrXG5cdFx0XHRcdHRoaXNbIHByb3AgXSA9IHVuZGVmaW5lZDtcblx0XHRcdGVsc2UgaWYgKCB2YWxpZFByb3BzLmluY2x1ZGVzKCBwcm9wICkgKSAvLyBzZXQgb25seSB2YWxpZCBwcm9wZXJ0aWVzXG5cdFx0XHRcdHRoaXNbIHByb3AgXSA9IG9wdGlvbnNbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyBkZXByZWNhdGVkIC0gbW92ZSB0aGlzIHRvIHRoZSBjb25zdHJ1Y3RvciBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlIChgc3RhcnRgIHNob3VsZCBiZSBjb25zdHJ1Y3Rvci1zcGVjaWZpYylcblx0XHRpZiAoIG9wdGlvbnMuc3RhcnQgIT09IHVuZGVmaW5lZCApXG5cdFx0XHR0aGlzLnRvZ2dsZUFuYWx5emVyKCBvcHRpb25zLnN0YXJ0ICk7XG5cdH1cblxufVxuXG5leHBvcnQgeyBBdWRpb01vdGlvbkFuYWx5emVyIH07XG5leHBvcnQgZGVmYXVsdCBBdWRpb01vdGlvbkFuYWx5emVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js\n");

/***/ })

};
;